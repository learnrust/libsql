use ::libc;
extern "C" {
    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;
    fn memcmp(
        _: *const libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> libc::c_int;
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn memcpy(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn strlen(_: *const libc::c_char) -> libc::c_ulong;
    fn qsort(
        __base: *mut libc::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
    fn __assert_fail(
        __assertion: *const libc::c_char,
        __file: *const libc::c_char,
        __line: libc::c_uint,
        __function: *const libc::c_char,
    ) -> !;
}
pub type size_t = libc::c_ulong;
pub type __compar_fn_t = Option::<
    unsafe extern "C" fn(*const libc::c_void, *const libc::c_void) -> libc::c_int,
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Keyword {
    pub zName: *mut libc::c_char,
    pub zTokenType: *mut libc::c_char,
    pub mask: libc::c_int,
    pub priority: libc::c_int,
    pub id: libc::c_int,
    pub hash: libc::c_int,
    pub offset: libc::c_int,
    pub len: libc::c_int,
    pub prefix: libc::c_int,
    pub longestSuffix: libc::c_int,
    pub iNext: libc::c_int,
    pub substrId: libc::c_int,
    pub substrOffset: libc::c_int,
    pub zOrigName: [libc::c_char; 20],
}
static mut zHdr: [libc::c_char; 565] = unsafe {
    *::std::mem::transmute::<
        &[u8; 565],
        &[libc::c_char; 565],
    >(
        b"/***** This file contains automatically generated code ******\n**\n** The code in this file has been automatically generated by\n**\n**   sqlite/tool/mkkeywordhash.c\n**\n** The code in this file implements a function that determines whether\n** or not a given identifier is really an SQL keyword.  The same thing\n** might be implemented more directly using a hand-written hash table.\n** But by using this automatically generated code, the size of the code\n** is substantially reduced.  This is important for embedded applications\n** on platforms with limited memory.\n*/\n\0",
    )
};
static mut aKeywordTable: [Keyword; 150] = [
    {
        let mut init = Keyword {
            zName: b"ABORT\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_ABORT\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x80 as libc::c_int | 0x2000 as libc::c_int,
            priority: 0 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"ACTION\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_ACTION\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x200 as libc::c_int,
            priority: 0 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"ADD\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_ADD\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x1 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"AFTER\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_AFTER\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2000 as libc::c_int,
            priority: 0 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"ALL\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_ALL\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 0 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"ALTER\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_ALTER\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x1 as libc::c_int,
            priority: 0 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"ALWAYS\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_ALWAYS\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x200000 as libc::c_int,
            priority: 0 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"ANALYZE\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_ANALYZE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x4 as libc::c_int,
            priority: 0 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"AND\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_AND\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 10 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"AS\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_AS\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 10 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"ASC\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_ASC\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 0 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"ATTACH\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_ATTACH\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x8 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"AUTOINCREMENT\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            zTokenType: b"TK_AUTOINCR\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x10 as libc::c_int,
            priority: 0 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"BEFORE\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_BEFORE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2000 as libc::c_int,
            priority: 0 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"BEGIN\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_BEGIN\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"BETWEEN\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_BETWEEN\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 5 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"BY\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_BY\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 10 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"CASCADE\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_CASCADE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x200 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"CASE\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_CASE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 5 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"CAST\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_CAST\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x20 as libc::c_int,
            priority: 5 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"CHECK\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_CHECK\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"COLLATE\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_COLLATE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"COLUMN\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_COLUMNKW\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x1 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"COMMIT\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_COMMIT\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"CONFLICT\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            zTokenType: b"TK_CONFLICT\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x80 as libc::c_int,
            priority: 0 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"CONSTRAINT\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            zTokenType: b"TK_CONSTRAINT\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"CREATE\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_CREATE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 2 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"CROSS\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_JOIN_KW\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 3 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"CURRENT\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_CURRENT\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x100000 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"CURRENT_DATE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            zTokenType: b"TK_CTIME_KW\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"CURRENT_TIME\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            zTokenType: b"TK_CTIME_KW\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"CURRENT_TIMESTAMP\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            zTokenType: b"TK_CTIME_KW\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"DATABASE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            zTokenType: b"TK_DATABASE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x8 as libc::c_int,
            priority: 0 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"DEFAULT\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_DEFAULT\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"DEFERRED\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            zTokenType: b"TK_DEFERRED\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"DEFERRABLE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            zTokenType: b"TK_DEFERRABLE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x200 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"DELETE\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_DELETE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 10 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"DESC\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_DESC\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 3 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"DETACH\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_DETACH\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x8 as libc::c_int,
            priority: 0 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"DISTINCT\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            zTokenType: b"TK_DISTINCT\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 5 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"DO\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_DO\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x80000 as libc::c_int,
            priority: 2 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"DROP\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_DROP\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"END\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_END\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"EACH\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_EACH\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2000 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"ELSE\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_ELSE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 2 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"ESCAPE\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_ESCAPE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 4 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"EXCEPT\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_EXCEPT\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x40 as libc::c_int,
            priority: 4 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"EXCLUSIVE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            zTokenType: b"TK_EXCLUSIVE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"EXCLUDE\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_EXCLUDE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x100000 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"EXISTS\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_EXISTS\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 4 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"EXPLAIN\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_EXPLAIN\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x100 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"FAIL\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_FAIL\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x80 as libc::c_int | 0x2000 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"FILTER\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_FILTER\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x100000 as libc::c_int,
            priority: 4 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"FIRST\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_FIRST\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 4 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"FOLLOWING\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            zTokenType: b"TK_FOLLOWING\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x100000 as libc::c_int,
            priority: 4 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"FOR\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_FOR\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2000 as libc::c_int,
            priority: 2 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"FOREIGN\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_FOREIGN\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x200 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"FROM\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_FROM\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 10 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"FULL\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_JOIN_KW\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 3 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"FUNCTION\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            zTokenType: b"TK_FUNCTION\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"GENERATED\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            zTokenType: b"TK_GENERATED\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"GLOB\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_LIKE_KW\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 3 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"GROUP\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_GROUP\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 5 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"GROUPS\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_GROUPS\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x100000 as libc::c_int,
            priority: 2 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"HAVING\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_HAVING\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 5 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"IF\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_IF\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 2 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"IGNORE\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_IGNORE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x80 as libc::c_int | 0x2000 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"IMMEDIATE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            zTokenType: b"TK_IMMEDIATE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"IN\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_IN\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 10 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"INDEX\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_INDEX\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"INDEXED\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_INDEXED\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 0 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"INITIALLY\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            zTokenType: b"TK_INITIALLY\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x200 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"INNER\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_JOIN_KW\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"INSERT\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_INSERT\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 10 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"INSTEAD\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_INSTEAD\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2000 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"INTERSECT\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            zTokenType: b"TK_INTERSECT\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x40 as libc::c_int,
            priority: 5 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"INTO\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_INTO\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 10 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"IS\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_IS\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 5 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"ISNULL\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_ISNULL\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 5 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"JOIN\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_JOIN\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 5 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"KEY\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_KEY\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"LANGUAGE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            zTokenType: b"TK_LANGUAGE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 0 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"LAST\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_LAST\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 4 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"LEFT\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_JOIN_KW\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 5 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"LIKE\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_LIKE_KW\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 5 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"LIMIT\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_LIMIT\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 3 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"MATCH\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_MATCH\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 2 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"MATERIALIZED\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            zTokenType: b"TK_MATERIALIZED\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x40000 as libc::c_int,
            priority: 12 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"NATURAL\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_JOIN_KW\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 3 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"NO\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_NO\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x200 as libc::c_int | 0x100000 as libc::c_int,
            priority: 2 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"NOT\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_NOT\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 10 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"NOTHING\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_NOTHING\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x80000 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"NOTNULL\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_NOTNULL\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 3 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"NULL\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_NULL\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 10 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"NULLS\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_NULLS\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 3 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"OF\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_OF\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 3 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"OFFSET\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_OFFSET\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"ON\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_ON\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"OR\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_OR\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 9 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"ORDER\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_ORDER\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 10 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"OTHERS\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_OTHERS\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x100000 as libc::c_int,
            priority: 3 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"OUTER\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_JOIN_KW\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 5 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"OVER\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_OVER\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x100000 as libc::c_int,
            priority: 3 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"PARTITION\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            zTokenType: b"TK_PARTITION\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x100000 as libc::c_int,
            priority: 3 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"PLAN\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_PLAN\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x100 as libc::c_int,
            priority: 0 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"PRAGMA\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_PRAGMA\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x400 as libc::c_int,
            priority: 0 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"PRECEDING\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            zTokenType: b"TK_PRECEDING\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x100000 as libc::c_int,
            priority: 3 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"PRIMARY\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_PRIMARY\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"QUERY\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_QUERY\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x100 as libc::c_int,
            priority: 0 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"RAISE\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_RAISE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2000 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"RANDOM\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_RANDOM\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"RANGE\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_RANGE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x100000 as libc::c_int,
            priority: 3 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"RECURSIVE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            zTokenType: b"TK_RECURSIVE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x40000 as libc::c_int,
            priority: 3 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"REFERENCES\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            zTokenType: b"TK_REFERENCES\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x200 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"REGEXP\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_LIKE_KW\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 3 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"REINDEX\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_REINDEX\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x800 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"RELEASE\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_RELEASE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"RENAME\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_RENAME\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x1 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"REPLACE\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_REPLACE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x80 as libc::c_int,
            priority: 10 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"RESTRICT\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            zTokenType: b"TK_RESTRICT\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x200 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"RETURNING\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            zTokenType: b"TK_RETURNING\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x400000 as libc::c_int,
            priority: 10 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"RIGHT\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_JOIN_KW\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 0 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"ROLLBACK\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            zTokenType: b"TK_ROLLBACK\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"ROW\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_ROW\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2000 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"ROWS\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_ROWS\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"SAVEPOINT\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            zTokenType: b"TK_SAVEPOINT\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"SELECT\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_SELECT\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 10 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"SET\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_SET\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 10 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"TABLE\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_TABLE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"TEMP\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_TEMP\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"TEMPORARY\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            zTokenType: b"TK_TEMP\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"THEN\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_THEN\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 3 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"TIES\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_TIES\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x100000 as libc::c_int,
            priority: 3 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"TO\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_TO\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 3 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"TRANSACTION\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            zTokenType: b"TK_TRANSACTION\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"TRIGGER\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_TRIGGER\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2000 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"UNBOUNDED\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            zTokenType: b"TK_UNBOUNDED\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x100000 as libc::c_int,
            priority: 3 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"UNION\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_UNION\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x40 as libc::c_int,
            priority: 3 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"UNIQUE\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_UNIQUE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"UPDATE\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_UPDATE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 10 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"USING\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_USING\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 8 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"VACUUM\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_VACUUM\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x4000 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"VALUES\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_VALUES\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 10 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"VIEW\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_VIEW\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x8000 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"VIRTUAL\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_VIRTUAL\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x10000 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"WHEN\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_WHEN\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"WHERE\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_WHERE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 10 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"WINDOW\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_WINDOW\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x100000 as libc::c_int,
            priority: 3 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"WITH\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_WITH\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x40000 as libc::c_int,
            priority: 4 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
    {
        let mut init = Keyword {
            zName: b"WITHOUT\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            zTokenType: b"TK_WITHOUT\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mask: 0x2 as libc::c_int,
            priority: 1 as libc::c_int,
            id: 0,
            hash: 0,
            offset: 0,
            len: 0,
            prefix: 0,
            longestSuffix: 0,
            iNext: 0,
            substrId: 0,
            substrOffset: 0,
            zOrigName: [0; 20],
        };
        init
    },
];
static mut nKeyword: libc::c_int = 0;
unsafe extern "C" fn keywordCompare1(
    mut a: *const libc::c_void,
    mut b: *const libc::c_void,
) -> libc::c_int {
    let mut pA: *const Keyword = a as *mut Keyword;
    let mut pB: *const Keyword = b as *mut Keyword;
    let mut n: libc::c_int = (*pA).len - (*pB).len;
    if n == 0 as libc::c_int {
        n = strcmp((*pA).zName, (*pB).zName);
    }
    if n != 0 as libc::c_int {} else {
        __assert_fail(
            b"n!=0\0" as *const u8 as *const libc::c_char,
            b"/home/me/github/learnrust/libsql/tool/mkkeywordhash.c\0" as *const u8
                as *const libc::c_char,
            344 as libc::c_int as libc::c_uint,
            (*::std::mem::transmute::<
                &[u8; 48],
                &[libc::c_char; 48],
            >(b"int keywordCompare1(const void *, const void *)\0"))
                .as_ptr(),
        );
    }
    return n;
}
unsafe extern "C" fn keywordCompare2(
    mut a: *const libc::c_void,
    mut b: *const libc::c_void,
) -> libc::c_int {
    let mut pA: *const Keyword = a as *mut Keyword;
    let mut pB: *const Keyword = b as *mut Keyword;
    let mut n: libc::c_int = (*pB).longestSuffix - (*pA).longestSuffix;
    if n == 0 as libc::c_int {
        n = strcmp((*pA).zName, (*pB).zName);
    }
    if n != 0 as libc::c_int {} else {
        __assert_fail(
            b"n!=0\0" as *const u8 as *const libc::c_char,
            b"/home/me/github/learnrust/libsql/tool/mkkeywordhash.c\0" as *const u8
                as *const libc::c_char,
            354 as libc::c_int as libc::c_uint,
            (*::std::mem::transmute::<
                &[u8; 48],
                &[libc::c_char; 48],
            >(b"int keywordCompare2(const void *, const void *)\0"))
                .as_ptr(),
        );
    }
    return n;
}
unsafe extern "C" fn keywordCompare3(
    mut a: *const libc::c_void,
    mut b: *const libc::c_void,
) -> libc::c_int {
    let mut pA: *const Keyword = a as *mut Keyword;
    let mut pB: *const Keyword = b as *mut Keyword;
    let mut n: libc::c_int = (*pA).offset - (*pB).offset;
    if n == 0 as libc::c_int {
        n = (*pB).id - (*pA).id;
    }
    if n != 0 as libc::c_int {} else {
        __assert_fail(
            b"n!=0\0" as *const u8 as *const libc::c_char,
            b"/home/me/github/learnrust/libsql/tool/mkkeywordhash.c\0" as *const u8
                as *const libc::c_char,
            362 as libc::c_int as libc::c_uint,
            (*::std::mem::transmute::<
                &[u8; 48],
                &[libc::c_char; 48],
            >(b"int keywordCompare3(const void *, const void *)\0"))
                .as_ptr(),
        );
    }
    return n;
}
unsafe extern "C" fn findById(mut id: libc::c_int) -> *mut Keyword {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < nKeyword {
        if aKeywordTable[i as usize].id == id {
            break;
        }
        i += 1;
    }
    return &mut *aKeywordTable.as_mut_ptr().offset(i as isize) as *mut Keyword;
}
unsafe extern "C" fn reorder(mut pFrom: *mut libc::c_int) {
    let mut i: libc::c_int = *pFrom - 1 as libc::c_int;
    let mut j: libc::c_int = 0;
    if i < 0 as libc::c_int {
        return;
    }
    j = aKeywordTable[i as usize].iNext;
    if j == 0 as libc::c_int {
        return;
    }
    j -= 1;
    if aKeywordTable[i as usize].priority >= aKeywordTable[j as usize].priority {
        return;
    }
    aKeywordTable[i as usize].iNext = aKeywordTable[j as usize].iNext;
    aKeywordTable[j as usize].iNext = i + 1 as libc::c_int;
    *pFrom = j + 1 as libc::c_int;
    reorder(&mut (*aKeywordTable.as_mut_ptr().offset(i as isize)).iNext);
}
unsafe fn main_0(
    mut argc: libc::c_int,
    mut argv: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut k: libc::c_int = 0;
    let mut h: libc::c_int = 0;
    let mut bestSize: libc::c_int = 0;
    let mut bestCount: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    let mut nChar: libc::c_int = 0;
    let mut totalLen: libc::c_int = 0 as libc::c_int;
    let mut aKWHash: [libc::c_int; 1000] = [0; 1000];
    let mut zKWText: [libc::c_char; 2000] = [0; 2000];
    j = 0 as libc::c_int;
    i = j;
    while i < nKeyword {
        if !(aKeywordTable[i as usize].mask == 0 as libc::c_int) {
            if j < i {
                aKeywordTable[j as usize] = aKeywordTable[i as usize];
            }
            j += 1;
        }
        i += 1;
    }
    nKeyword = j;
    i = 0 as libc::c_int;
    while i < nKeyword {
        let mut p: *mut Keyword = &mut *aKeywordTable.as_mut_ptr().offset(i as isize)
            as *mut Keyword;
        (*p).len = strlen((*p).zName) as libc::c_int;
        if ((*p).len as libc::c_ulong)
            < ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
        {} else {
            __assert_fail(
                b"p->len<sizeof(p->zOrigName)\0" as *const u8 as *const libc::c_char,
                b"/home/me/github/learnrust/libsql/tool/mkkeywordhash.c\0" as *const u8
                    as *const libc::c_char,
                430 as libc::c_int as libc::c_uint,
                (*::std::mem::transmute::<
                    &[u8; 23],
                    &[libc::c_char; 23],
                >(b"int main(int, char **)\0"))
                    .as_ptr(),
            );
        }
        memcpy(
            ((*p).zOrigName).as_mut_ptr() as *mut libc::c_void,
            (*p).zName as *const libc::c_void,
            ((*p).len + 1 as libc::c_int) as libc::c_ulong,
        );
        totalLen += (*p).len;
        (*p)
            .hash = (0x20 as libc::c_int
            | *((*p).zName).offset(0 as libc::c_int as isize) as libc::c_int)
            * 4 as libc::c_int
            ^ (0x20 as libc::c_int
                | *((*p).zName).offset(((*p).len - 1 as libc::c_int) as isize)
                    as libc::c_int) * 3 as libc::c_int ^ (*p).len * 1 as libc::c_int;
        (*p).id = i + 1 as libc::c_int;
        i += 1;
    }
    qsort(
        aKeywordTable.as_mut_ptr() as *mut libc::c_void,
        nKeyword as size_t,
        ::std::mem::size_of::<Keyword>() as libc::c_ulong,
        Some(
            keywordCompare1
                as unsafe extern "C" fn(
                    *const libc::c_void,
                    *const libc::c_void,
                ) -> libc::c_int,
        ),
    );
    i = nKeyword - 2 as libc::c_int;
    while i >= 0 as libc::c_int {
        let mut p_0: *mut Keyword = &mut *aKeywordTable.as_mut_ptr().offset(i as isize)
            as *mut Keyword;
        j = nKeyword - 1 as libc::c_int;
        while j > i && (*p_0).substrId == 0 as libc::c_int {
            let mut pOther: *mut Keyword = &mut *aKeywordTable
                .as_mut_ptr()
                .offset(j as isize) as *mut Keyword;
            if !((*pOther).substrId != 0) {
                if !((*pOther).len <= (*p_0).len) {
                    k = 0 as libc::c_int;
                    while k <= (*pOther).len - (*p_0).len {
                        if memcmp(
                            (*p_0).zName as *const libc::c_void,
                            &mut *((*pOther).zName).offset(k as isize)
                                as *mut libc::c_char as *const libc::c_void,
                            (*p_0).len as libc::c_ulong,
                        ) == 0 as libc::c_int
                        {
                            (*p_0).substrId = (*pOther).id;
                            (*p_0).substrOffset = k;
                            break;
                        } else {
                            k += 1;
                        }
                    }
                }
            }
            j -= 1;
        }
        i -= 1;
    }
    i = 0 as libc::c_int;
    while i < nKeyword {
        let mut p_1: *mut Keyword = &mut *aKeywordTable.as_mut_ptr().offset(i as isize)
            as *mut Keyword;
        if !((*p_1).substrId != 0) {
            j = 0 as libc::c_int;
            while j < nKeyword {
                let mut pOther_0: *mut Keyword = 0 as *mut Keyword;
                if !(j == i) {
                    pOther_0 = &mut *aKeywordTable.as_mut_ptr().offset(j as isize)
                        as *mut Keyword;
                    if !((*pOther_0).substrId != 0) {
                        k = (*p_1).longestSuffix + 1 as libc::c_int;
                        while k < (*p_1).len && k < (*pOther_0).len {
                            if memcmp(
                                &mut *((*p_1).zName).offset(((*p_1).len - k) as isize)
                                    as *mut libc::c_char as *const libc::c_void,
                                (*pOther_0).zName as *const libc::c_void,
                                k as libc::c_ulong,
                            ) == 0 as libc::c_int
                            {
                                (*p_1).longestSuffix = k;
                            }
                            k += 1;
                        }
                    }
                }
                j += 1;
            }
        }
        i += 1;
    }
    qsort(
        aKeywordTable.as_mut_ptr() as *mut libc::c_void,
        nKeyword as size_t,
        ::std::mem::size_of::<Keyword>() as libc::c_ulong,
        Some(
            keywordCompare2
                as unsafe extern "C" fn(
                    *const libc::c_void,
                    *const libc::c_void,
                ) -> libc::c_int,
        ),
    );
    nChar = 0 as libc::c_int;
    i = 0 as libc::c_int;
    while i < nKeyword {
        let mut p_2: *mut Keyword = &mut *aKeywordTable.as_mut_ptr().offset(i as isize)
            as *mut Keyword;
        if !((*p_2).offset > 0 as libc::c_int || (*p_2).substrId != 0) {
            (*p_2).offset = nChar;
            nChar += (*p_2).len;
            k = (*p_2).len - 1 as libc::c_int;
            while k >= 1 as libc::c_int {
                j = i + 1 as libc::c_int;
                while j < nKeyword {
                    let mut pOther_1: *mut Keyword = &mut *aKeywordTable
                        .as_mut_ptr()
                        .offset(j as isize) as *mut Keyword;
                    if !((*pOther_1).offset > 0 as libc::c_int
                        || (*pOther_1).substrId != 0)
                    {
                        if !((*pOther_1).len <= k) {
                            if memcmp(
                                &mut *((*p_2).zName).offset(((*p_2).len - k) as isize)
                                    as *mut libc::c_char as *const libc::c_void,
                                (*pOther_1).zName as *const libc::c_void,
                                k as libc::c_ulong,
                            ) == 0 as libc::c_int
                            {
                                p_2 = pOther_1;
                                (*p_2).offset = nChar - k;
                                nChar = (*p_2).offset + (*p_2).len;
                                let ref mut fresh0 = (*p_2).zName;
                                *fresh0 = (*fresh0).offset(k as isize);
                                (*p_2).len -= k;
                                (*p_2).prefix = k;
                                j = i;
                                k = (*p_2).len;
                            }
                        }
                    }
                    j += 1;
                }
                k -= 1;
            }
        }
        i += 1;
    }
    i = 0 as libc::c_int;
    while i < nKeyword {
        let mut p_3: *mut Keyword = &mut *aKeywordTable.as_mut_ptr().offset(i as isize)
            as *mut Keyword;
        if (*p_3).substrId != 0 {
            (*p_3).offset = (*findById((*p_3).substrId)).offset + (*p_3).substrOffset;
        }
        i += 1;
    }
    qsort(
        aKeywordTable.as_mut_ptr() as *mut libc::c_void,
        nKeyword as size_t,
        ::std::mem::size_of::<Keyword>() as libc::c_ulong,
        Some(
            keywordCompare3
                as unsafe extern "C" fn(
                    *const libc::c_void,
                    *const libc::c_void,
                ) -> libc::c_int,
        ),
    );
    bestSize = nKeyword;
    bestCount = nKeyword * nKeyword;
    i = nKeyword / 2 as libc::c_int;
    while i <= 2 as libc::c_int * nKeyword {
        if !(i <= 0 as libc::c_int) {
            j = 0 as libc::c_int;
            while j < i {
                aKWHash[j as usize] = 0 as libc::c_int;
                j += 1;
            }
            j = 0 as libc::c_int;
            while j < nKeyword {
                h = aKeywordTable[j as usize].hash % i;
                aKWHash[h as usize] *= 2 as libc::c_int;
                aKWHash[h as usize] += 1;
                j += 1;
            }
            count = 0 as libc::c_int;
            j = count;
            while j < i {
                count += aKWHash[j as usize];
                j += 1;
            }
            if count < bestCount {
                bestCount = count;
                bestSize = i;
            }
        }
        i += 1;
    }
    i = 0 as libc::c_int;
    while i < bestSize {
        aKWHash[i as usize] = 0 as libc::c_int;
        i += 1;
    }
    i = 0 as libc::c_int;
    while i < nKeyword {
        h = aKeywordTable[i as usize].hash % bestSize;
        aKeywordTable[i as usize].iNext = aKWHash[h as usize];
        aKWHash[h as usize] = i + 1 as libc::c_int;
        reorder(&mut *aKWHash.as_mut_ptr().offset(h as isize));
        i += 1;
    }
    printf(b"%s\0" as *const u8 as *const libc::c_char, zHdr.as_ptr());
    printf(b"/* Hash score: %d */\n\0" as *const u8 as *const libc::c_char, bestCount);
    printf(
        b"/* zKWText[] encodes %d bytes of keyword text in %d bytes */\n\0" as *const u8
            as *const libc::c_char,
        totalLen + nKeyword,
        nChar + 1 as libc::c_int,
    );
    k = 0 as libc::c_int;
    j = k;
    i = j;
    while i < nKeyword {
        let mut p_4: *mut Keyword = &mut *aKeywordTable.as_mut_ptr().offset(i as isize)
            as *mut Keyword;
        if !((*p_4).substrId != 0) {
            memcpy(
                &mut *zKWText.as_mut_ptr().offset(k as isize) as *mut libc::c_char
                    as *mut libc::c_void,
                (*p_4).zName as *const libc::c_void,
                (*p_4).len as libc::c_ulong,
            );
            k += (*p_4).len;
            if j + (*p_4).len > 70 as libc::c_int {
                printf(
                    b"%*s */\n\0" as *const u8 as *const libc::c_char,
                    74 as libc::c_int - j,
                    b"\0" as *const u8 as *const libc::c_char,
                );
                j = 0 as libc::c_int;
            }
            if j == 0 as libc::c_int {
                printf(b"/*   \0" as *const u8 as *const libc::c_char);
                j = 8 as libc::c_int;
            }
            printf(b"%s\0" as *const u8 as *const libc::c_char, (*p_4).zName);
            j += (*p_4).len;
        }
        i += 1;
    }
    if j > 0 as libc::c_int {
        printf(
            b"%*s */\n\0" as *const u8 as *const libc::c_char,
            74 as libc::c_int - j,
            b"\0" as *const u8 as *const libc::c_char,
        );
    }
    printf(
        b"static const char zKWText[%d] = {\n\0" as *const u8 as *const libc::c_char,
        nChar,
    );
    zKWText[nChar as usize] = 0 as libc::c_int as libc::c_char;
    j = 0 as libc::c_int;
    i = j;
    while i < k {
        if j == 0 as libc::c_int {
            printf(b"  \0" as *const u8 as *const libc::c_char);
        }
        if zKWText[i as usize] as libc::c_int == 0 as libc::c_int {
            printf(b"0\0" as *const u8 as *const libc::c_char);
        } else {
            printf(
                b"'%c',\0" as *const u8 as *const libc::c_char,
                zKWText[i as usize] as libc::c_int,
            );
        }
        j += 4 as libc::c_int;
        if j > 68 as libc::c_int {
            printf(b"\n\0" as *const u8 as *const libc::c_char);
            j = 0 as libc::c_int;
        }
        i += 1;
    }
    if j > 0 as libc::c_int {
        printf(b"\n\0" as *const u8 as *const libc::c_char);
    }
    printf(b"};\n\0" as *const u8 as *const libc::c_char);
    printf(
        b"/* aKWHash[i] is the hash value for the i-th keyword */\n\0" as *const u8
            as *const libc::c_char,
    );
    printf(
        b"static const unsigned char aKWHash[%d] = {\n\0" as *const u8
            as *const libc::c_char,
        bestSize,
    );
    j = 0 as libc::c_int;
    i = j;
    while i < bestSize {
        if j == 0 as libc::c_int {
            printf(b"  \0" as *const u8 as *const libc::c_char);
        }
        printf(b" %3d,\0" as *const u8 as *const libc::c_char, aKWHash[i as usize]);
        j += 1;
        if j > 12 as libc::c_int {
            printf(b"\n\0" as *const u8 as *const libc::c_char);
            j = 0 as libc::c_int;
        }
        i += 1;
    }
    printf(
        b"%s};\n\0" as *const u8 as *const libc::c_char,
        if j == 0 as libc::c_int {
            b"\0" as *const u8 as *const libc::c_char
        } else {
            b"\n\0" as *const u8 as *const libc::c_char
        },
    );
    printf(
        b"/* aKWNext[] forms the hash collision chain.  If aKWHash[i]==0\n\0"
            as *const u8 as *const libc::c_char,
    );
    printf(
        b"** then the i-th keyword has no more hash collisions.  Otherwise,\n\0"
            as *const u8 as *const libc::c_char,
    );
    printf(
        b"** the next keyword with the same hash is aKWHash[i]-1. */\n\0" as *const u8
            as *const libc::c_char,
    );
    printf(
        b"static const unsigned char aKWNext[%d] = {\n\0" as *const u8
            as *const libc::c_char,
        nKeyword,
    );
    j = 0 as libc::c_int;
    i = j;
    while i < nKeyword {
        if j == 0 as libc::c_int {
            printf(b"  \0" as *const u8 as *const libc::c_char);
        }
        printf(
            b" %3d,\0" as *const u8 as *const libc::c_char,
            aKeywordTable[i as usize].iNext,
        );
        j += 1;
        if j > 12 as libc::c_int {
            printf(b"\n\0" as *const u8 as *const libc::c_char);
            j = 0 as libc::c_int;
        }
        i += 1;
    }
    printf(
        b"%s};\n\0" as *const u8 as *const libc::c_char,
        if j == 0 as libc::c_int {
            b"\0" as *const u8 as *const libc::c_char
        } else {
            b"\n\0" as *const u8 as *const libc::c_char
        },
    );
    printf(
        b"/* aKWLen[i] is the length (in bytes) of the i-th keyword */\n\0" as *const u8
            as *const libc::c_char,
    );
    printf(
        b"static const unsigned char aKWLen[%d] = {\n\0" as *const u8
            as *const libc::c_char,
        nKeyword,
    );
    j = 0 as libc::c_int;
    i = j;
    while i < nKeyword {
        if j == 0 as libc::c_int {
            printf(b"  \0" as *const u8 as *const libc::c_char);
        }
        printf(
            b" %3d,\0" as *const u8 as *const libc::c_char,
            aKeywordTable[i as usize].len + aKeywordTable[i as usize].prefix,
        );
        j += 1;
        if j > 12 as libc::c_int {
            printf(b"\n\0" as *const u8 as *const libc::c_char);
            j = 0 as libc::c_int;
        }
        i += 1;
    }
    printf(
        b"%s};\n\0" as *const u8 as *const libc::c_char,
        if j == 0 as libc::c_int {
            b"\0" as *const u8 as *const libc::c_char
        } else {
            b"\n\0" as *const u8 as *const libc::c_char
        },
    );
    printf(
        b"/* aKWOffset[i] is the index into zKWText[] of the start of\n\0" as *const u8
            as *const libc::c_char,
    );
    printf(
        b"** the text for the i-th keyword. */\n\0" as *const u8 as *const libc::c_char,
    );
    printf(
        b"static const unsigned short int aKWOffset[%d] = {\n\0" as *const u8
            as *const libc::c_char,
        nKeyword,
    );
    j = 0 as libc::c_int;
    i = j;
    while i < nKeyword {
        if j == 0 as libc::c_int {
            printf(b"  \0" as *const u8 as *const libc::c_char);
        }
        printf(
            b" %3d,\0" as *const u8 as *const libc::c_char,
            aKeywordTable[i as usize].offset,
        );
        j += 1;
        if j > 12 as libc::c_int {
            printf(b"\n\0" as *const u8 as *const libc::c_char);
            j = 0 as libc::c_int;
        }
        i += 1;
    }
    printf(
        b"%s};\n\0" as *const u8 as *const libc::c_char,
        if j == 0 as libc::c_int {
            b"\0" as *const u8 as *const libc::c_char
        } else {
            b"\n\0" as *const u8 as *const libc::c_char
        },
    );
    printf(
        b"/* aKWCode[i] is the parser symbol code for the i-th keyword */\n\0"
            as *const u8 as *const libc::c_char,
    );
    printf(
        b"static const unsigned char aKWCode[%d] = {\n\0" as *const u8
            as *const libc::c_char,
        nKeyword,
    );
    j = 0 as libc::c_int;
    i = j;
    while i < nKeyword {
        let mut zToken: *mut libc::c_char = aKeywordTable[i as usize].zTokenType;
        if j == 0 as libc::c_int {
            printf(b"  \0" as *const u8 as *const libc::c_char);
        }
        printf(
            b"%s,%*s\0" as *const u8 as *const libc::c_char,
            zToken,
            (14 as libc::c_int as libc::c_ulong).wrapping_sub(strlen(zToken))
                as libc::c_int,
            b"\0" as *const u8 as *const libc::c_char,
        );
        j += 1;
        if j >= 5 as libc::c_int {
            printf(b"\n\0" as *const u8 as *const libc::c_char);
            j = 0 as libc::c_int;
        }
        i += 1;
    }
    printf(
        b"%s};\n\0" as *const u8 as *const libc::c_char,
        if j == 0 as libc::c_int {
            b"\0" as *const u8 as *const libc::c_char
        } else {
            b"\n\0" as *const u8 as *const libc::c_char
        },
    );
    printf(b"/* Hash table decoded:\n\0" as *const u8 as *const libc::c_char);
    i = 0 as libc::c_int;
    while i < bestSize {
        j = aKWHash[i as usize];
        printf(b"** %3d:\0" as *const u8 as *const libc::c_char, i);
        while j != 0 {
            printf(
                b" %s\0" as *const u8 as *const libc::c_char,
                (aKeywordTable[(j - 1 as libc::c_int) as usize].zOrigName).as_mut_ptr(),
            );
            j = aKeywordTable[(j - 1 as libc::c_int) as usize].iNext;
        }
        printf(b"\n\0" as *const u8 as *const libc::c_char);
        i += 1;
    }
    printf(b"*/\n\0" as *const u8 as *const libc::c_char);
    printf(
        b"/* Check to see if z[0..n-1] is a keyword. If it is, write the\n\0"
            as *const u8 as *const libc::c_char,
    );
    printf(
        b"** parser symbol code for that keyword into *pType.  Always\n\0" as *const u8
            as *const libc::c_char,
    );
    printf(
        b"** return the integer n (the length of the token). */\n\0" as *const u8
            as *const libc::c_char,
    );
    printf(
        b"static int keywordCode(const char *z, int n, int *pType){\n\0" as *const u8
            as *const libc::c_char,
    );
    printf(b"  int i, j;\n\0" as *const u8 as *const libc::c_char);
    printf(b"  const char *zKW;\n\0" as *const u8 as *const libc::c_char);
    printf(b"  if( n>=2 ){\n\0" as *const u8 as *const libc::c_char);
    printf(
        b"    i = ((charMap(z[0])*%d) %c\0" as *const u8 as *const libc::c_char,
        4 as libc::c_int,
        '^' as i32,
    );
    printf(
        b" (charMap(z[n-1])*%d) %c\0" as *const u8 as *const libc::c_char,
        3 as libc::c_int,
        '^' as i32,
    );
    printf(
        b" n*%d) %% %d;\n\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
        bestSize,
    );
    printf(
        b"    for(i=((int)aKWHash[i])-1; i>=0; i=((int)aKWNext[i])-1){\n\0" as *const u8
            as *const libc::c_char,
    );
    printf(
        b"      if( aKWLen[i]!=n ) continue;\n\0" as *const u8 as *const libc::c_char,
    );
    printf(
        b"      zKW = &zKWText[aKWOffset[i]];\n\0" as *const u8 as *const libc::c_char,
    );
    printf(b"#ifdef SQLITE_ASCII\n\0" as *const u8 as *const libc::c_char);
    printf(
        b"      if( (z[0]&~0x20)!=zKW[0] ) continue;\n\0" as *const u8
            as *const libc::c_char,
    );
    printf(
        b"      if( (z[1]&~0x20)!=zKW[1] ) continue;\n\0" as *const u8
            as *const libc::c_char,
    );
    printf(b"      j = 2;\n\0" as *const u8 as *const libc::c_char);
    printf(
        b"      while( j<n && (z[j]&~0x20)==zKW[j] ){ j++; }\n\0" as *const u8
            as *const libc::c_char,
    );
    printf(b"#endif\n\0" as *const u8 as *const libc::c_char);
    printf(b"#ifdef SQLITE_EBCDIC\n\0" as *const u8 as *const libc::c_char);
    printf(
        b"      if( toupper(z[0])!=zKW[0] ) continue;\n\0" as *const u8
            as *const libc::c_char,
    );
    printf(
        b"      if( toupper(z[1])!=zKW[1] ) continue;\n\0" as *const u8
            as *const libc::c_char,
    );
    printf(b"      j = 2;\n\0" as *const u8 as *const libc::c_char);
    printf(
        b"      while( j<n && toupper(z[j])==zKW[j] ){ j++; }\n\0" as *const u8
            as *const libc::c_char,
    );
    printf(b"#endif\n\0" as *const u8 as *const libc::c_char);
    printf(b"      if( j<n ) continue;\n\0" as *const u8 as *const libc::c_char);
    i = 0 as libc::c_int;
    while i < nKeyword {
        printf(
            b"      testcase( i==%d ); /* %s */\n\0" as *const u8 as *const libc::c_char,
            i,
            (aKeywordTable[i as usize].zOrigName).as_mut_ptr(),
        );
        i += 1;
    }
    printf(b"      *pType = aKWCode[i];\n\0" as *const u8 as *const libc::c_char);
    printf(b"      break;\n\0" as *const u8 as *const libc::c_char);
    printf(b"    }\n\0" as *const u8 as *const libc::c_char);
    printf(b"  }\n\0" as *const u8 as *const libc::c_char);
    printf(b"  return n;\n\0" as *const u8 as *const libc::c_char);
    printf(b"}\n\0" as *const u8 as *const libc::c_char);
    printf(
        b"int sqlite3KeywordCode(const unsigned char *z, int n){\n\0" as *const u8
            as *const libc::c_char,
    );
    printf(b"  int id = TK_ID;\n\0" as *const u8 as *const libc::c_char);
    printf(b"  keywordCode((char*)z, n, &id);\n\0" as *const u8 as *const libc::c_char);
    printf(b"  return id;\n\0" as *const u8 as *const libc::c_char);
    printf(b"}\n\0" as *const u8 as *const libc::c_char);
    printf(
        b"#define SQLITE_N_KEYWORD %d\n\0" as *const u8 as *const libc::c_char,
        nKeyword,
    );
    printf(
        b"int sqlite3_keyword_name(int i,const char **pzName,int *pnName){\n\0"
            as *const u8 as *const libc::c_char,
    );
    printf(
        b"  if( i<0 || i>=SQLITE_N_KEYWORD ) return SQLITE_ERROR;\n\0" as *const u8
            as *const libc::c_char,
    );
    printf(
        b"  *pzName = zKWText + aKWOffset[i];\n\0" as *const u8 as *const libc::c_char,
    );
    printf(b"  *pnName = aKWLen[i];\n\0" as *const u8 as *const libc::c_char);
    printf(b"  return SQLITE_OK;\n\0" as *const u8 as *const libc::c_char);
    printf(b"}\n\0" as *const u8 as *const libc::c_char);
    printf(
        b"int sqlite3_keyword_count(void){ return SQLITE_N_KEYWORD; }\n\0" as *const u8
            as *const libc::c_char,
    );
    printf(
        b"int sqlite3_keyword_check(const char *zName, int nName){\n\0" as *const u8
            as *const libc::c_char,
    );
    printf(
        b"  return TK_ID!=sqlite3KeywordCode((const u8*)zName, nName);\n\0" as *const u8
            as *const libc::c_char,
    );
    printf(b"}\n\0" as *const u8 as *const libc::c_char);
    return 0 as libc::c_int;
}
pub fn main() {
    let mut args: Vec::<*mut libc::c_char> = Vec::new();
    for arg in ::std::env::args() {
        args.push(
            (::std::ffi::CString::new(arg))
                .expect("Failed to convert argument into CString.")
                .into_raw(),
        );
    }
    args.push(::std::ptr::null_mut());
    unsafe {
        ::std::process::exit(
            main_0(
                (args.len() - 1) as libc::c_int,
                args.as_mut_ptr() as *mut *mut libc::c_char,
            ) as i32,
        )
    }
}
unsafe extern "C" fn run_static_initializers() {
    nKeyword = (::std::mem::size_of::<[Keyword; 150]>() as libc::c_ulong)
        .wrapping_div(::std::mem::size_of::<Keyword>() as libc::c_ulong) as libc::c_int;
}
#[used]
#[cfg_attr(target_os = "linux", link_section = ".init_array")]
#[cfg_attr(target_os = "windows", link_section = ".CRT$XIB")]
#[cfg_attr(target_os = "macos", link_section = "__DATA,__mod_init_func")]
static INIT_ARRAY: [unsafe extern "C" fn(); 1] = [run_static_initializers];
