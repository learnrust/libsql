use ::libc;
extern "C" {
    pub type _IO_wide_data;
    pub type _IO_codecvt;
    pub type _IO_marker;
    pub type sqlite3;
    pub type sqlite3_mutex;
    pub type sqlite3_api_routines;
    pub type sqlite3_stmt;
    pub type sqlite3_value;
    pub type sqlite3_context;
    pub type sqlite3_str;
    pub type sqlite3_backup;
    pub type __dirstream;
    pub type internal_state;
    fn strtol(
        _: *const libc::c_char,
        _: *mut *mut libc::c_char,
        _: libc::c_int,
    ) -> libc::c_long;
    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;
    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;
    fn free(_: *mut libc::c_void);
    fn exit(_: libc::c_int) -> !;
    fn getenv(__name: *const libc::c_char) -> *mut libc::c_char;
    fn system(__command: *const libc::c_char) -> libc::c_int;
    fn memcpy(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memmove(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memset(
        _: *mut libc::c_void,
        _: libc::c_int,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memcmp(
        _: *const libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> libc::c_int;
    fn strncpy(
        _: *mut libc::c_char,
        _: *const libc::c_char,
        _: libc::c_ulong,
    ) -> *mut libc::c_char;
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn strncmp(
        _: *const libc::c_char,
        _: *const libc::c_char,
        _: libc::c_ulong,
    ) -> libc::c_int;
    fn strdup(_: *const libc::c_char) -> *mut libc::c_char;
    fn strchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
    fn strstr(_: *const libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strlen(_: *const libc::c_char) -> libc::c_ulong;
    static mut stdin: *mut FILE;
    static mut stdout: *mut FILE;
    static mut stderr: *mut FILE;
    fn fclose(__stream: *mut FILE) -> libc::c_int;
    fn fflush(__stream: *mut FILE) -> libc::c_int;
    fn fopen(_: *const libc::c_char, _: *const libc::c_char) -> *mut FILE;
    fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut libc::c_char,
        __modes: libc::c_int,
        __n: size_t,
    ) -> libc::c_int;
    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;
    fn sscanf(_: *const libc::c_char, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn fgetc(__stream: *mut FILE) -> libc::c_int;
    fn fputc(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
    fn putc(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
    fn fgets(
        __s: *mut libc::c_char,
        __n: libc::c_int,
        __stream: *mut FILE,
    ) -> *mut libc::c_char;
    fn fputs(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;
    fn fread(
        _: *mut libc::c_void,
        _: libc::c_ulong,
        _: libc::c_ulong,
        _: *mut FILE,
    ) -> libc::c_ulong;
    fn fwrite(
        _: *const libc::c_void,
        _: libc::c_ulong,
        _: libc::c_ulong,
        _: *mut FILE,
    ) -> libc::c_ulong;
    fn fseek(
        __stream: *mut FILE,
        __off: libc::c_long,
        __whence: libc::c_int,
    ) -> libc::c_int;
    fn ftell(__stream: *mut FILE) -> libc::c_long;
    fn rewind(__stream: *mut FILE);
    fn popen(__command: *const libc::c_char, __modes: *const libc::c_char) -> *mut FILE;
    fn pclose(__stream: *mut FILE) -> libc::c_int;
    fn sqlite3_libversion() -> *const libc::c_char;
    fn sqlite3_sourceid() -> *const libc::c_char;
    fn sqlite3_libversion_number() -> libc::c_int;
    fn libsql_libversion() -> *const libc::c_char;
    fn sqlite3_close(_: *mut sqlite3) -> libc::c_int;
    fn sqlite3_exec(
        _: *mut sqlite3,
        sql: *const libc::c_char,
        callback_0: Option::<
            unsafe extern "C" fn(
                *mut libc::c_void,
                libc::c_int,
                *mut *mut libc::c_char,
                *mut *mut libc::c_char,
            ) -> libc::c_int,
        >,
        _: *mut libc::c_void,
        errmsg: *mut *mut libc::c_char,
    ) -> libc::c_int;
    fn sqlite3_initialize() -> libc::c_int;
    fn sqlite3_config(_: libc::c_int, _: ...) -> libc::c_int;
    fn sqlite3_db_config(_: *mut sqlite3, op: libc::c_int, _: ...) -> libc::c_int;
    fn sqlite3_changes64(_: *mut sqlite3) -> sqlite3_int64;
    fn sqlite3_total_changes64(_: *mut sqlite3) -> sqlite3_int64;
    fn sqlite3_interrupt(_: *mut sqlite3);
    fn sqlite3_complete(sql: *const libc::c_char) -> libc::c_int;
    fn sqlite3_busy_timeout(_: *mut sqlite3, ms: libc::c_int) -> libc::c_int;
    fn sqlite3_mprintf(_: *const libc::c_char, _: ...) -> *mut libc::c_char;
    fn sqlite3_vmprintf(
        _: *const libc::c_char,
        _: ::std::ffi::VaList,
    ) -> *mut libc::c_char;
    fn sqlite3_snprintf(
        _: libc::c_int,
        _: *mut libc::c_char,
        _: *const libc::c_char,
        _: ...
    ) -> *mut libc::c_char;
    fn sqlite3_vsnprintf(
        _: libc::c_int,
        _: *mut libc::c_char,
        _: *const libc::c_char,
        _: ::std::ffi::VaList,
    ) -> *mut libc::c_char;
    fn sqlite3_malloc(_: libc::c_int) -> *mut libc::c_void;
    fn sqlite3_malloc64(_: sqlite3_uint64) -> *mut libc::c_void;
    fn sqlite3_realloc(_: *mut libc::c_void, _: libc::c_int) -> *mut libc::c_void;
    fn sqlite3_realloc64(_: *mut libc::c_void, _: sqlite3_uint64) -> *mut libc::c_void;
    fn sqlite3_free(_: *mut libc::c_void);
    fn sqlite3_randomness(N: libc::c_int, P: *mut libc::c_void);
    fn sqlite3_set_authorizer(
        _: *mut sqlite3,
        xAuth: Option::<
            unsafe extern "C" fn(
                *mut libc::c_void,
                libc::c_int,
                *const libc::c_char,
                *const libc::c_char,
                *const libc::c_char,
                *const libc::c_char,
            ) -> libc::c_int,
        >,
        pUserData: *mut libc::c_void,
    ) -> libc::c_int;
    fn sqlite3_trace_v2(
        _: *mut sqlite3,
        uMask: libc::c_uint,
        xCallback: Option::<
            unsafe extern "C" fn(
                libc::c_uint,
                *mut libc::c_void,
                *mut libc::c_void,
                *mut libc::c_void,
            ) -> libc::c_int,
        >,
        pCtx: *mut libc::c_void,
    ) -> libc::c_int;
    fn sqlite3_progress_handler(
        _: *mut sqlite3,
        _: libc::c_int,
        _: Option::<unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int>,
        _: *mut libc::c_void,
    );
    fn sqlite3_open(
        filename: *const libc::c_char,
        ppDb: *mut *mut sqlite3,
    ) -> libc::c_int;
    fn sqlite3_open_v2(
        filename: *const libc::c_char,
        ppDb: *mut *mut sqlite3,
        flags: libc::c_int,
        zVfs: *const libc::c_char,
    ) -> libc::c_int;
    fn sqlite3_errcode(db: *mut sqlite3) -> libc::c_int;
    fn sqlite3_extended_errcode(db: *mut sqlite3) -> libc::c_int;
    fn sqlite3_errmsg(_: *mut sqlite3) -> *const libc::c_char;
    fn sqlite3_error_offset(db: *mut sqlite3) -> libc::c_int;
    fn sqlite3_limit(
        _: *mut sqlite3,
        id: libc::c_int,
        newVal: libc::c_int,
    ) -> libc::c_int;
    fn sqlite3_prepare_v2(
        db: *mut sqlite3,
        zSql: *const libc::c_char,
        nByte: libc::c_int,
        ppStmt: *mut *mut sqlite3_stmt,
        pzTail: *mut *const libc::c_char,
    ) -> libc::c_int;
    fn sqlite3_sql(pStmt: *mut sqlite3_stmt) -> *const libc::c_char;
    fn sqlite3_expanded_sql(pStmt: *mut sqlite3_stmt) -> *mut libc::c_char;
    fn sqlite3_stmt_readonly(pStmt: *mut sqlite3_stmt) -> libc::c_int;
    fn sqlite3_stmt_isexplain(pStmt: *mut sqlite3_stmt) -> libc::c_int;
    fn sqlite3_bind_blob(
        _: *mut sqlite3_stmt,
        _: libc::c_int,
        _: *const libc::c_void,
        n: libc::c_int,
        _: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    ) -> libc::c_int;
    fn sqlite3_bind_double(
        _: *mut sqlite3_stmt,
        _: libc::c_int,
        _: libc::c_double,
    ) -> libc::c_int;
    fn sqlite3_bind_int(
        _: *mut sqlite3_stmt,
        _: libc::c_int,
        _: libc::c_int,
    ) -> libc::c_int;
    fn sqlite3_bind_int64(
        _: *mut sqlite3_stmt,
        _: libc::c_int,
        _: sqlite3_int64,
    ) -> libc::c_int;
    fn sqlite3_bind_null(_: *mut sqlite3_stmt, _: libc::c_int) -> libc::c_int;
    fn sqlite3_bind_text(
        _: *mut sqlite3_stmt,
        _: libc::c_int,
        _: *const libc::c_char,
        _: libc::c_int,
        _: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    ) -> libc::c_int;
    fn sqlite3_bind_value(
        _: *mut sqlite3_stmt,
        _: libc::c_int,
        _: *const sqlite3_value,
    ) -> libc::c_int;
    fn sqlite3_bind_parameter_count(_: *mut sqlite3_stmt) -> libc::c_int;
    fn sqlite3_bind_parameter_name(
        _: *mut sqlite3_stmt,
        _: libc::c_int,
    ) -> *const libc::c_char;
    fn sqlite3_bind_parameter_index(
        _: *mut sqlite3_stmt,
        zName: *const libc::c_char,
    ) -> libc::c_int;
    fn sqlite3_clear_bindings(_: *mut sqlite3_stmt) -> libc::c_int;
    fn sqlite3_column_count(pStmt: *mut sqlite3_stmt) -> libc::c_int;
    fn sqlite3_column_name(_: *mut sqlite3_stmt, N: libc::c_int) -> *const libc::c_char;
    fn sqlite3_column_decltype(
        _: *mut sqlite3_stmt,
        _: libc::c_int,
    ) -> *const libc::c_char;
    fn sqlite3_step(_: *mut sqlite3_stmt) -> libc::c_int;
    fn sqlite3_column_blob(
        _: *mut sqlite3_stmt,
        iCol: libc::c_int,
    ) -> *const libc::c_void;
    fn sqlite3_column_double(_: *mut sqlite3_stmt, iCol: libc::c_int) -> libc::c_double;
    fn sqlite3_column_int(_: *mut sqlite3_stmt, iCol: libc::c_int) -> libc::c_int;
    fn sqlite3_column_int64(_: *mut sqlite3_stmt, iCol: libc::c_int) -> sqlite3_int64;
    fn sqlite3_column_text(
        _: *mut sqlite3_stmt,
        iCol: libc::c_int,
    ) -> *const libc::c_uchar;
    fn sqlite3_column_value(
        _: *mut sqlite3_stmt,
        iCol: libc::c_int,
    ) -> *mut sqlite3_value;
    fn sqlite3_column_bytes(_: *mut sqlite3_stmt, iCol: libc::c_int) -> libc::c_int;
    fn sqlite3_column_type(_: *mut sqlite3_stmt, iCol: libc::c_int) -> libc::c_int;
    fn sqlite3_finalize(pStmt: *mut sqlite3_stmt) -> libc::c_int;
    fn sqlite3_reset(pStmt: *mut sqlite3_stmt) -> libc::c_int;
    fn sqlite3_create_function(
        db: *mut sqlite3,
        zFunctionName: *const libc::c_char,
        nArg: libc::c_int,
        eTextRep: libc::c_int,
        pApp: *mut libc::c_void,
        xFunc: Option::<
            unsafe extern "C" fn(
                *mut sqlite3_context,
                libc::c_int,
                *mut *mut sqlite3_value,
            ) -> (),
        >,
        xStep: Option::<
            unsafe extern "C" fn(
                *mut sqlite3_context,
                libc::c_int,
                *mut *mut sqlite3_value,
            ) -> (),
        >,
        xFinal: Option::<unsafe extern "C" fn(*mut sqlite3_context) -> ()>,
    ) -> libc::c_int;
    fn sqlite3_create_window_function(
        db: *mut sqlite3,
        zFunctionName: *const libc::c_char,
        nArg: libc::c_int,
        eTextRep: libc::c_int,
        pApp: *mut libc::c_void,
        xStep: Option::<
            unsafe extern "C" fn(
                *mut sqlite3_context,
                libc::c_int,
                *mut *mut sqlite3_value,
            ) -> (),
        >,
        xFinal: Option::<unsafe extern "C" fn(*mut sqlite3_context) -> ()>,
        xValue: Option::<unsafe extern "C" fn(*mut sqlite3_context) -> ()>,
        xInverse: Option::<
            unsafe extern "C" fn(
                *mut sqlite3_context,
                libc::c_int,
                *mut *mut sqlite3_value,
            ) -> (),
        >,
        xDestroy: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    ) -> libc::c_int;
    fn sqlite3_value_blob(_: *mut sqlite3_value) -> *const libc::c_void;
    fn sqlite3_value_double(_: *mut sqlite3_value) -> libc::c_double;
    fn sqlite3_value_int(_: *mut sqlite3_value) -> libc::c_int;
    fn sqlite3_value_int64(_: *mut sqlite3_value) -> sqlite3_int64;
    fn sqlite3_value_text(_: *mut sqlite3_value) -> *const libc::c_uchar;
    fn sqlite3_value_bytes(_: *mut sqlite3_value) -> libc::c_int;
    fn sqlite3_value_type(_: *mut sqlite3_value) -> libc::c_int;
    fn sqlite3_value_dup(_: *const sqlite3_value) -> *mut sqlite3_value;
    fn sqlite3_value_free(_: *mut sqlite3_value);
    fn sqlite3_aggregate_context(
        _: *mut sqlite3_context,
        nBytes: libc::c_int,
    ) -> *mut libc::c_void;
    fn sqlite3_user_data(_: *mut sqlite3_context) -> *mut libc::c_void;
    fn sqlite3_context_db_handle(_: *mut sqlite3_context) -> *mut sqlite3;
    fn sqlite3_get_auxdata(_: *mut sqlite3_context, N: libc::c_int) -> *mut libc::c_void;
    fn sqlite3_set_auxdata(
        _: *mut sqlite3_context,
        N: libc::c_int,
        _: *mut libc::c_void,
        _: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    );
    fn sqlite3_result_blob(
        _: *mut sqlite3_context,
        _: *const libc::c_void,
        _: libc::c_int,
        _: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    );
    fn sqlite3_result_blob64(
        _: *mut sqlite3_context,
        _: *const libc::c_void,
        _: sqlite3_uint64,
        _: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    );
    fn sqlite3_result_double(_: *mut sqlite3_context, _: libc::c_double);
    fn sqlite3_result_error(
        _: *mut sqlite3_context,
        _: *const libc::c_char,
        _: libc::c_int,
    );
    fn sqlite3_result_error_nomem(_: *mut sqlite3_context);
    fn sqlite3_result_error_code(_: *mut sqlite3_context, _: libc::c_int);
    fn sqlite3_result_int(_: *mut sqlite3_context, _: libc::c_int);
    fn sqlite3_result_int64(_: *mut sqlite3_context, _: sqlite3_int64);
    fn sqlite3_result_null(_: *mut sqlite3_context);
    fn sqlite3_result_text(
        _: *mut sqlite3_context,
        _: *const libc::c_char,
        _: libc::c_int,
        _: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    );
    fn sqlite3_result_text64(
        _: *mut sqlite3_context,
        _: *const libc::c_char,
        _: sqlite3_uint64,
        _: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
        encoding: libc::c_uchar,
    );
    fn sqlite3_result_text16le(
        _: *mut sqlite3_context,
        _: *const libc::c_void,
        _: libc::c_int,
        _: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    );
    fn sqlite3_result_text16be(
        _: *mut sqlite3_context,
        _: *const libc::c_void,
        _: libc::c_int,
        _: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    );
    fn sqlite3_result_value(_: *mut sqlite3_context, _: *mut sqlite3_value);
    fn sqlite3_create_collation(
        _: *mut sqlite3,
        zName: *const libc::c_char,
        eTextRep: libc::c_int,
        pArg: *mut libc::c_void,
        xCompare: Option::<
            unsafe extern "C" fn(
                *mut libc::c_void,
                libc::c_int,
                *const libc::c_void,
                libc::c_int,
                *const libc::c_void,
            ) -> libc::c_int,
        >,
    ) -> libc::c_int;
    fn sqlite3_sleep(_: libc::c_int) -> libc::c_int;
    fn sqlite3_get_autocommit(_: *mut sqlite3) -> libc::c_int;
    fn sqlite3_db_handle(_: *mut sqlite3_stmt) -> *mut sqlite3;
    fn sqlite3_db_readonly(
        db: *mut sqlite3,
        zDbName: *const libc::c_char,
    ) -> libc::c_int;
    fn sqlite3_txn_state(_: *mut sqlite3, zSchema: *const libc::c_char) -> libc::c_int;
    fn sqlite3_table_column_metadata(
        db: *mut sqlite3,
        zDbName: *const libc::c_char,
        zTableName: *const libc::c_char,
        zColumnName: *const libc::c_char,
        pzDataType: *mut *const libc::c_char,
        pzCollSeq: *mut *const libc::c_char,
        pNotNull: *mut libc::c_int,
        pPrimaryKey: *mut libc::c_int,
        pAutoinc: *mut libc::c_int,
    ) -> libc::c_int;
    fn sqlite3_load_extension(
        db: *mut sqlite3,
        zFile: *const libc::c_char,
        zProc: *const libc::c_char,
        pzErrMsg: *mut *mut libc::c_char,
    ) -> libc::c_int;
    fn sqlite3_enable_load_extension(
        db: *mut sqlite3,
        onoff: libc::c_int,
    ) -> libc::c_int;
    fn sqlite3_create_module(
        db: *mut sqlite3,
        zName: *const libc::c_char,
        p: *const sqlite3_module,
        pClientData: *mut libc::c_void,
    ) -> libc::c_int;
    fn sqlite3_declare_vtab(_: *mut sqlite3, zSQL: *const libc::c_char) -> libc::c_int;
    fn sqlite3_overload_function(
        _: *mut sqlite3,
        zFuncName: *const libc::c_char,
        nArg: libc::c_int,
    ) -> libc::c_int;
    fn sqlite3_vfs_find(zVfsName: *const libc::c_char) -> *mut sqlite3_vfs;
    fn sqlite3_vfs_register(_: *mut sqlite3_vfs, makeDflt: libc::c_int) -> libc::c_int;
    fn sqlite3_mutex_alloc(_: libc::c_int) -> *mut sqlite3_mutex;
    fn sqlite3_mutex_enter(_: *mut sqlite3_mutex);
    fn sqlite3_mutex_leave(_: *mut sqlite3_mutex);
    fn sqlite3_file_control(
        _: *mut sqlite3,
        zDbName: *const libc::c_char,
        op: libc::c_int,
        _: *mut libc::c_void,
    ) -> libc::c_int;
    fn sqlite3_test_control(op: libc::c_int, _: ...) -> libc::c_int;
    fn sqlite3_keyword_count() -> libc::c_int;
    fn sqlite3_keyword_name(
        _: libc::c_int,
        _: *mut *const libc::c_char,
        _: *mut libc::c_int,
    ) -> libc::c_int;
    fn sqlite3_keyword_check(_: *const libc::c_char, _: libc::c_int) -> libc::c_int;
    fn sqlite3_str_new(_: *mut sqlite3) -> *mut sqlite3_str;
    fn sqlite3_str_finish(_: *mut sqlite3_str) -> *mut libc::c_char;
    fn sqlite3_str_appendf(_: *mut sqlite3_str, zFormat: *const libc::c_char, _: ...);
    fn sqlite3_str_append(_: *mut sqlite3_str, zIn: *const libc::c_char, N: libc::c_int);
    fn sqlite3_str_appendall(_: *mut sqlite3_str, zIn: *const libc::c_char);
    fn sqlite3_status64(
        op: libc::c_int,
        pCurrent: *mut sqlite3_int64,
        pHighwater: *mut sqlite3_int64,
        resetFlag: libc::c_int,
    ) -> libc::c_int;
    fn sqlite3_db_status(
        _: *mut sqlite3,
        op: libc::c_int,
        pCur: *mut libc::c_int,
        pHiwtr: *mut libc::c_int,
        resetFlg: libc::c_int,
    ) -> libc::c_int;
    fn sqlite3_stmt_status(
        _: *mut sqlite3_stmt,
        op: libc::c_int,
        resetFlg: libc::c_int,
    ) -> libc::c_int;
    fn sqlite3_backup_init(
        pDest: *mut sqlite3,
        zDestName: *const libc::c_char,
        pSource: *mut sqlite3,
        zSourceName: *const libc::c_char,
    ) -> *mut sqlite3_backup;
    fn sqlite3_backup_step(p: *mut sqlite3_backup, nPage: libc::c_int) -> libc::c_int;
    fn sqlite3_backup_finish(p: *mut sqlite3_backup) -> libc::c_int;
    fn sqlite3_stricmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn sqlite3_strnicmp(
        _: *const libc::c_char,
        _: *const libc::c_char,
        _: libc::c_int,
    ) -> libc::c_int;
    fn sqlite3_strglob(
        zGlob: *const libc::c_char,
        zStr: *const libc::c_char,
    ) -> libc::c_int;
    fn sqlite3_strlike(
        zGlob: *const libc::c_char,
        zStr: *const libc::c_char,
        cEsc: libc::c_uint,
    ) -> libc::c_int;
    fn sqlite3_vtab_config(_: *mut sqlite3, op: libc::c_int, _: ...) -> libc::c_int;
    fn sqlite3_vtab_on_conflict(_: *mut sqlite3) -> libc::c_int;
    fn sqlite3_vtab_nochange(_: *mut sqlite3_context) -> libc::c_int;
    fn sqlite3_vtab_collation(
        _: *mut sqlite3_index_info,
        _: libc::c_int,
    ) -> *const libc::c_char;
    fn sqlite3_deserialize(
        db: *mut sqlite3,
        zSchema: *const libc::c_char,
        pData: *mut libc::c_uchar,
        szDb: sqlite3_int64,
        szBuf: sqlite3_int64,
        mFlags: libc::c_uint,
    ) -> libc::c_int;
    fn __ctype_b_loc() -> *mut *const libc::c_ushort;
    fn __ctype_tolower_loc() -> *mut *const __int32_t;
    fn signal(__sig: libc::c_int, __handler: __sighandler_t) -> __sighandler_t;
    fn raise(__sig: libc::c_int) -> libc::c_int;
    fn getpwuid(__uid: __uid_t) -> *mut passwd;
    fn access(__name: *const libc::c_char, __type: libc::c_int) -> libc::c_int;
    fn chdir(__path: *const libc::c_char) -> libc::c_int;
    fn getpid() -> __pid_t;
    fn getuid() -> __uid_t;
    fn isatty(__fd: libc::c_int) -> libc::c_int;
    fn symlink(__from: *const libc::c_char, __to: *const libc::c_char) -> libc::c_int;
    fn readlink(
        __path: *const libc::c_char,
        __buf: *mut libc::c_char,
        __len: size_t,
    ) -> ssize_t;
    fn unlink(__name: *const libc::c_char) -> libc::c_int;
    fn opendir(__name: *const libc::c_char) -> *mut DIR;
    fn closedir(__dirp: *mut DIR) -> libc::c_int;
    fn readdir(__dirp: *mut DIR) -> *mut dirent;
    fn chmod(__file: *const libc::c_char, __mode: __mode_t) -> libc::c_int;
    fn mkdir(__path: *const libc::c_char, __mode: __mode_t) -> libc::c_int;
    fn __xstat(
        __ver: libc::c_int,
        __filename: *const libc::c_char,
        __stat_buf: *mut stat,
    ) -> libc::c_int;
    fn __lxstat(
        __ver: libc::c_int,
        __filename: *const libc::c_char,
        __stat_buf: *mut stat,
    ) -> libc::c_int;
    fn readline(_: *const libc::c_char) -> *mut libc::c_char;
    fn rl_completion_matches(
        _: *const libc::c_char,
        _: Option::<rl_compentry_func_t>,
    ) -> *mut *mut libc::c_char;
    static mut rl_attempted_completion_function: Option::<rl_completion_func_t>;
    static mut rl_attempted_completion_over: libc::c_int;
    fn add_history(_: *const libc::c_char);
    fn stifle_history(_: libc::c_int);
    fn read_history(_: *const libc::c_char) -> libc::c_int;
    fn write_history(_: *const libc::c_char) -> libc::c_int;
    fn time(__timer: *mut time_t) -> time_t;
    fn utimes(__file: *const libc::c_char, __tvp: *const timeval) -> libc::c_int;
    fn getrusage(__who: __rusage_who_t, __usage: *mut rusage) -> libc::c_int;
    fn __errno_location() -> *mut libc::c_int;
    fn zlibVersion() -> *const libc::c_char;
    fn deflate(strm: z_streamp, flush: libc::c_int) -> libc::c_int;
    fn deflateEnd(strm: z_streamp) -> libc::c_int;
    fn inflate(strm: z_streamp, flush: libc::c_int) -> libc::c_int;
    fn inflateEnd(strm: z_streamp) -> libc::c_int;
    fn deflateBound(strm: z_streamp, sourceLen: uLong) -> uLong;
    fn compress(
        dest: *mut Bytef,
        destLen: *mut uLongf,
        source: *const Bytef,
        sourceLen: uLong,
    ) -> libc::c_int;
    fn compressBound(sourceLen: uLong) -> uLong;
    fn uncompress(
        dest: *mut Bytef,
        destLen: *mut uLongf,
        source: *const Bytef,
        sourceLen: uLong,
    ) -> libc::c_int;
    fn crc32(crc: uLong, buf: *const Bytef, len: uInt) -> uLong;
    fn inflateInit2_(
        strm: z_streamp,
        windowBits: libc::c_int,
        version: *const libc::c_char,
        stream_size: libc::c_int,
    ) -> libc::c_int;
    fn deflateInit2_(
        strm: z_streamp,
        level: libc::c_int,
        method: libc::c_int,
        windowBits: libc::c_int,
        memLevel: libc::c_int,
        strategy: libc::c_int,
        version: *const libc::c_char,
        stream_size: libc::c_int,
    ) -> libc::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1];
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
pub type u32_0 = libc::c_uint;
pub type u16_0 = libc::c_ushort;
pub type size_t = libc::c_ulong;
pub type __int32_t = libc::c_int;
pub type __dev_t = libc::c_ulong;
pub type __uid_t = libc::c_uint;
pub type __gid_t = libc::c_uint;
pub type __ino_t = libc::c_ulong;
pub type __ino64_t = libc::c_ulong;
pub type __mode_t = libc::c_uint;
pub type __nlink_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type __pid_t = libc::c_int;
pub type __time_t = libc::c_long;
pub type __suseconds_t = libc::c_long;
pub type __blksize_t = libc::c_long;
pub type __blkcnt_t = libc::c_long;
pub type __ssize_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
pub type mode_t = __mode_t;
pub type uid_t = __uid_t;
pub type ssize_t = __ssize_t;
pub type time_t = __time_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub type va_list = __builtin_va_list;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1],
    pub _lock: *mut libc::c_void,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: size_t,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20],
}
pub type _IO_lock_t = ();
pub type FILE = _IO_FILE;
pub type sqlite_int64 = libc::c_longlong;
pub type sqlite_uint64 = libc::c_ulonglong;
pub type sqlite3_int64 = sqlite_int64;
pub type sqlite3_uint64 = sqlite_uint64;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_file {
    pub pMethods: *const sqlite3_io_methods,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_io_methods {
    pub iVersion: libc::c_int,
    pub xClose: Option::<unsafe extern "C" fn(*mut sqlite3_file) -> libc::c_int>,
    pub xRead: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_file,
            *mut libc::c_void,
            libc::c_int,
            sqlite3_int64,
        ) -> libc::c_int,
    >,
    pub xWrite: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_file,
            *const libc::c_void,
            libc::c_int,
            sqlite3_int64,
        ) -> libc::c_int,
    >,
    pub xTruncate: Option::<
        unsafe extern "C" fn(*mut sqlite3_file, sqlite3_int64) -> libc::c_int,
    >,
    pub xSync: Option::<
        unsafe extern "C" fn(*mut sqlite3_file, libc::c_int) -> libc::c_int,
    >,
    pub xFileSize: Option::<
        unsafe extern "C" fn(*mut sqlite3_file, *mut sqlite3_int64) -> libc::c_int,
    >,
    pub xLock: Option::<
        unsafe extern "C" fn(*mut sqlite3_file, libc::c_int) -> libc::c_int,
    >,
    pub xUnlock: Option::<
        unsafe extern "C" fn(*mut sqlite3_file, libc::c_int) -> libc::c_int,
    >,
    pub xCheckReservedLock: Option::<
        unsafe extern "C" fn(*mut sqlite3_file, *mut libc::c_int) -> libc::c_int,
    >,
    pub xFileControl: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_file,
            libc::c_int,
            *mut libc::c_void,
        ) -> libc::c_int,
    >,
    pub xSectorSize: Option::<unsafe extern "C" fn(*mut sqlite3_file) -> libc::c_int>,
    pub xDeviceCharacteristics: Option::<
        unsafe extern "C" fn(*mut sqlite3_file) -> libc::c_int,
    >,
    pub xShmMap: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_file,
            libc::c_int,
            libc::c_int,
            libc::c_int,
            *mut *mut libc::c_void,
        ) -> libc::c_int,
    >,
    pub xShmLock: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_file,
            libc::c_int,
            libc::c_int,
            libc::c_int,
        ) -> libc::c_int,
    >,
    pub xShmBarrier: Option::<unsafe extern "C" fn(*mut sqlite3_file) -> ()>,
    pub xShmUnmap: Option::<
        unsafe extern "C" fn(*mut sqlite3_file, libc::c_int) -> libc::c_int,
    >,
    pub xFetch: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_file,
            sqlite3_int64,
            libc::c_int,
            *mut *mut libc::c_void,
        ) -> libc::c_int,
    >,
    pub xUnfetch: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_file,
            sqlite3_int64,
            *mut libc::c_void,
        ) -> libc::c_int,
    >,
}
pub type sqlite3_filename = *const libc::c_char;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_vfs {
    pub iVersion: libc::c_int,
    pub szOsFile: libc::c_int,
    pub mxPathname: libc::c_int,
    pub pNext: *mut sqlite3_vfs,
    pub zName: *const libc::c_char,
    pub pAppData: *mut libc::c_void,
    pub xOpen: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vfs,
            sqlite3_filename,
            *mut sqlite3_file,
            libc::c_int,
            *mut libc::c_int,
        ) -> libc::c_int,
    >,
    pub xDelete: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vfs,
            *const libc::c_char,
            libc::c_int,
        ) -> libc::c_int,
    >,
    pub xAccess: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vfs,
            *const libc::c_char,
            libc::c_int,
            *mut libc::c_int,
        ) -> libc::c_int,
    >,
    pub xFullPathname: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vfs,
            *const libc::c_char,
            libc::c_int,
            *mut libc::c_char,
        ) -> libc::c_int,
    >,
    pub xDlOpen: Option::<
        unsafe extern "C" fn(*mut sqlite3_vfs, *const libc::c_char) -> *mut libc::c_void,
    >,
    pub xDlError: Option::<
        unsafe extern "C" fn(*mut sqlite3_vfs, libc::c_int, *mut libc::c_char) -> (),
    >,
    pub xDlSym: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vfs,
            *mut libc::c_void,
            *const libc::c_char,
        ) -> Option::<unsafe extern "C" fn() -> ()>,
    >,
    pub xDlClose: Option::<
        unsafe extern "C" fn(*mut sqlite3_vfs, *mut libc::c_void) -> (),
    >,
    pub xRandomness: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vfs,
            libc::c_int,
            *mut libc::c_char,
        ) -> libc::c_int,
    >,
    pub xSleep: Option::<
        unsafe extern "C" fn(*mut sqlite3_vfs, libc::c_int) -> libc::c_int,
    >,
    pub xCurrentTime: Option::<
        unsafe extern "C" fn(*mut sqlite3_vfs, *mut libc::c_double) -> libc::c_int,
    >,
    pub xGetLastError: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vfs,
            libc::c_int,
            *mut libc::c_char,
        ) -> libc::c_int,
    >,
    pub xCurrentTimeInt64: Option::<
        unsafe extern "C" fn(*mut sqlite3_vfs, *mut sqlite3_int64) -> libc::c_int,
    >,
    pub xSetSystemCall: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vfs,
            *const libc::c_char,
            sqlite3_syscall_ptr,
        ) -> libc::c_int,
    >,
    pub xGetSystemCall: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vfs,
            *const libc::c_char,
        ) -> sqlite3_syscall_ptr,
    >,
    pub xNextSystemCall: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vfs,
            *const libc::c_char,
        ) -> *const libc::c_char,
    >,
}
pub type sqlite3_syscall_ptr = Option::<unsafe extern "C" fn() -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_mem_methods {
    pub xMalloc: Option::<unsafe extern "C" fn(libc::c_int) -> *mut libc::c_void>,
    pub xFree: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    pub xRealloc: Option::<
        unsafe extern "C" fn(*mut libc::c_void, libc::c_int) -> *mut libc::c_void,
    >,
    pub xSize: Option::<unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int>,
    pub xRoundup: Option::<unsafe extern "C" fn(libc::c_int) -> libc::c_int>,
    pub xInit: Option::<unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int>,
    pub xShutdown: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    pub pAppData: *mut libc::c_void,
}
pub type sqlite3_destructor_type = Option::<
    unsafe extern "C" fn(*mut libc::c_void) -> (),
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_vtab {
    pub pModule: *const sqlite3_module,
    pub nRef: libc::c_int,
    pub zErrMsg: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_module {
    pub iVersion: libc::c_int,
    pub xCreate: Option::<
        unsafe extern "C" fn(
            *mut sqlite3,
            *mut libc::c_void,
            libc::c_int,
            *const *const libc::c_char,
            *mut *mut sqlite3_vtab,
            *mut *mut libc::c_char,
        ) -> libc::c_int,
    >,
    pub xConnect: Option::<
        unsafe extern "C" fn(
            *mut sqlite3,
            *mut libc::c_void,
            libc::c_int,
            *const *const libc::c_char,
            *mut *mut sqlite3_vtab,
            *mut *mut libc::c_char,
        ) -> libc::c_int,
    >,
    pub xBestIndex: Option::<
        unsafe extern "C" fn(*mut sqlite3_vtab, *mut sqlite3_index_info) -> libc::c_int,
    >,
    pub xDisconnect: Option::<unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int>,
    pub xDestroy: Option::<unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int>,
    pub xOpen: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vtab,
            *mut *mut sqlite3_vtab_cursor,
        ) -> libc::c_int,
    >,
    pub xClose: Option::<unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int>,
    pub xFilter: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vtab_cursor,
            libc::c_int,
            *const libc::c_char,
            libc::c_int,
            *mut *mut sqlite3_value,
        ) -> libc::c_int,
    >,
    pub xNext: Option::<unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int>,
    pub xEof: Option::<unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int>,
    pub xColumn: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vtab_cursor,
            *mut sqlite3_context,
            libc::c_int,
        ) -> libc::c_int,
    >,
    pub xRowid: Option::<
        unsafe extern "C" fn(*mut sqlite3_vtab_cursor, *mut sqlite3_int64) -> libc::c_int,
    >,
    pub xUpdate: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vtab,
            libc::c_int,
            *mut *mut sqlite3_value,
            *mut sqlite3_int64,
        ) -> libc::c_int,
    >,
    pub xBegin: Option::<unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int>,
    pub xSync: Option::<unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int>,
    pub xCommit: Option::<unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int>,
    pub xRollback: Option::<unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int>,
    pub xFindFunction: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vtab,
            libc::c_int,
            *const libc::c_char,
            *mut Option::<
                unsafe extern "C" fn(
                    *mut sqlite3_context,
                    libc::c_int,
                    *mut *mut sqlite3_value,
                ) -> (),
            >,
            *mut *mut libc::c_void,
        ) -> libc::c_int,
    >,
    pub xRename: Option::<
        unsafe extern "C" fn(*mut sqlite3_vtab, *const libc::c_char) -> libc::c_int,
    >,
    pub xSavepoint: Option::<
        unsafe extern "C" fn(*mut sqlite3_vtab, libc::c_int) -> libc::c_int,
    >,
    pub xRelease: Option::<
        unsafe extern "C" fn(*mut sqlite3_vtab, libc::c_int) -> libc::c_int,
    >,
    pub xRollbackTo: Option::<
        unsafe extern "C" fn(*mut sqlite3_vtab, libc::c_int) -> libc::c_int,
    >,
    pub xShadowName: Option::<unsafe extern "C" fn(*const libc::c_char) -> libc::c_int>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_vtab_cursor {
    pub pVtab: *mut sqlite3_vtab,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_index_info {
    pub nConstraint: libc::c_int,
    pub aConstraint: *mut sqlite3_index_constraint,
    pub nOrderBy: libc::c_int,
    pub aOrderBy: *mut sqlite3_index_orderby,
    pub aConstraintUsage: *mut sqlite3_index_constraint_usage,
    pub idxNum: libc::c_int,
    pub idxStr: *mut libc::c_char,
    pub needToFreeIdxStr: libc::c_int,
    pub orderByConsumed: libc::c_int,
    pub estimatedCost: libc::c_double,
    pub estimatedRows: sqlite3_int64,
    pub idxFlags: libc::c_int,
    pub colUsed: sqlite3_uint64,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_index_constraint_usage {
    pub argvIndex: libc::c_int,
    pub omit: libc::c_uchar,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_index_orderby {
    pub iColumn: libc::c_int,
    pub desc: libc::c_uchar,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_index_constraint {
    pub iColumn: libc::c_int,
    pub op: libc::c_uchar,
    pub usable: libc::c_uchar,
    pub iTermOffset: libc::c_int,
}
pub type i64_0 = sqlite3_int64;
pub type u64_0 = sqlite3_uint64;
pub type u8_0 = libc::c_uchar;
pub type C2RustUnnamed = libc::c_uint;
pub const _ISalnum: C2RustUnnamed = 8;
pub const _ISpunct: C2RustUnnamed = 4;
pub const _IScntrl: C2RustUnnamed = 2;
pub const _ISblank: C2RustUnnamed = 1;
pub const _ISgraph: C2RustUnnamed = 32768;
pub const _ISprint: C2RustUnnamed = 16384;
pub const _ISspace: C2RustUnnamed = 8192;
pub const _ISxdigit: C2RustUnnamed = 4096;
pub const _ISdigit: C2RustUnnamed = 2048;
pub const _ISalpha: C2RustUnnamed = 1024;
pub const _ISlower: C2RustUnnamed = 512;
pub const _ISupper: C2RustUnnamed = 256;
pub type __sighandler_t = Option::<unsafe extern "C" fn(libc::c_int) -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct passwd {
    pub pw_name: *mut libc::c_char,
    pub pw_passwd: *mut libc::c_char,
    pub pw_uid: __uid_t,
    pub pw_gid: __gid_t,
    pub pw_gecos: *mut libc::c_char,
    pub pw_dir: *mut libc::c_char,
    pub pw_shell: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct dirent {
    pub d_ino: __ino64_t,
    pub d_off: __off64_t,
    pub d_reclen: libc::c_ushort,
    pub d_type: libc::c_uchar,
    pub d_name: [libc::c_char; 256],
}
pub type DIR = __dirstream;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: libc::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3],
}
pub type rl_compentry_func_t = unsafe extern "C" fn(
    *const libc::c_char,
    libc::c_int,
) -> *mut libc::c_char;
pub type rl_completion_func_t = unsafe extern "C" fn(
    *const libc::c_char,
    libc::c_int,
    libc::c_int,
) -> *mut *mut libc::c_char;
pub type __rusage_who = libc::c_int;
pub const RUSAGE_CHILDREN: __rusage_who = -1;
pub const RUSAGE_SELF: __rusage_who = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub c2rust_unnamed: C2RustUnnamed_13,
    pub c2rust_unnamed_0: C2RustUnnamed_12,
    pub c2rust_unnamed_1: C2RustUnnamed_11,
    pub c2rust_unnamed_2: C2RustUnnamed_10,
    pub c2rust_unnamed_3: C2RustUnnamed_9,
    pub c2rust_unnamed_4: C2RustUnnamed_8,
    pub c2rust_unnamed_5: C2RustUnnamed_7,
    pub c2rust_unnamed_6: C2RustUnnamed_6,
    pub c2rust_unnamed_7: C2RustUnnamed_5,
    pub c2rust_unnamed_8: C2RustUnnamed_4,
    pub c2rust_unnamed_9: C2RustUnnamed_3,
    pub c2rust_unnamed_10: C2RustUnnamed_2,
    pub c2rust_unnamed_11: C2RustUnnamed_1,
    pub c2rust_unnamed_12: C2RustUnnamed_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_0 {
    pub ru_nivcsw: libc::c_long,
    pub __ru_nivcsw_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_1 {
    pub ru_nvcsw: libc::c_long,
    pub __ru_nvcsw_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_2 {
    pub ru_nsignals: libc::c_long,
    pub __ru_nsignals_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_3 {
    pub ru_msgrcv: libc::c_long,
    pub __ru_msgrcv_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_4 {
    pub ru_msgsnd: libc::c_long,
    pub __ru_msgsnd_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_5 {
    pub ru_oublock: libc::c_long,
    pub __ru_oublock_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_6 {
    pub ru_inblock: libc::c_long,
    pub __ru_inblock_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_7 {
    pub ru_nswap: libc::c_long,
    pub __ru_nswap_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_8 {
    pub ru_majflt: libc::c_long,
    pub __ru_majflt_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_9 {
    pub ru_minflt: libc::c_long,
    pub __ru_minflt_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_10 {
    pub ru_isrss: libc::c_long,
    pub __ru_isrss_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_11 {
    pub ru_idrss: libc::c_long,
    pub __ru_idrss_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_12 {
    pub ru_ixrss: libc::c_long,
    pub __ru_ixrss_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_13 {
    pub ru_maxrss: libc::c_long,
    pub __ru_maxrss_word: __syscall_slong_t,
}
pub type __rusage_who_t = libc::c_int;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_14 {
    pub zSuffix: *mut libc::c_char,
    pub iMult: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ShellText {
    pub z: *mut libc::c_char,
    pub n: libc::c_int,
    pub nAlloc: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SHA3Context {
    pub u: C2RustUnnamed_15,
    pub nRate: libc::c_uint,
    pub nLoaded: libc::c_uint,
    pub ixMask: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_15 {
    pub s: [u64_0; 25],
    pub x: [libc::c_uchar; 1600],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Decimal {
    pub sign: libc::c_char,
    pub oom: libc::c_char,
    pub isNull: libc::c_char,
    pub isInit: libc::c_char,
    pub nDigit: libc::c_int,
    pub nFrac: libc::c_int,
    pub a: *mut libc::c_schar,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_16 {
    pub zFuncName: *const libc::c_char,
    pub nArg: libc::c_int,
    pub xFunc: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_context,
            libc::c_int,
            *mut *mut sqlite3_value,
        ) -> (),
    >,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_17 {
    pub zFName: *mut libc::c_char,
    pub nArg: libc::c_int,
    pub iAux: libc::c_int,
    pub xFunc: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_context,
            libc::c_int,
            *mut *mut sqlite3_value,
        ) -> (),
    >,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct series_cursor {
    pub base: sqlite3_vtab_cursor,
    pub isDesc: libc::c_int,
    pub iRowid: sqlite3_int64,
    pub iValue: sqlite3_int64,
    pub mnValue: sqlite3_int64,
    pub mxValue: sqlite3_int64,
    pub iStep: sqlite3_int64,
}
pub type ReStateNumber = libc::c_ushort;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ReStateSet {
    pub nState: libc::c_uint,
    pub aState: *mut ReStateNumber,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ReInput {
    pub z: *const libc::c_uchar,
    pub i: libc::c_int,
    pub mx: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ReCompiled {
    pub sIn: ReInput,
    pub zErr: *const libc::c_char,
    pub aOp: *mut libc::c_char,
    pub aArg: *mut libc::c_int,
    pub xNextChar: Option::<unsafe extern "C" fn(*mut ReInput) -> libc::c_uint>,
    pub zInit: [libc::c_uchar; 12],
    pub nInit: libc::c_int,
    pub nState: libc::c_uint,
    pub nAlloc: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct fsdir_cursor {
    pub base: sqlite3_vtab_cursor,
    pub nLvl: libc::c_int,
    pub iLvl: libc::c_int,
    pub aLvl: *mut FsdirLevel,
    pub zBase: *const libc::c_char,
    pub nBase: libc::c_int,
    pub sStat: stat,
    pub zPath: *mut libc::c_char,
    pub iRowid: sqlite3_int64,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct FsdirLevel {
    pub pDir: *mut DIR,
    pub zDir: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct fsdir_tab {
    pub base: sqlite3_vtab,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct completion_vtab {
    pub base: sqlite3_vtab,
    pub db: *mut sqlite3,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct completion_cursor {
    pub base: sqlite3_vtab_cursor,
    pub db: *mut sqlite3,
    pub nPrefix: libc::c_int,
    pub nLine: libc::c_int,
    pub zPrefix: *mut libc::c_char,
    pub zLine: *mut libc::c_char,
    pub zCurrentRow: *const libc::c_char,
    pub szRow: libc::c_int,
    pub pStmt: *mut sqlite3_stmt,
    pub iRowid: sqlite3_int64,
    pub ePhase: libc::c_int,
    pub j: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ApndFile {
    pub base: sqlite3_file,
    pub iPgOne: sqlite3_int64,
    pub iMark: sqlite3_int64,
}
pub type Byte = libc::c_uchar;
pub type uInt = libc::c_uint;
pub type uLong = libc::c_ulong;
pub type Bytef = Byte;
pub type uLongf = uLong;
pub type voidpf = *mut libc::c_void;
pub type alloc_func = Option::<unsafe extern "C" fn(voidpf, uInt, uInt) -> voidpf>;
pub type free_func = Option::<unsafe extern "C" fn(voidpf, voidpf) -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct z_stream_s {
    pub next_in: *mut Bytef,
    pub avail_in: uInt,
    pub total_in: uLong,
    pub next_out: *mut Bytef,
    pub avail_out: uInt,
    pub total_out: uLong,
    pub msg: *mut libc::c_char,
    pub state: *mut internal_state,
    pub zalloc: alloc_func,
    pub zfree: free_func,
    pub opaque: voidpf,
    pub data_type: libc::c_int,
    pub adler: uLong,
    pub reserved: uLong,
}
pub type z_stream = z_stream_s;
pub type z_streamp = *mut z_stream;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ZipfileEOCD {
    pub iDisk: u16_0,
    pub iFirstDisk: u16_0,
    pub nEntry: u16_0,
    pub nEntryTotal: u16_0,
    pub nSize: u32_0,
    pub iOffset: u32_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ZipfileCDS {
    pub iVersionMadeBy: u16_0,
    pub iVersionExtract: u16_0,
    pub flags: u16_0,
    pub iCompression: u16_0,
    pub mTime: u16_0,
    pub mDate: u16_0,
    pub crc32: u32_0,
    pub szCompressed: u32_0,
    pub szUncompressed: u32_0,
    pub nFile: u16_0,
    pub nExtra: u16_0,
    pub nComment: u16_0,
    pub iDiskStart: u16_0,
    pub iInternalAttr: u16_0,
    pub iExternalAttr: u32_0,
    pub iOffset: u32_0,
    pub zFile: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ZipfileLFH {
    pub iVersionExtract: u16_0,
    pub flags: u16_0,
    pub iCompression: u16_0,
    pub mTime: u16_0,
    pub mDate: u16_0,
    pub crc32: u32_0,
    pub szCompressed: u32_0,
    pub szUncompressed: u32_0,
    pub nFile: u16_0,
    pub nExtra: u16_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ZipfileEntry {
    pub cds: ZipfileCDS,
    pub mUnixTime: u32_0,
    pub aExtra: *mut u8_0,
    pub iDataOff: i64_0,
    pub aData: *mut u8_0,
    pub pNext: *mut ZipfileEntry,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ZipfileCsr {
    pub base: sqlite3_vtab_cursor,
    pub iId: i64_0,
    pub bEof: u8_0,
    pub bNoop: u8_0,
    pub pFile: *mut FILE,
    pub iNextOff: i64_0,
    pub eocd: ZipfileEOCD,
    pub pFreeEntry: *mut ZipfileEntry,
    pub pCurrent: *mut ZipfileEntry,
    pub pCsrNext: *mut ZipfileCsr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ZipfileTab {
    pub base: sqlite3_vtab,
    pub zFile: *mut libc::c_char,
    pub db: *mut sqlite3,
    pub aBuffer: *mut u8_0,
    pub pCsrList: *mut ZipfileCsr,
    pub iNextCsrid: i64_0,
    pub pFirstEntry: *mut ZipfileEntry,
    pub pLastEntry: *mut ZipfileEntry,
    pub pWriteFd: *mut FILE,
    pub szCurrent: i64_0,
    pub szOrig: i64_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ZipfileBuffer {
    pub a: *mut u8_0,
    pub n: libc::c_int,
    pub nAlloc: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ZipfileCtx {
    pub nEntry: libc::c_int,
    pub body: ZipfileBuffer,
    pub cds: ZipfileBuffer,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3expert {
    pub iSample: libc::c_int,
    pub db: *mut sqlite3,
    pub dbm: *mut sqlite3,
    pub dbv: *mut sqlite3,
    pub pTable: *mut IdxTable,
    pub pScan: *mut IdxScan,
    pub pWrite: *mut IdxWrite,
    pub pStatement: *mut IdxStatement,
    pub bRun: libc::c_int,
    pub pzErrmsg: *mut *mut libc::c_char,
    pub rc: libc::c_int,
    pub hIdx: IdxHash,
    pub zCandidates: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxHash {
    pub pFirst: *mut IdxHashEntry,
    pub aHash: [*mut IdxHashEntry; 1023],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxHashEntry {
    pub zKey: *mut libc::c_char,
    pub zVal: *mut libc::c_char,
    pub zVal2: *mut libc::c_char,
    pub pHashNext: *mut IdxHashEntry,
    pub pNext: *mut IdxHashEntry,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxStatement {
    pub iId: libc::c_int,
    pub zSql: *mut libc::c_char,
    pub zIdx: *mut libc::c_char,
    pub zEQP: *mut libc::c_char,
    pub pNext: *mut IdxStatement,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxWrite {
    pub pTab: *mut IdxTable,
    pub eOp: libc::c_int,
    pub pNext: *mut IdxWrite,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxTable {
    pub nCol: libc::c_int,
    pub zName: *mut libc::c_char,
    pub aCol: *mut IdxColumn,
    pub pNext: *mut IdxTable,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxColumn {
    pub zName: *mut libc::c_char,
    pub zColl: *mut libc::c_char,
    pub iPk: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxScan {
    pub pTab: *mut IdxTable,
    pub iDb: libc::c_int,
    pub covering: i64_0,
    pub pOrder: *mut IdxConstraint,
    pub pEq: *mut IdxConstraint,
    pub pRange: *mut IdxConstraint,
    pub pNextScan: *mut IdxScan,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxConstraint {
    pub zColl: *mut libc::c_char,
    pub bRange: libc::c_int,
    pub iCol: libc::c_int,
    pub bFlag: libc::c_int,
    pub bDesc: libc::c_int,
    pub pNext: *mut IdxConstraint,
    pub pLink: *mut IdxConstraint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ExpertCsr {
    pub base: sqlite3_vtab_cursor,
    pub pData: *mut sqlite3_stmt,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ExpertVtab {
    pub base: sqlite3_vtab,
    pub pTab: *mut IdxTable,
    pub pExpert: *mut sqlite3expert,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxRemCtx {
    pub nSlot: libc::c_int,
    pub aSlot: [IdxRemSlot; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxRemSlot {
    pub eType: libc::c_int,
    pub iVal: i64_0,
    pub rVal: libc::c_double,
    pub nByte: libc::c_int,
    pub n: libc::c_int,
    pub z: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxSampleCtx {
    pub iTarget: libc::c_int,
    pub target: libc::c_double,
    pub nRow: libc::c_double,
    pub nRet: libc::c_double,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_recover {
    pub dbIn: *mut sqlite3,
    pub zDb: *mut libc::c_char,
    pub zUri: *mut libc::c_char,
    pub pSqlCtx: *mut libc::c_void,
    pub xSql: Option::<
        unsafe extern "C" fn(*mut libc::c_void, *const libc::c_char) -> libc::c_int,
    >,
    pub zStateDb: *mut libc::c_char,
    pub zLostAndFound: *mut libc::c_char,
    pub bFreelistCorrupt: libc::c_int,
    pub bRecoverRowid: libc::c_int,
    pub bSlowIndexes: libc::c_int,
    pub pgsz: libc::c_int,
    pub detected_pgsz: libc::c_int,
    pub nReserve: libc::c_int,
    pub pPage1Disk: *mut u8_0,
    pub pPage1Cache: *mut u8_0,
    pub errCode: libc::c_int,
    pub zErrMsg: *mut libc::c_char,
    pub eState: libc::c_int,
    pub bCloseTransaction: libc::c_int,
    pub w1: RecoverStateW1,
    pub laf: RecoverStateLAF,
    pub dbOut: *mut sqlite3,
    pub pGetPage: *mut sqlite3_stmt,
    pub pTblList: *mut RecoverTable,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct RecoverTable {
    pub iRoot: u32_0,
    pub zTab: *mut libc::c_char,
    pub nCol: libc::c_int,
    pub aCol: *mut RecoverColumn,
    pub bIntkey: libc::c_int,
    pub iRowidBind: libc::c_int,
    pub pNext: *mut RecoverTable,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct RecoverColumn {
    pub iField: libc::c_int,
    pub iBind: libc::c_int,
    pub bIPK: libc::c_int,
    pub zCol: *mut libc::c_char,
    pub eHidden: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct RecoverStateLAF {
    pub pUsed: *mut RecoverBitmap,
    pub nPg: i64_0,
    pub pAllAndParent: *mut sqlite3_stmt,
    pub pMapInsert: *mut sqlite3_stmt,
    pub pMaxField: *mut sqlite3_stmt,
    pub pUsedPages: *mut sqlite3_stmt,
    pub pFindRoot: *mut sqlite3_stmt,
    pub pInsert: *mut sqlite3_stmt,
    pub pAllPage: *mut sqlite3_stmt,
    pub pPageData: *mut sqlite3_stmt,
    pub apVal: *mut *mut sqlite3_value,
    pub nMaxField: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct RecoverBitmap {
    pub nPg: i64_0,
    pub aElem: [u32_0; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct RecoverStateW1 {
    pub pTbls: *mut sqlite3_stmt,
    pub pSel: *mut sqlite3_stmt,
    pub pInsert: *mut sqlite3_stmt,
    pub nInsert: libc::c_int,
    pub pTab: *mut RecoverTable,
    pub nMax: libc::c_int,
    pub apVal: *mut *mut sqlite3_value,
    pub nVal: libc::c_int,
    pub bHaveRowid: libc::c_int,
    pub iRowid: i64_0,
    pub iPrevPage: i64_0,
    pub iPrevCell: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct RecoverGlobal {
    pub pMethods: *const sqlite3_io_methods,
    pub p: *mut sqlite3_recover,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Func {
    pub zName: *const libc::c_char,
    pub nArg: libc::c_int,
    pub xFunc: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_context,
            libc::c_int,
            *mut *mut sqlite3_value,
        ) -> (),
    >,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DbdataCursor {
    pub base: sqlite3_vtab_cursor,
    pub pStmt: *mut sqlite3_stmt,
    pub iPgno: libc::c_int,
    pub aPage: *mut u8_0,
    pub nPage: libc::c_int,
    pub nCell: libc::c_int,
    pub iCell: libc::c_int,
    pub bOnePage: libc::c_int,
    pub szDb: libc::c_int,
    pub iRowid: sqlite3_int64,
    pub pRec: *mut u8_0,
    pub nRec: sqlite3_int64,
    pub nHdr: sqlite3_int64,
    pub iField: libc::c_int,
    pub pHdrPtr: *mut u8_0,
    pub pPtr: *mut u8_0,
    pub enc: u32_0,
    pub iIntkey: sqlite3_int64,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DbdataTable {
    pub base: sqlite3_vtab,
    pub db: *mut sqlite3,
    pub pStmt: *mut sqlite3_stmt,
    pub bPtr: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ExpertInfo {
    pub pExpert: *mut sqlite3expert,
    pub bVerbose: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EQPGraphRow {
    pub iEqpId: libc::c_int,
    pub iParentId: libc::c_int,
    pub pNext: *mut EQPGraphRow,
    pub zText: [libc::c_char; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EQPGraph {
    pub pRow: *mut EQPGraphRow,
    pub pLast: *mut EQPGraphRow,
    pub zPrefix: [libc::c_char; 100],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ColModeOpts {
    pub iWrap: libc::c_int,
    pub bQuote: u8_0,
    pub bWordWrap: u8_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ShellState {
    pub db: *mut sqlite3,
    pub autoExplain: u8_0,
    pub autoEQP: u8_0,
    pub autoEQPtest: u8_0,
    pub autoEQPtrace: u8_0,
    pub scanstatsOn: u8_0,
    pub openMode: u8_0,
    pub doXdgOpen: u8_0,
    pub nEqpLevel: u8_0,
    pub eTraceType: u8_0,
    pub bSafeMode: u8_0,
    pub bSafeModePersist: u8_0,
    pub cmOpts: ColModeOpts,
    pub statsOn: libc::c_uint,
    pub mEqpLines: libc::c_uint,
    pub inputNesting: libc::c_int,
    pub outCount: libc::c_int,
    pub cnt: libc::c_int,
    pub lineno: libc::c_int,
    pub openFlags: libc::c_int,
    pub in_0: *mut FILE,
    pub out: *mut FILE,
    pub traceOut: *mut FILE,
    pub nErr: libc::c_int,
    pub mode: libc::c_int,
    pub modePrior: libc::c_int,
    pub cMode: libc::c_int,
    pub normalMode: libc::c_int,
    pub writableSchema: libc::c_int,
    pub showHeader: libc::c_int,
    pub nCheck: libc::c_int,
    pub nProgress: libc::c_uint,
    pub mxProgress: libc::c_uint,
    pub flgProgress: libc::c_uint,
    pub shellFlgs: libc::c_uint,
    pub priorShFlgs: libc::c_uint,
    pub szMax: sqlite3_int64,
    pub zDestTable: *mut libc::c_char,
    pub zTempFile: *mut libc::c_char,
    pub zTestcase: [libc::c_char; 30],
    pub colSeparator: [libc::c_char; 20],
    pub rowSeparator: [libc::c_char; 20],
    pub colSepPrior: [libc::c_char; 20],
    pub rowSepPrior: [libc::c_char; 20],
    pub colWidth: *mut libc::c_int,
    pub actualWidth: *mut libc::c_int,
    pub nWidth: libc::c_int,
    pub nullValue: [libc::c_char; 20],
    pub outfile: [libc::c_char; 4096],
    pub pStmt: *mut sqlite3_stmt,
    pub pLog: *mut FILE,
    pub aAuxDb: [AuxDb; 5],
    pub pAuxDb: *mut AuxDb,
    pub aiIndent: *mut libc::c_int,
    pub nIndent: libc::c_int,
    pub iIndent: libc::c_int,
    pub zNonce: *mut libc::c_char,
    pub sGraph: EQPGraph,
    pub expert: ExpertInfo,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AuxDb {
    pub db: *mut sqlite3,
    pub zDbFilename: *const libc::c_char,
    pub zFreeOnClose: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_18 {
    pub zPattern: *const libc::c_char,
    pub zDesc: *const libc::c_char,
}
pub type QuickScanState = libc::c_uint;
pub const QSS_Start: QuickScanState = 0;
pub const QSS_ScanMask: QuickScanState = 768;
pub const QSS_CharMask: QuickScanState = 255;
pub const QSS_EndingSemi: QuickScanState = 512;
pub const QSS_HasDark: QuickScanState = 256;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_19 {
    pub zCtrlName: *const libc::c_char,
    pub ctrlCode: libc::c_int,
    pub unSafe: libc::c_int,
    pub zUsage: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_20 {
    pub zLimitName: *const libc::c_char,
    pub limitCode: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ImportCtx {
    pub zFile: *const libc::c_char,
    pub in_0: *mut FILE,
    pub xCloser: Option::<unsafe extern "C" fn(*mut FILE) -> libc::c_int>,
    pub z: *mut libc::c_char,
    pub n: libc::c_int,
    pub nAlloc: libc::c_int,
    pub nLine: libc::c_int,
    pub nRow: libc::c_int,
    pub nErr: libc::c_int,
    pub bNotFirst: libc::c_int,
    pub cTerm: libc::c_int,
    pub cColSep: libc::c_int,
    pub cRowSep: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_21 {
    pub zCtrlName: *const libc::c_char,
    pub ctrlCode: libc::c_int,
    pub zUsage: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_22 {
    pub zName: *const libc::c_char,
    pub zSql: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_23 {
    pub zName: *const libc::c_char,
    pub ofst: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DbConfigChoices {
    pub zName: *const libc::c_char,
    pub op: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ArCommand {
    pub eCmd: u8_0,
    pub bVerbose: u8_0,
    pub bZip: u8_0,
    pub bDryRun: u8_0,
    pub bAppend: u8_0,
    pub bGlob: u8_0,
    pub fromCmdLine: u8_0,
    pub nArg: libc::c_int,
    pub zSrcTable: *mut libc::c_char,
    pub zFile: *const libc::c_char,
    pub zDir: *const libc::c_char,
    pub azArg: *mut *mut libc::c_char,
    pub p: *mut ShellState,
    pub db: *mut sqlite3,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ArSwitch {
    pub zLong: *const libc::c_char,
    pub cShort: libc::c_char,
    pub eSwitch: u8_0,
    pub bArg: u8_0,
}
#[inline]
unsafe extern "C" fn atoi(mut __nptr: *const libc::c_char) -> libc::c_int {
    return strtol(
        __nptr,
        0 as *mut libc::c_void as *mut *mut libc::c_char,
        10 as libc::c_int,
    ) as libc::c_int;
}
#[inline]
unsafe extern "C" fn tolower(mut __c: libc::c_int) -> libc::c_int {
    return if __c >= -(128 as libc::c_int) && __c < 256 as libc::c_int {
        *(*__ctype_tolower_loc()).offset(__c as isize)
    } else {
        __c
    };
}
#[inline]
unsafe extern "C" fn stat(
    mut __path: *const libc::c_char,
    mut __statbuf: *mut stat,
) -> libc::c_int {
    return __xstat(1 as libc::c_int, __path, __statbuf);
}
#[inline]
unsafe extern "C" fn lstat(
    mut __path: *const libc::c_char,
    mut __statbuf: *mut stat,
) -> libc::c_int {
    return __lxstat(1 as libc::c_int, __path, __statbuf);
}
static mut enableTimer: libc::c_int = 0 as libc::c_int;
unsafe extern "C" fn cli_strcmp(
    mut a: *const libc::c_char,
    mut b: *const libc::c_char,
) -> libc::c_int {
    if a.is_null() {
        a = b"\0" as *const u8 as *const libc::c_char;
    }
    if b.is_null() {
        b = b"\0" as *const u8 as *const libc::c_char;
    }
    return strcmp(a, b);
}
unsafe extern "C" fn cli_strncmp(
    mut a: *const libc::c_char,
    mut b: *const libc::c_char,
    mut n: size_t,
) -> libc::c_int {
    if a.is_null() {
        a = b"\0" as *const u8 as *const libc::c_char;
    }
    if b.is_null() {
        b = b"\0" as *const u8 as *const libc::c_char;
    }
    return strncmp(a, b, n);
}
unsafe extern "C" fn timeOfDay() -> sqlite3_int64 {
    static mut clockVfs: *mut sqlite3_vfs = 0 as *const sqlite3_vfs as *mut sqlite3_vfs;
    let mut t: sqlite3_int64 = 0;
    if clockVfs.is_null() {
        clockVfs = sqlite3_vfs_find(0 as *const libc::c_char);
    }
    if clockVfs.is_null() {
        return 0 as libc::c_int as sqlite3_int64;
    }
    if (*clockVfs).iVersion >= 2 as libc::c_int
        && ((*clockVfs).xCurrentTimeInt64).is_some()
    {
        ((*clockVfs).xCurrentTimeInt64)
            .expect("non-null function pointer")(clockVfs, &mut t);
    } else {
        let mut r: libc::c_double = 0.;
        ((*clockVfs).xCurrentTime).expect("non-null function pointer")(clockVfs, &mut r);
        t = (r * 86400000.0f64) as sqlite3_int64;
    }
    return t;
}
static mut sBegin: rusage = rusage {
    ru_utime: timeval { tv_sec: 0, tv_usec: 0 },
    ru_stime: timeval { tv_sec: 0, tv_usec: 0 },
    c2rust_unnamed: C2RustUnnamed_13 { ru_maxrss: 0 },
    c2rust_unnamed_0: C2RustUnnamed_12 { ru_ixrss: 0 },
    c2rust_unnamed_1: C2RustUnnamed_11 { ru_idrss: 0 },
    c2rust_unnamed_2: C2RustUnnamed_10 { ru_isrss: 0 },
    c2rust_unnamed_3: C2RustUnnamed_9 { ru_minflt: 0 },
    c2rust_unnamed_4: C2RustUnnamed_8 { ru_majflt: 0 },
    c2rust_unnamed_5: C2RustUnnamed_7 { ru_nswap: 0 },
    c2rust_unnamed_6: C2RustUnnamed_6 { ru_inblock: 0 },
    c2rust_unnamed_7: C2RustUnnamed_5 { ru_oublock: 0 },
    c2rust_unnamed_8: C2RustUnnamed_4 { ru_msgsnd: 0 },
    c2rust_unnamed_9: C2RustUnnamed_3 { ru_msgrcv: 0 },
    c2rust_unnamed_10: C2RustUnnamed_2 { ru_nsignals: 0 },
    c2rust_unnamed_11: C2RustUnnamed_1 { ru_nvcsw: 0 },
    c2rust_unnamed_12: C2RustUnnamed_0 { ru_nivcsw: 0 },
};
static mut iBegin: sqlite3_int64 = 0;
unsafe extern "C" fn beginTimer() {
    if enableTimer != 0 {
        getrusage(RUSAGE_SELF as libc::c_int, &mut sBegin);
        iBegin = timeOfDay();
    }
}
unsafe extern "C" fn timeDiff(
    mut pStart: *mut timeval,
    mut pEnd: *mut timeval,
) -> libc::c_double {
    return ((*pEnd).tv_usec - (*pStart).tv_usec) as libc::c_double * 0.000001f64
        + ((*pEnd).tv_sec - (*pStart).tv_sec) as libc::c_double;
}
unsafe extern "C" fn endTimer() {
    if enableTimer != 0 {
        let mut iEnd: sqlite3_int64 = timeOfDay();
        let mut sEnd: rusage = rusage {
            ru_utime: timeval { tv_sec: 0, tv_usec: 0 },
            ru_stime: timeval { tv_sec: 0, tv_usec: 0 },
            c2rust_unnamed: C2RustUnnamed_13 { ru_maxrss: 0 },
            c2rust_unnamed_0: C2RustUnnamed_12 { ru_ixrss: 0 },
            c2rust_unnamed_1: C2RustUnnamed_11 { ru_idrss: 0 },
            c2rust_unnamed_2: C2RustUnnamed_10 { ru_isrss: 0 },
            c2rust_unnamed_3: C2RustUnnamed_9 { ru_minflt: 0 },
            c2rust_unnamed_4: C2RustUnnamed_8 { ru_majflt: 0 },
            c2rust_unnamed_5: C2RustUnnamed_7 { ru_nswap: 0 },
            c2rust_unnamed_6: C2RustUnnamed_6 { ru_inblock: 0 },
            c2rust_unnamed_7: C2RustUnnamed_5 { ru_oublock: 0 },
            c2rust_unnamed_8: C2RustUnnamed_4 { ru_msgsnd: 0 },
            c2rust_unnamed_9: C2RustUnnamed_3 { ru_msgrcv: 0 },
            c2rust_unnamed_10: C2RustUnnamed_2 { ru_nsignals: 0 },
            c2rust_unnamed_11: C2RustUnnamed_1 { ru_nvcsw: 0 },
            c2rust_unnamed_12: C2RustUnnamed_0 { ru_nivcsw: 0 },
        };
        getrusage(RUSAGE_SELF as libc::c_int, &mut sEnd);
        printf(
            b"Run Time: real %.3f user %f sys %f\n\0" as *const u8
                as *const libc::c_char,
            (iEnd - iBegin) as libc::c_double * 0.001f64,
            timeDiff(&mut sBegin.ru_utime, &mut sEnd.ru_utime),
            timeDiff(&mut sBegin.ru_stime, &mut sEnd.ru_stime),
        );
    }
}
static mut bail_on_error: libc::c_int = 0 as libc::c_int;
static mut stdin_is_interactive: libc::c_int = 1 as libc::c_int;
static mut stdout_is_console: libc::c_int = 1 as libc::c_int;
static mut globalDb: *mut sqlite3 = 0 as *const sqlite3 as *mut sqlite3;
static mut seenInterrupt: libc::c_int = 0 as libc::c_int;
static mut Argv0: *mut libc::c_char = 0 as *const libc::c_char as *mut libc::c_char;
static mut mainPrompt: [libc::c_char; 20] = [0; 20];
static mut continuePrompt: [libc::c_char; 20] = [0; 20];
unsafe extern "C" fn shell_out_of_memory() {
    fprintf(stderr, b"Error: out of memory\n\0" as *const u8 as *const libc::c_char);
    exit(1 as libc::c_int);
}
unsafe extern "C" fn shell_check_oom(mut p: *mut libc::c_void) {
    if p.is_null() {
        shell_out_of_memory();
    }
}
unsafe extern "C" fn utf8_width_print(
    mut pOut: *mut FILE,
    mut w: libc::c_int,
    mut zUtf: *const libc::c_char,
) {
    let mut i: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut aw: libc::c_int = if w < 0 as libc::c_int { -w } else { w };
    if zUtf.is_null() {
        zUtf = b"\0" as *const u8 as *const libc::c_char;
    }
    n = 0 as libc::c_int;
    i = n;
    while *zUtf.offset(i as isize) != 0 {
        if *zUtf.offset(i as isize) as libc::c_int & 0xc0 as libc::c_int
            != 0x80 as libc::c_int
        {
            n += 1;
            if n == aw {
                loop {
                    i += 1;
                    if !(*zUtf.offset(i as isize) as libc::c_int & 0xc0 as libc::c_int
                        == 0x80 as libc::c_int)
                    {
                        break;
                    }
                }
                break;
            }
        }
        i += 1;
    }
    if n >= aw {
        fprintf(pOut, b"%.*s\0" as *const u8 as *const libc::c_char, i, zUtf);
    } else if w < 0 as libc::c_int {
        fprintf(
            pOut,
            b"%*s%s\0" as *const u8 as *const libc::c_char,
            aw - n,
            b"\0" as *const u8 as *const libc::c_char,
            zUtf,
        );
    } else {
        fprintf(
            pOut,
            b"%s%*s\0" as *const u8 as *const libc::c_char,
            zUtf,
            aw - n,
            b"\0" as *const u8 as *const libc::c_char,
        );
    };
}
unsafe extern "C" fn isNumber(
    mut z: *const libc::c_char,
    mut realnum: *mut libc::c_int,
) -> libc::c_int {
    if *z as libc::c_int == '-' as i32 || *z as libc::c_int == '+' as i32 {
        z = z.offset(1);
    }
    if *(*__ctype_b_loc()).offset(*z as libc::c_uchar as libc::c_int as isize)
        as libc::c_int & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int == 0
    {
        return 0 as libc::c_int;
    }
    z = z.offset(1);
    if !realnum.is_null() {
        *realnum = 0 as libc::c_int;
    }
    while *(*__ctype_b_loc()).offset(*z as libc::c_uchar as libc::c_int as isize)
        as libc::c_int & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int != 0
    {
        z = z.offset(1);
    }
    if *z as libc::c_int == '.' as i32 {
        z = z.offset(1);
        if *(*__ctype_b_loc()).offset(*z as libc::c_uchar as libc::c_int as isize)
            as libc::c_int & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
            == 0
        {
            return 0 as libc::c_int;
        }
        while *(*__ctype_b_loc()).offset(*z as libc::c_uchar as libc::c_int as isize)
            as libc::c_int & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
            != 0
        {
            z = z.offset(1);
        }
        if !realnum.is_null() {
            *realnum = 1 as libc::c_int;
        }
    }
    if *z as libc::c_int == 'e' as i32 || *z as libc::c_int == 'E' as i32 {
        z = z.offset(1);
        if *z as libc::c_int == '+' as i32 || *z as libc::c_int == '-' as i32 {
            z = z.offset(1);
        }
        if *(*__ctype_b_loc()).offset(*z as libc::c_uchar as libc::c_int as isize)
            as libc::c_int & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
            == 0
        {
            return 0 as libc::c_int;
        }
        while *(*__ctype_b_loc()).offset(*z as libc::c_uchar as libc::c_int as isize)
            as libc::c_int & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
            != 0
        {
            z = z.offset(1);
        }
        if !realnum.is_null() {
            *realnum = 1 as libc::c_int;
        }
    }
    return (*z as libc::c_int == 0 as libc::c_int) as libc::c_int;
}
unsafe extern "C" fn strlen30(mut z: *const libc::c_char) -> libc::c_int {
    let mut z2: *const libc::c_char = z;
    while *z2 != 0 {
        z2 = z2.offset(1);
    }
    return 0x3fffffff as libc::c_int & z2.offset_from(z) as libc::c_long as libc::c_int;
}
unsafe extern "C" fn strlenChar(mut z: *const libc::c_char) -> libc::c_int {
    let mut n: libc::c_int = 0 as libc::c_int;
    while *z != 0 {
        let fresh0 = z;
        z = z.offset(1);
        if 0xc0 as libc::c_int & *fresh0 as libc::c_int != 0x80 as libc::c_int {
            n += 1;
        }
    }
    return n;
}
unsafe extern "C" fn openChrSource(mut zFile: *const libc::c_char) -> *mut FILE {
    let mut x: stat = {
        let mut init = stat {
            st_dev: 0 as libc::c_int as __dev_t,
            st_ino: 0,
            st_nlink: 0,
            st_mode: 0,
            st_uid: 0,
            st_gid: 0,
            __pad0: 0,
            st_rdev: 0,
            st_size: 0,
            st_blksize: 0,
            st_blocks: 0,
            st_atim: timespec { tv_sec: 0, tv_nsec: 0 },
            st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },
            st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },
            __glibc_reserved: [0; 3],
        };
        init
    };
    let mut rc: libc::c_int = stat(zFile, &mut x);
    if rc != 0 as libc::c_int {
        return 0 as *mut FILE;
    }
    if x.st_mode & 0o170000 as libc::c_int as libc::c_uint
        == 0o100000 as libc::c_int as libc::c_uint
        || x.st_mode & 0o170000 as libc::c_int as libc::c_uint
            == 0o10000 as libc::c_int as libc::c_uint
        || x.st_mode & 0o170000 as libc::c_int as libc::c_uint
            == 0o20000 as libc::c_int as libc::c_uint
    {
        return fopen(zFile, b"rb\0" as *const u8 as *const libc::c_char)
    } else {
        return 0 as *mut FILE
    };
}
unsafe extern "C" fn local_getline(
    mut zLine: *mut libc::c_char,
    mut in_0: *mut FILE,
) -> *mut libc::c_char {
    let mut nLine: libc::c_int = if zLine.is_null() {
        0 as libc::c_int
    } else {
        100 as libc::c_int
    };
    let mut n: libc::c_int = 0 as libc::c_int;
    loop {
        if n + 100 as libc::c_int > nLine {
            nLine = nLine * 2 as libc::c_int + 100 as libc::c_int;
            zLine = realloc(zLine as *mut libc::c_void, nLine as libc::c_ulong)
                as *mut libc::c_char;
            shell_check_oom(zLine as *mut libc::c_void);
        }
        if (fgets(&mut *zLine.offset(n as isize), nLine - n, in_0)).is_null() {
            if n == 0 as libc::c_int {
                free(zLine as *mut libc::c_void);
                return 0 as *mut libc::c_char;
            }
            *zLine.offset(n as isize) = 0 as libc::c_int as libc::c_char;
            break;
        } else {
            while *zLine.offset(n as isize) != 0 {
                n += 1;
            }
            if !(n > 0 as libc::c_int
                && *zLine.offset((n - 1 as libc::c_int) as isize) as libc::c_int
                    == '\n' as i32)
            {
                continue;
            }
            n -= 1;
            if n > 0 as libc::c_int
                && *zLine.offset((n - 1 as libc::c_int) as isize) as libc::c_int
                    == '\r' as i32
            {
                n -= 1;
            }
            *zLine.offset(n as isize) = 0 as libc::c_int as libc::c_char;
            break;
        }
    }
    return zLine;
}
unsafe extern "C" fn one_input_line(
    mut in_0: *mut FILE,
    mut zPrior: *mut libc::c_char,
    mut isContinuation: libc::c_int,
) -> *mut libc::c_char {
    let mut zPrompt: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zResult: *mut libc::c_char = 0 as *mut libc::c_char;
    if !in_0.is_null() {
        zResult = local_getline(zPrior, in_0);
    } else {
        zPrompt = if isContinuation != 0 {
            continuePrompt.as_mut_ptr()
        } else {
            mainPrompt.as_mut_ptr()
        };
        free(zPrior as *mut libc::c_void);
        zResult = readline(zPrompt);
        if !zResult.is_null() && *zResult as libc::c_int != 0 {
            add_history(zResult);
        }
    }
    return zResult;
}
unsafe extern "C" fn hexDigitValue(mut c: libc::c_char) -> libc::c_int {
    if c as libc::c_int >= '0' as i32 && c as libc::c_int <= '9' as i32 {
        return c as libc::c_int - '0' as i32;
    }
    if c as libc::c_int >= 'a' as i32 && c as libc::c_int <= 'f' as i32 {
        return c as libc::c_int - 'a' as i32 + 10 as libc::c_int;
    }
    if c as libc::c_int >= 'A' as i32 && c as libc::c_int <= 'F' as i32 {
        return c as libc::c_int - 'A' as i32 + 10 as libc::c_int;
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn integerValue(mut zArg: *const libc::c_char) -> sqlite3_int64 {
    let mut v: sqlite3_int64 = 0 as libc::c_int as sqlite3_int64;
    static mut aMult: [C2RustUnnamed_14; 9] = [
        {
            let mut init = C2RustUnnamed_14 {
                zSuffix: b"KiB\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                iMult: 1024 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_14 {
                zSuffix: b"MiB\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                iMult: 1024 as libc::c_int * 1024 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_14 {
                zSuffix: b"GiB\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                iMult: 1024 as libc::c_int * 1024 as libc::c_int * 1024 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_14 {
                zSuffix: b"KB\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                iMult: 1000 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_14 {
                zSuffix: b"MB\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                iMult: 1000000 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_14 {
                zSuffix: b"GB\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                iMult: 1000000000 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_14 {
                zSuffix: b"K\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                iMult: 1000 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_14 {
                zSuffix: b"M\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                iMult: 1000000 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_14 {
                zSuffix: b"G\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                iMult: 1000000000 as libc::c_int,
            };
            init
        },
    ];
    let mut i: libc::c_int = 0;
    let mut isNeg: libc::c_int = 0 as libc::c_int;
    if *zArg.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
        isNeg = 1 as libc::c_int;
        zArg = zArg.offset(1);
    } else if *zArg.offset(0 as libc::c_int as isize) as libc::c_int == '+' as i32 {
        zArg = zArg.offset(1);
    }
    if *zArg.offset(0 as libc::c_int as isize) as libc::c_int == '0' as i32
        && *zArg.offset(1 as libc::c_int as isize) as libc::c_int == 'x' as i32
    {
        let mut x: libc::c_int = 0;
        zArg = zArg.offset(2 as libc::c_int as isize);
        loop {
            x = hexDigitValue(*zArg.offset(0 as libc::c_int as isize));
            if !(x >= 0 as libc::c_int) {
                break;
            }
            v = (v << 4 as libc::c_int) + x as libc::c_longlong;
            zArg = zArg.offset(1);
        }
    } else {
        while *(*__ctype_b_loc())
            .offset(
                *zArg.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                    as isize,
            ) as libc::c_int & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
            != 0
        {
            v = v * 10 as libc::c_int as libc::c_longlong
                + *zArg.offset(0 as libc::c_int as isize) as libc::c_longlong
                - '0' as i32 as libc::c_longlong;
            zArg = zArg.offset(1);
        }
    }
    i = 0 as libc::c_int;
    while i
        < (::std::mem::size_of::<[C2RustUnnamed_14; 9]>() as libc::c_ulong)
            .wrapping_div(::std::mem::size_of::<C2RustUnnamed_14>() as libc::c_ulong)
            as libc::c_int
    {
        if sqlite3_stricmp(aMult[i as usize].zSuffix, zArg) == 0 as libc::c_int {
            v *= aMult[i as usize].iMult as libc::c_longlong;
            break;
        } else {
            i += 1;
        }
    }
    return if isNeg != 0 { -v } else { v };
}
unsafe extern "C" fn initText(mut p: *mut ShellText) {
    memset(
        p as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<ShellText>() as libc::c_ulong,
    );
}
unsafe extern "C" fn freeText(mut p: *mut ShellText) {
    free((*p).z as *mut libc::c_void);
    initText(p);
}
unsafe extern "C" fn appendText(
    mut p: *mut ShellText,
    mut zAppend: *const libc::c_char,
    mut quote: libc::c_char,
) {
    let mut len: i64_0 = 0;
    let mut i: i64_0 = 0;
    let mut nAppend: i64_0 = strlen30(zAppend) as i64_0;
    len = nAppend + (*p).n as libc::c_longlong + 1 as libc::c_int as libc::c_longlong;
    if quote != 0 {
        len += 2 as libc::c_int as libc::c_longlong;
        i = 0 as libc::c_int as i64_0;
        while i < nAppend {
            if *zAppend.offset(i as isize) as libc::c_int == quote as libc::c_int {
                len += 1;
            }
            i += 1;
        }
    }
    if ((*p).z).is_null()
        || (*p).n as libc::c_longlong + len >= (*p).nAlloc as libc::c_longlong
    {
        (*p)
            .nAlloc = (((*p).nAlloc * 2 as libc::c_int) as libc::c_longlong + len
            + 20 as libc::c_int as libc::c_longlong) as libc::c_int;
        let ref mut fresh1 = (*p).z;
        *fresh1 = realloc((*p).z as *mut libc::c_void, (*p).nAlloc as libc::c_ulong)
            as *mut libc::c_char;
        shell_check_oom((*p).z as *mut libc::c_void);
    }
    if quote != 0 {
        let mut zCsr: *mut libc::c_char = ((*p).z).offset((*p).n as isize);
        let fresh2 = zCsr;
        zCsr = zCsr.offset(1);
        *fresh2 = quote;
        i = 0 as libc::c_int as i64_0;
        while i < nAppend {
            let fresh3 = zCsr;
            zCsr = zCsr.offset(1);
            *fresh3 = *zAppend.offset(i as isize);
            if *zAppend.offset(i as isize) as libc::c_int == quote as libc::c_int {
                let fresh4 = zCsr;
                zCsr = zCsr.offset(1);
                *fresh4 = quote;
            }
            i += 1;
        }
        let fresh5 = zCsr;
        zCsr = zCsr.offset(1);
        *fresh5 = quote;
        (*p).n = zCsr.offset_from((*p).z) as libc::c_long as libc::c_int;
        *zCsr = '\0' as i32 as libc::c_char;
    } else {
        memcpy(
            ((*p).z).offset((*p).n as isize) as *mut libc::c_void,
            zAppend as *const libc::c_void,
            nAppend as libc::c_ulong,
        );
        let ref mut fresh6 = (*p).n;
        *fresh6 = (*fresh6 as libc::c_longlong + nAppend) as libc::c_int;
        *((*p).z).offset((*p).n as isize) = '\0' as i32 as libc::c_char;
    };
}
unsafe extern "C" fn quoteChar(mut zName: *const libc::c_char) -> libc::c_char {
    let mut i: libc::c_int = 0;
    if *(*__ctype_b_loc())
        .offset(
            *zName.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                as isize,
        ) as libc::c_int & _ISalpha as libc::c_int as libc::c_ushort as libc::c_int == 0
        && *zName.offset(0 as libc::c_int as isize) as libc::c_int != '_' as i32
    {
        return '"' as i32 as libc::c_char;
    }
    i = 0 as libc::c_int;
    while *zName.offset(i as isize) != 0 {
        if *(*__ctype_b_loc())
            .offset(*zName.offset(i as isize) as libc::c_uchar as libc::c_int as isize)
            as libc::c_int & _ISalnum as libc::c_int as libc::c_ushort as libc::c_int
            == 0 && *zName.offset(i as isize) as libc::c_int != '_' as i32
        {
            return '"' as i32 as libc::c_char;
        }
        i += 1;
    }
    return (if sqlite3_keyword_check(zName, i) != 0 {
        '"' as i32
    } else {
        0 as libc::c_int
    }) as libc::c_char;
}
unsafe extern "C" fn shellFakeSchema(
    mut db: *mut sqlite3,
    mut zSchema: *const libc::c_char,
    mut zName: *const libc::c_char,
) -> *mut libc::c_char {
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut s: ShellText = ShellText {
        z: 0 as *mut libc::c_char,
        n: 0,
        nAlloc: 0,
    };
    let mut cQuote: libc::c_char = 0;
    let mut zDiv: *mut libc::c_char = b"(\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    let mut nRow: libc::c_int = 0 as libc::c_int;
    zSql = sqlite3_mprintf(
        b"PRAGMA \"%w\".table_info=%Q;\0" as *const u8 as *const libc::c_char,
        if !zSchema.is_null() {
            zSchema
        } else {
            b"main\0" as *const u8 as *const libc::c_char
        },
        zName,
    );
    shell_check_oom(zSql as *mut libc::c_void);
    sqlite3_prepare_v2(
        db,
        zSql,
        -(1 as libc::c_int),
        &mut pStmt,
        0 as *mut *const libc::c_char,
    );
    sqlite3_free(zSql as *mut libc::c_void);
    initText(&mut s);
    if !zSchema.is_null() {
        cQuote = quoteChar(zSchema);
        if cQuote as libc::c_int != 0
            && sqlite3_stricmp(zSchema, b"temp\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
        {
            cQuote = 0 as libc::c_int as libc::c_char;
        }
        appendText(&mut s, zSchema, cQuote);
        appendText(
            &mut s,
            b".\0" as *const u8 as *const libc::c_char,
            0 as libc::c_int as libc::c_char,
        );
    }
    cQuote = quoteChar(zName);
    appendText(&mut s, zName, cQuote);
    while sqlite3_step(pStmt) == 100 as libc::c_int {
        let mut zCol: *const libc::c_char = sqlite3_column_text(pStmt, 1 as libc::c_int)
            as *const libc::c_char;
        nRow += 1;
        appendText(&mut s, zDiv, 0 as libc::c_int as libc::c_char);
        zDiv = b",\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
        if zCol.is_null() {
            zCol = b"\0" as *const u8 as *const libc::c_char;
        }
        cQuote = quoteChar(zCol);
        appendText(&mut s, zCol, cQuote);
    }
    appendText(
        &mut s,
        b")\0" as *const u8 as *const libc::c_char,
        0 as libc::c_int as libc::c_char,
    );
    sqlite3_finalize(pStmt);
    if nRow == 0 as libc::c_int {
        freeText(&mut s);
        s.z = 0 as *mut libc::c_char;
    }
    return s.z;
}
unsafe extern "C" fn shellModuleSchema(
    mut pCtx: *mut sqlite3_context,
    mut nVal: libc::c_int,
    mut apVal: *mut *mut sqlite3_value,
) {
    let mut zName: *const libc::c_char = 0 as *const libc::c_char;
    let mut zFake: *mut libc::c_char = 0 as *mut libc::c_char;
    zName = sqlite3_value_text(*apVal.offset(0 as libc::c_int as isize))
        as *const libc::c_char;
    zFake = if !zName.is_null() {
        shellFakeSchema(sqlite3_context_db_handle(pCtx), 0 as *const libc::c_char, zName)
    } else {
        0 as *mut libc::c_char
    };
    if !zFake.is_null() {
        sqlite3_result_text(
            pCtx,
            sqlite3_mprintf(b"/* %s */\0" as *const u8 as *const libc::c_char, zFake),
            -(1 as libc::c_int),
            Some(sqlite3_free as unsafe extern "C" fn(*mut libc::c_void) -> ()),
        );
        free(zFake as *mut libc::c_void);
    }
}
unsafe extern "C" fn shellAddSchemaName(
    mut pCtx: *mut sqlite3_context,
    mut nVal: libc::c_int,
    mut apVal: *mut *mut sqlite3_value,
) {
    static mut aPrefix: [*const libc::c_char; 6] = [
        b"TABLE\0" as *const u8 as *const libc::c_char,
        b"INDEX\0" as *const u8 as *const libc::c_char,
        b"UNIQUE INDEX\0" as *const u8 as *const libc::c_char,
        b"VIEW\0" as *const u8 as *const libc::c_char,
        b"TRIGGER\0" as *const u8 as *const libc::c_char,
        b"VIRTUAL TABLE\0" as *const u8 as *const libc::c_char,
    ];
    let mut i: libc::c_int = 0 as libc::c_int;
    let mut zIn: *const libc::c_char = sqlite3_value_text(
        *apVal.offset(0 as libc::c_int as isize),
    ) as *const libc::c_char;
    let mut zSchema: *const libc::c_char = sqlite3_value_text(
        *apVal.offset(1 as libc::c_int as isize),
    ) as *const libc::c_char;
    let mut zName: *const libc::c_char = sqlite3_value_text(
        *apVal.offset(2 as libc::c_int as isize),
    ) as *const libc::c_char;
    let mut db: *mut sqlite3 = sqlite3_context_db_handle(pCtx);
    if !zIn.is_null()
        && cli_strncmp(
            zIn,
            b"CREATE \0" as *const u8 as *const libc::c_char,
            7 as libc::c_int as size_t,
        ) == 0 as libc::c_int
    {
        i = 0 as libc::c_int;
        while i
            < (::std::mem::size_of::<[*const libc::c_char; 6]>() as libc::c_ulong)
                .wrapping_div(
                    ::std::mem::size_of::<*const libc::c_char>() as libc::c_ulong,
                ) as libc::c_int
        {
            let mut n: libc::c_int = strlen30(aPrefix[i as usize]);
            if cli_strncmp(
                zIn.offset(7 as libc::c_int as isize),
                aPrefix[i as usize],
                n as size_t,
            ) == 0 as libc::c_int
                && *zIn.offset((n + 7 as libc::c_int) as isize) as libc::c_int
                    == ' ' as i32
            {
                let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
                let mut zFake: *mut libc::c_char = 0 as *mut libc::c_char;
                if !zSchema.is_null() {
                    let mut cQuote: libc::c_char = quoteChar(zSchema);
                    if cQuote as libc::c_int != 0
                        && sqlite3_stricmp(
                            zSchema,
                            b"temp\0" as *const u8 as *const libc::c_char,
                        ) != 0 as libc::c_int
                    {
                        z = sqlite3_mprintf(
                            b"%.*s \"%w\".%s\0" as *const u8 as *const libc::c_char,
                            n + 7 as libc::c_int,
                            zIn,
                            zSchema,
                            zIn.offset(n as isize).offset(8 as libc::c_int as isize),
                        );
                    } else {
                        z = sqlite3_mprintf(
                            b"%.*s %s.%s\0" as *const u8 as *const libc::c_char,
                            n + 7 as libc::c_int,
                            zIn,
                            zSchema,
                            zIn.offset(n as isize).offset(8 as libc::c_int as isize),
                        );
                    }
                }
                if !zName.is_null()
                    && *(aPrefix[i as usize]).offset(0 as libc::c_int as isize)
                        as libc::c_int == 'V' as i32
                    && {
                        zFake = shellFakeSchema(db, zSchema, zName);
                        !zFake.is_null()
                    }
                {
                    if z.is_null() {
                        z = sqlite3_mprintf(
                            b"%s\n/* %s */\0" as *const u8 as *const libc::c_char,
                            zIn,
                            zFake,
                        );
                    } else {
                        z = sqlite3_mprintf(
                            b"%z\n/* %s */\0" as *const u8 as *const libc::c_char,
                            z,
                            zFake,
                        );
                    }
                    free(zFake as *mut libc::c_void);
                }
                if !z.is_null() {
                    sqlite3_result_text(
                        pCtx,
                        z,
                        -(1 as libc::c_int),
                        Some(
                            sqlite3_free as unsafe extern "C" fn(*mut libc::c_void) -> (),
                        ),
                    );
                    return;
                }
            }
            i += 1;
        }
    }
    sqlite3_result_value(pCtx, *apVal.offset(0 as libc::c_int as isize));
}
static mut memtraceBase: sqlite3_mem_methods = sqlite3_mem_methods {
    xMalloc: None,
    xFree: None,
    xRealloc: None,
    xSize: None,
    xRoundup: None,
    xInit: None,
    xShutdown: None,
    pAppData: 0 as *const libc::c_void as *mut libc::c_void,
};
static mut memtraceOut: *mut FILE = 0 as *const FILE as *mut FILE;
unsafe extern "C" fn memtraceMalloc(mut n: libc::c_int) -> *mut libc::c_void {
    if !memtraceOut.is_null() {
        fprintf(
            memtraceOut,
            b"MEMTRACE: allocate %d bytes\n\0" as *const u8 as *const libc::c_char,
            (memtraceBase.xRoundup).expect("non-null function pointer")(n),
        );
    }
    return (memtraceBase.xMalloc).expect("non-null function pointer")(n);
}
unsafe extern "C" fn memtraceFree(mut p: *mut libc::c_void) {
    if p.is_null() {
        return;
    }
    if !memtraceOut.is_null() {
        fprintf(
            memtraceOut,
            b"MEMTRACE: free %d bytes\n\0" as *const u8 as *const libc::c_char,
            (memtraceBase.xSize).expect("non-null function pointer")(p),
        );
    }
    (memtraceBase.xFree).expect("non-null function pointer")(p);
}
unsafe extern "C" fn memtraceRealloc(
    mut p: *mut libc::c_void,
    mut n: libc::c_int,
) -> *mut libc::c_void {
    if p.is_null() {
        return memtraceMalloc(n);
    }
    if n == 0 as libc::c_int {
        memtraceFree(p);
        return 0 as *mut libc::c_void;
    }
    if !memtraceOut.is_null() {
        fprintf(
            memtraceOut,
            b"MEMTRACE: resize %d -> %d bytes\n\0" as *const u8 as *const libc::c_char,
            (memtraceBase.xSize).expect("non-null function pointer")(p),
            (memtraceBase.xRoundup).expect("non-null function pointer")(n),
        );
    }
    return (memtraceBase.xRealloc).expect("non-null function pointer")(p, n);
}
unsafe extern "C" fn memtraceSize(mut p: *mut libc::c_void) -> libc::c_int {
    return (memtraceBase.xSize).expect("non-null function pointer")(p);
}
unsafe extern "C" fn memtraceRoundup(mut n: libc::c_int) -> libc::c_int {
    return (memtraceBase.xRoundup).expect("non-null function pointer")(n);
}
unsafe extern "C" fn memtraceInit(mut p: *mut libc::c_void) -> libc::c_int {
    return (memtraceBase.xInit).expect("non-null function pointer")(p);
}
unsafe extern "C" fn memtraceShutdown(mut p: *mut libc::c_void) {
    (memtraceBase.xShutdown).expect("non-null function pointer")(p);
}
static mut ersaztMethods: sqlite3_mem_methods = unsafe {
    {
        let mut init = sqlite3_mem_methods {
            xMalloc: Some(
                memtraceMalloc as unsafe extern "C" fn(libc::c_int) -> *mut libc::c_void,
            ),
            xFree: Some(memtraceFree as unsafe extern "C" fn(*mut libc::c_void) -> ()),
            xRealloc: Some(
                memtraceRealloc
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        libc::c_int,
                    ) -> *mut libc::c_void,
            ),
            xSize: Some(
                memtraceSize as unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int,
            ),
            xRoundup: Some(
                memtraceRoundup as unsafe extern "C" fn(libc::c_int) -> libc::c_int,
            ),
            xInit: Some(
                memtraceInit as unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int,
            ),
            xShutdown: Some(
                memtraceShutdown as unsafe extern "C" fn(*mut libc::c_void) -> (),
            ),
            pAppData: 0 as *const libc::c_void as *mut libc::c_void,
        };
        init
    }
};
#[no_mangle]
pub unsafe extern "C" fn sqlite3MemTraceActivate(mut out: *mut FILE) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (memtraceBase.xMalloc).is_none() {
        rc = sqlite3_config(
            5 as libc::c_int,
            &mut memtraceBase as *mut sqlite3_mem_methods,
        );
        if rc == 0 as libc::c_int {
            rc = sqlite3_config(
                4 as libc::c_int,
                &mut ersaztMethods as *mut sqlite3_mem_methods,
            );
        }
    }
    memtraceOut = out;
    return rc;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3MemTraceDeactivate() -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (memtraceBase.xMalloc).is_some() {
        rc = sqlite3_config(
            4 as libc::c_int,
            &mut memtraceBase as *mut sqlite3_mem_methods,
        );
        if rc == 0 as libc::c_int {
            memset(
                &mut memtraceBase as *mut sqlite3_mem_methods as *mut libc::c_void,
                0 as libc::c_int,
                ::std::mem::size_of::<sqlite3_mem_methods>() as libc::c_ulong,
            );
        }
    }
    memtraceOut = 0 as *mut FILE;
    return rc;
}
unsafe extern "C" fn KeccakF1600Step(mut p: *mut SHA3Context) {
    let mut i: libc::c_int = 0;
    let mut b0: u64_0 = 0;
    let mut b1: u64_0 = 0;
    let mut b2: u64_0 = 0;
    let mut b3: u64_0 = 0;
    let mut b4: u64_0 = 0;
    let mut c0: u64_0 = 0;
    let mut c1: u64_0 = 0;
    let mut c2: u64_0 = 0;
    let mut c3: u64_0 = 0;
    let mut c4: u64_0 = 0;
    let mut d0: u64_0 = 0;
    let mut d1: u64_0 = 0;
    let mut d2: u64_0 = 0;
    let mut d3: u64_0 = 0;
    let mut d4: u64_0 = 0;
    static mut RC: [u64_0; 24] = [
        0x1 as libc::c_ulonglong,
        0x8082 as libc::c_ulonglong,
        0x800000000000808a as libc::c_ulonglong,
        0x8000000080008000 as libc::c_ulonglong,
        0x808b as libc::c_ulonglong,
        0x80000001 as libc::c_ulonglong,
        0x8000000080008081 as libc::c_ulonglong,
        0x8000000000008009 as libc::c_ulonglong,
        0x8a as libc::c_ulonglong,
        0x88 as libc::c_ulonglong,
        0x80008009 as libc::c_ulonglong,
        0x8000000a as libc::c_ulonglong,
        0x8000808b as libc::c_ulonglong,
        0x800000000000008b as libc::c_ulonglong,
        0x8000000000008089 as libc::c_ulonglong,
        0x8000000000008003 as libc::c_ulonglong,
        0x8000000000008002 as libc::c_ulonglong,
        0x8000000000000080 as libc::c_ulonglong,
        0x800a as libc::c_ulonglong,
        0x800000008000000a as libc::c_ulonglong,
        0x8000000080008081 as libc::c_ulonglong,
        0x8000000000008080 as libc::c_ulonglong,
        0x80000001 as libc::c_ulonglong,
        0x8000000080008008 as libc::c_ulonglong,
    ];
    i = 0 as libc::c_int;
    while i < 24 as libc::c_int {
        c0 = (*p).u.s[0 as libc::c_int as usize] ^ (*p).u.s[5 as libc::c_int as usize]
            ^ (*p).u.s[10 as libc::c_int as usize] ^ (*p).u.s[15 as libc::c_int as usize]
            ^ (*p).u.s[20 as libc::c_int as usize];
        c1 = (*p).u.s[1 as libc::c_int as usize] ^ (*p).u.s[6 as libc::c_int as usize]
            ^ (*p).u.s[11 as libc::c_int as usize] ^ (*p).u.s[16 as libc::c_int as usize]
            ^ (*p).u.s[21 as libc::c_int as usize];
        c2 = (*p).u.s[2 as libc::c_int as usize] ^ (*p).u.s[7 as libc::c_int as usize]
            ^ (*p).u.s[12 as libc::c_int as usize] ^ (*p).u.s[17 as libc::c_int as usize]
            ^ (*p).u.s[22 as libc::c_int as usize];
        c3 = (*p).u.s[3 as libc::c_int as usize] ^ (*p).u.s[8 as libc::c_int as usize]
            ^ (*p).u.s[13 as libc::c_int as usize] ^ (*p).u.s[18 as libc::c_int as usize]
            ^ (*p).u.s[23 as libc::c_int as usize];
        c4 = (*p).u.s[4 as libc::c_int as usize] ^ (*p).u.s[9 as libc::c_int as usize]
            ^ (*p).u.s[14 as libc::c_int as usize] ^ (*p).u.s[19 as libc::c_int as usize]
            ^ (*p).u.s[24 as libc::c_int as usize];
        d0 = c4 ^ (c1 << 1 as libc::c_int | c1 >> 64 as libc::c_int - 1 as libc::c_int);
        d1 = c0 ^ (c2 << 1 as libc::c_int | c2 >> 64 as libc::c_int - 1 as libc::c_int);
        d2 = c1 ^ (c3 << 1 as libc::c_int | c3 >> 64 as libc::c_int - 1 as libc::c_int);
        d3 = c2 ^ (c4 << 1 as libc::c_int | c4 >> 64 as libc::c_int - 1 as libc::c_int);
        d4 = c3 ^ (c0 << 1 as libc::c_int | c0 >> 64 as libc::c_int - 1 as libc::c_int);
        b0 = (*p).u.s[0 as libc::c_int as usize] ^ d0;
        b1 = ((*p).u.s[6 as libc::c_int as usize] ^ d1) << 44 as libc::c_int
            | ((*p).u.s[6 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 44 as libc::c_int;
        b2 = ((*p).u.s[12 as libc::c_int as usize] ^ d2) << 43 as libc::c_int
            | ((*p).u.s[12 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 43 as libc::c_int;
        b3 = ((*p).u.s[18 as libc::c_int as usize] ^ d3) << 21 as libc::c_int
            | ((*p).u.s[18 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 21 as libc::c_int;
        b4 = ((*p).u.s[24 as libc::c_int as usize] ^ d4) << 14 as libc::c_int
            | ((*p).u.s[24 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 14 as libc::c_int;
        (*p).u.s[0 as libc::c_int as usize] = b0 ^ !b1 & b2;
        let ref mut fresh7 = (*p).u.s[0 as libc::c_int as usize];
        *fresh7 ^= RC[i as usize];
        (*p).u.s[6 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[12 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[18 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[24 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b2 = ((*p).u.s[10 as libc::c_int as usize] ^ d0) << 3 as libc::c_int
            | ((*p).u.s[10 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 3 as libc::c_int;
        b3 = ((*p).u.s[16 as libc::c_int as usize] ^ d1) << 45 as libc::c_int
            | ((*p).u.s[16 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 45 as libc::c_int;
        b4 = ((*p).u.s[22 as libc::c_int as usize] ^ d2) << 61 as libc::c_int
            | ((*p).u.s[22 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 61 as libc::c_int;
        b0 = ((*p).u.s[3 as libc::c_int as usize] ^ d3) << 28 as libc::c_int
            | ((*p).u.s[3 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 28 as libc::c_int;
        b1 = ((*p).u.s[9 as libc::c_int as usize] ^ d4) << 20 as libc::c_int
            | ((*p).u.s[9 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 20 as libc::c_int;
        (*p).u.s[10 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[16 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[22 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[3 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[9 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b4 = ((*p).u.s[20 as libc::c_int as usize] ^ d0) << 18 as libc::c_int
            | ((*p).u.s[20 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 18 as libc::c_int;
        b0 = ((*p).u.s[1 as libc::c_int as usize] ^ d1) << 1 as libc::c_int
            | ((*p).u.s[1 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 1 as libc::c_int;
        b1 = ((*p).u.s[7 as libc::c_int as usize] ^ d2) << 6 as libc::c_int
            | ((*p).u.s[7 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 6 as libc::c_int;
        b2 = ((*p).u.s[13 as libc::c_int as usize] ^ d3) << 25 as libc::c_int
            | ((*p).u.s[13 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 25 as libc::c_int;
        b3 = ((*p).u.s[19 as libc::c_int as usize] ^ d4) << 8 as libc::c_int
            | ((*p).u.s[19 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 8 as libc::c_int;
        (*p).u.s[20 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[1 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[7 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[13 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[19 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b1 = ((*p).u.s[5 as libc::c_int as usize] ^ d0) << 36 as libc::c_int
            | ((*p).u.s[5 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 36 as libc::c_int;
        b2 = ((*p).u.s[11 as libc::c_int as usize] ^ d1) << 10 as libc::c_int
            | ((*p).u.s[11 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 10 as libc::c_int;
        b3 = ((*p).u.s[17 as libc::c_int as usize] ^ d2) << 15 as libc::c_int
            | ((*p).u.s[17 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 15 as libc::c_int;
        b4 = ((*p).u.s[23 as libc::c_int as usize] ^ d3) << 56 as libc::c_int
            | ((*p).u.s[23 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 56 as libc::c_int;
        b0 = ((*p).u.s[4 as libc::c_int as usize] ^ d4) << 27 as libc::c_int
            | ((*p).u.s[4 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 27 as libc::c_int;
        (*p).u.s[5 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[11 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[17 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[23 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[4 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b3 = ((*p).u.s[15 as libc::c_int as usize] ^ d0) << 41 as libc::c_int
            | ((*p).u.s[15 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 41 as libc::c_int;
        b4 = ((*p).u.s[21 as libc::c_int as usize] ^ d1) << 2 as libc::c_int
            | ((*p).u.s[21 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 2 as libc::c_int;
        b0 = ((*p).u.s[2 as libc::c_int as usize] ^ d2) << 62 as libc::c_int
            | ((*p).u.s[2 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 62 as libc::c_int;
        b1 = ((*p).u.s[8 as libc::c_int as usize] ^ d3) << 55 as libc::c_int
            | ((*p).u.s[8 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 55 as libc::c_int;
        b2 = ((*p).u.s[14 as libc::c_int as usize] ^ d4) << 39 as libc::c_int
            | ((*p).u.s[14 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 39 as libc::c_int;
        (*p).u.s[15 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[21 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[2 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[8 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[14 as libc::c_int as usize] = b4 ^ !b0 & b1;
        c0 = (*p).u.s[0 as libc::c_int as usize] ^ (*p).u.s[10 as libc::c_int as usize]
            ^ (*p).u.s[20 as libc::c_int as usize] ^ (*p).u.s[5 as libc::c_int as usize]
            ^ (*p).u.s[15 as libc::c_int as usize];
        c1 = (*p).u.s[6 as libc::c_int as usize] ^ (*p).u.s[16 as libc::c_int as usize]
            ^ (*p).u.s[1 as libc::c_int as usize] ^ (*p).u.s[11 as libc::c_int as usize]
            ^ (*p).u.s[21 as libc::c_int as usize];
        c2 = (*p).u.s[12 as libc::c_int as usize] ^ (*p).u.s[22 as libc::c_int as usize]
            ^ (*p).u.s[7 as libc::c_int as usize] ^ (*p).u.s[17 as libc::c_int as usize]
            ^ (*p).u.s[2 as libc::c_int as usize];
        c3 = (*p).u.s[18 as libc::c_int as usize] ^ (*p).u.s[3 as libc::c_int as usize]
            ^ (*p).u.s[13 as libc::c_int as usize] ^ (*p).u.s[23 as libc::c_int as usize]
            ^ (*p).u.s[8 as libc::c_int as usize];
        c4 = (*p).u.s[24 as libc::c_int as usize] ^ (*p).u.s[9 as libc::c_int as usize]
            ^ (*p).u.s[19 as libc::c_int as usize] ^ (*p).u.s[4 as libc::c_int as usize]
            ^ (*p).u.s[14 as libc::c_int as usize];
        d0 = c4 ^ (c1 << 1 as libc::c_int | c1 >> 64 as libc::c_int - 1 as libc::c_int);
        d1 = c0 ^ (c2 << 1 as libc::c_int | c2 >> 64 as libc::c_int - 1 as libc::c_int);
        d2 = c1 ^ (c3 << 1 as libc::c_int | c3 >> 64 as libc::c_int - 1 as libc::c_int);
        d3 = c2 ^ (c4 << 1 as libc::c_int | c4 >> 64 as libc::c_int - 1 as libc::c_int);
        d4 = c3 ^ (c0 << 1 as libc::c_int | c0 >> 64 as libc::c_int - 1 as libc::c_int);
        b0 = (*p).u.s[0 as libc::c_int as usize] ^ d0;
        b1 = ((*p).u.s[16 as libc::c_int as usize] ^ d1) << 44 as libc::c_int
            | ((*p).u.s[16 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 44 as libc::c_int;
        b2 = ((*p).u.s[7 as libc::c_int as usize] ^ d2) << 43 as libc::c_int
            | ((*p).u.s[7 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 43 as libc::c_int;
        b3 = ((*p).u.s[23 as libc::c_int as usize] ^ d3) << 21 as libc::c_int
            | ((*p).u.s[23 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 21 as libc::c_int;
        b4 = ((*p).u.s[14 as libc::c_int as usize] ^ d4) << 14 as libc::c_int
            | ((*p).u.s[14 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 14 as libc::c_int;
        (*p).u.s[0 as libc::c_int as usize] = b0 ^ !b1 & b2;
        let ref mut fresh8 = (*p).u.s[0 as libc::c_int as usize];
        *fresh8 ^= RC[(i + 1 as libc::c_int) as usize];
        (*p).u.s[16 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[7 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[23 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[14 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b2 = ((*p).u.s[20 as libc::c_int as usize] ^ d0) << 3 as libc::c_int
            | ((*p).u.s[20 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 3 as libc::c_int;
        b3 = ((*p).u.s[11 as libc::c_int as usize] ^ d1) << 45 as libc::c_int
            | ((*p).u.s[11 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 45 as libc::c_int;
        b4 = ((*p).u.s[2 as libc::c_int as usize] ^ d2) << 61 as libc::c_int
            | ((*p).u.s[2 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 61 as libc::c_int;
        b0 = ((*p).u.s[18 as libc::c_int as usize] ^ d3) << 28 as libc::c_int
            | ((*p).u.s[18 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 28 as libc::c_int;
        b1 = ((*p).u.s[9 as libc::c_int as usize] ^ d4) << 20 as libc::c_int
            | ((*p).u.s[9 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 20 as libc::c_int;
        (*p).u.s[20 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[11 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[2 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[18 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[9 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b4 = ((*p).u.s[15 as libc::c_int as usize] ^ d0) << 18 as libc::c_int
            | ((*p).u.s[15 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 18 as libc::c_int;
        b0 = ((*p).u.s[6 as libc::c_int as usize] ^ d1) << 1 as libc::c_int
            | ((*p).u.s[6 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 1 as libc::c_int;
        b1 = ((*p).u.s[22 as libc::c_int as usize] ^ d2) << 6 as libc::c_int
            | ((*p).u.s[22 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 6 as libc::c_int;
        b2 = ((*p).u.s[13 as libc::c_int as usize] ^ d3) << 25 as libc::c_int
            | ((*p).u.s[13 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 25 as libc::c_int;
        b3 = ((*p).u.s[4 as libc::c_int as usize] ^ d4) << 8 as libc::c_int
            | ((*p).u.s[4 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 8 as libc::c_int;
        (*p).u.s[15 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[6 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[22 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[13 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[4 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b1 = ((*p).u.s[10 as libc::c_int as usize] ^ d0) << 36 as libc::c_int
            | ((*p).u.s[10 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 36 as libc::c_int;
        b2 = ((*p).u.s[1 as libc::c_int as usize] ^ d1) << 10 as libc::c_int
            | ((*p).u.s[1 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 10 as libc::c_int;
        b3 = ((*p).u.s[17 as libc::c_int as usize] ^ d2) << 15 as libc::c_int
            | ((*p).u.s[17 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 15 as libc::c_int;
        b4 = ((*p).u.s[8 as libc::c_int as usize] ^ d3) << 56 as libc::c_int
            | ((*p).u.s[8 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 56 as libc::c_int;
        b0 = ((*p).u.s[24 as libc::c_int as usize] ^ d4) << 27 as libc::c_int
            | ((*p).u.s[24 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 27 as libc::c_int;
        (*p).u.s[10 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[1 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[17 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[8 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[24 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b3 = ((*p).u.s[5 as libc::c_int as usize] ^ d0) << 41 as libc::c_int
            | ((*p).u.s[5 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 41 as libc::c_int;
        b4 = ((*p).u.s[21 as libc::c_int as usize] ^ d1) << 2 as libc::c_int
            | ((*p).u.s[21 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 2 as libc::c_int;
        b0 = ((*p).u.s[12 as libc::c_int as usize] ^ d2) << 62 as libc::c_int
            | ((*p).u.s[12 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 62 as libc::c_int;
        b1 = ((*p).u.s[3 as libc::c_int as usize] ^ d3) << 55 as libc::c_int
            | ((*p).u.s[3 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 55 as libc::c_int;
        b2 = ((*p).u.s[19 as libc::c_int as usize] ^ d4) << 39 as libc::c_int
            | ((*p).u.s[19 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 39 as libc::c_int;
        (*p).u.s[5 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[21 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[12 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[3 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[19 as libc::c_int as usize] = b4 ^ !b0 & b1;
        c0 = (*p).u.s[0 as libc::c_int as usize] ^ (*p).u.s[20 as libc::c_int as usize]
            ^ (*p).u.s[15 as libc::c_int as usize] ^ (*p).u.s[10 as libc::c_int as usize]
            ^ (*p).u.s[5 as libc::c_int as usize];
        c1 = (*p).u.s[16 as libc::c_int as usize] ^ (*p).u.s[11 as libc::c_int as usize]
            ^ (*p).u.s[6 as libc::c_int as usize] ^ (*p).u.s[1 as libc::c_int as usize]
            ^ (*p).u.s[21 as libc::c_int as usize];
        c2 = (*p).u.s[7 as libc::c_int as usize] ^ (*p).u.s[2 as libc::c_int as usize]
            ^ (*p).u.s[22 as libc::c_int as usize] ^ (*p).u.s[17 as libc::c_int as usize]
            ^ (*p).u.s[12 as libc::c_int as usize];
        c3 = (*p).u.s[23 as libc::c_int as usize] ^ (*p).u.s[18 as libc::c_int as usize]
            ^ (*p).u.s[13 as libc::c_int as usize] ^ (*p).u.s[8 as libc::c_int as usize]
            ^ (*p).u.s[3 as libc::c_int as usize];
        c4 = (*p).u.s[14 as libc::c_int as usize] ^ (*p).u.s[9 as libc::c_int as usize]
            ^ (*p).u.s[4 as libc::c_int as usize] ^ (*p).u.s[24 as libc::c_int as usize]
            ^ (*p).u.s[19 as libc::c_int as usize];
        d0 = c4 ^ (c1 << 1 as libc::c_int | c1 >> 64 as libc::c_int - 1 as libc::c_int);
        d1 = c0 ^ (c2 << 1 as libc::c_int | c2 >> 64 as libc::c_int - 1 as libc::c_int);
        d2 = c1 ^ (c3 << 1 as libc::c_int | c3 >> 64 as libc::c_int - 1 as libc::c_int);
        d3 = c2 ^ (c4 << 1 as libc::c_int | c4 >> 64 as libc::c_int - 1 as libc::c_int);
        d4 = c3 ^ (c0 << 1 as libc::c_int | c0 >> 64 as libc::c_int - 1 as libc::c_int);
        b0 = (*p).u.s[0 as libc::c_int as usize] ^ d0;
        b1 = ((*p).u.s[11 as libc::c_int as usize] ^ d1) << 44 as libc::c_int
            | ((*p).u.s[11 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 44 as libc::c_int;
        b2 = ((*p).u.s[22 as libc::c_int as usize] ^ d2) << 43 as libc::c_int
            | ((*p).u.s[22 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 43 as libc::c_int;
        b3 = ((*p).u.s[8 as libc::c_int as usize] ^ d3) << 21 as libc::c_int
            | ((*p).u.s[8 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 21 as libc::c_int;
        b4 = ((*p).u.s[19 as libc::c_int as usize] ^ d4) << 14 as libc::c_int
            | ((*p).u.s[19 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 14 as libc::c_int;
        (*p).u.s[0 as libc::c_int as usize] = b0 ^ !b1 & b2;
        let ref mut fresh9 = (*p).u.s[0 as libc::c_int as usize];
        *fresh9 ^= RC[(i + 2 as libc::c_int) as usize];
        (*p).u.s[11 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[22 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[8 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[19 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b2 = ((*p).u.s[15 as libc::c_int as usize] ^ d0) << 3 as libc::c_int
            | ((*p).u.s[15 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 3 as libc::c_int;
        b3 = ((*p).u.s[1 as libc::c_int as usize] ^ d1) << 45 as libc::c_int
            | ((*p).u.s[1 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 45 as libc::c_int;
        b4 = ((*p).u.s[12 as libc::c_int as usize] ^ d2) << 61 as libc::c_int
            | ((*p).u.s[12 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 61 as libc::c_int;
        b0 = ((*p).u.s[23 as libc::c_int as usize] ^ d3) << 28 as libc::c_int
            | ((*p).u.s[23 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 28 as libc::c_int;
        b1 = ((*p).u.s[9 as libc::c_int as usize] ^ d4) << 20 as libc::c_int
            | ((*p).u.s[9 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 20 as libc::c_int;
        (*p).u.s[15 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[1 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[12 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[23 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[9 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b4 = ((*p).u.s[5 as libc::c_int as usize] ^ d0) << 18 as libc::c_int
            | ((*p).u.s[5 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 18 as libc::c_int;
        b0 = ((*p).u.s[16 as libc::c_int as usize] ^ d1) << 1 as libc::c_int
            | ((*p).u.s[16 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 1 as libc::c_int;
        b1 = ((*p).u.s[2 as libc::c_int as usize] ^ d2) << 6 as libc::c_int
            | ((*p).u.s[2 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 6 as libc::c_int;
        b2 = ((*p).u.s[13 as libc::c_int as usize] ^ d3) << 25 as libc::c_int
            | ((*p).u.s[13 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 25 as libc::c_int;
        b3 = ((*p).u.s[24 as libc::c_int as usize] ^ d4) << 8 as libc::c_int
            | ((*p).u.s[24 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 8 as libc::c_int;
        (*p).u.s[5 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[16 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[2 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[13 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[24 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b1 = ((*p).u.s[20 as libc::c_int as usize] ^ d0) << 36 as libc::c_int
            | ((*p).u.s[20 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 36 as libc::c_int;
        b2 = ((*p).u.s[6 as libc::c_int as usize] ^ d1) << 10 as libc::c_int
            | ((*p).u.s[6 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 10 as libc::c_int;
        b3 = ((*p).u.s[17 as libc::c_int as usize] ^ d2) << 15 as libc::c_int
            | ((*p).u.s[17 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 15 as libc::c_int;
        b4 = ((*p).u.s[3 as libc::c_int as usize] ^ d3) << 56 as libc::c_int
            | ((*p).u.s[3 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 56 as libc::c_int;
        b0 = ((*p).u.s[14 as libc::c_int as usize] ^ d4) << 27 as libc::c_int
            | ((*p).u.s[14 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 27 as libc::c_int;
        (*p).u.s[20 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[6 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[17 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[3 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[14 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b3 = ((*p).u.s[10 as libc::c_int as usize] ^ d0) << 41 as libc::c_int
            | ((*p).u.s[10 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 41 as libc::c_int;
        b4 = ((*p).u.s[21 as libc::c_int as usize] ^ d1) << 2 as libc::c_int
            | ((*p).u.s[21 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 2 as libc::c_int;
        b0 = ((*p).u.s[7 as libc::c_int as usize] ^ d2) << 62 as libc::c_int
            | ((*p).u.s[7 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 62 as libc::c_int;
        b1 = ((*p).u.s[18 as libc::c_int as usize] ^ d3) << 55 as libc::c_int
            | ((*p).u.s[18 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 55 as libc::c_int;
        b2 = ((*p).u.s[4 as libc::c_int as usize] ^ d4) << 39 as libc::c_int
            | ((*p).u.s[4 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 39 as libc::c_int;
        (*p).u.s[10 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[21 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[7 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[18 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[4 as libc::c_int as usize] = b4 ^ !b0 & b1;
        c0 = (*p).u.s[0 as libc::c_int as usize] ^ (*p).u.s[15 as libc::c_int as usize]
            ^ (*p).u.s[5 as libc::c_int as usize] ^ (*p).u.s[20 as libc::c_int as usize]
            ^ (*p).u.s[10 as libc::c_int as usize];
        c1 = (*p).u.s[11 as libc::c_int as usize] ^ (*p).u.s[1 as libc::c_int as usize]
            ^ (*p).u.s[16 as libc::c_int as usize] ^ (*p).u.s[6 as libc::c_int as usize]
            ^ (*p).u.s[21 as libc::c_int as usize];
        c2 = (*p).u.s[22 as libc::c_int as usize] ^ (*p).u.s[12 as libc::c_int as usize]
            ^ (*p).u.s[2 as libc::c_int as usize] ^ (*p).u.s[17 as libc::c_int as usize]
            ^ (*p).u.s[7 as libc::c_int as usize];
        c3 = (*p).u.s[8 as libc::c_int as usize] ^ (*p).u.s[23 as libc::c_int as usize]
            ^ (*p).u.s[13 as libc::c_int as usize] ^ (*p).u.s[3 as libc::c_int as usize]
            ^ (*p).u.s[18 as libc::c_int as usize];
        c4 = (*p).u.s[19 as libc::c_int as usize] ^ (*p).u.s[9 as libc::c_int as usize]
            ^ (*p).u.s[24 as libc::c_int as usize] ^ (*p).u.s[14 as libc::c_int as usize]
            ^ (*p).u.s[4 as libc::c_int as usize];
        d0 = c4 ^ (c1 << 1 as libc::c_int | c1 >> 64 as libc::c_int - 1 as libc::c_int);
        d1 = c0 ^ (c2 << 1 as libc::c_int | c2 >> 64 as libc::c_int - 1 as libc::c_int);
        d2 = c1 ^ (c3 << 1 as libc::c_int | c3 >> 64 as libc::c_int - 1 as libc::c_int);
        d3 = c2 ^ (c4 << 1 as libc::c_int | c4 >> 64 as libc::c_int - 1 as libc::c_int);
        d4 = c3 ^ (c0 << 1 as libc::c_int | c0 >> 64 as libc::c_int - 1 as libc::c_int);
        b0 = (*p).u.s[0 as libc::c_int as usize] ^ d0;
        b1 = ((*p).u.s[1 as libc::c_int as usize] ^ d1) << 44 as libc::c_int
            | ((*p).u.s[1 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 44 as libc::c_int;
        b2 = ((*p).u.s[2 as libc::c_int as usize] ^ d2) << 43 as libc::c_int
            | ((*p).u.s[2 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 43 as libc::c_int;
        b3 = ((*p).u.s[3 as libc::c_int as usize] ^ d3) << 21 as libc::c_int
            | ((*p).u.s[3 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 21 as libc::c_int;
        b4 = ((*p).u.s[4 as libc::c_int as usize] ^ d4) << 14 as libc::c_int
            | ((*p).u.s[4 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 14 as libc::c_int;
        (*p).u.s[0 as libc::c_int as usize] = b0 ^ !b1 & b2;
        let ref mut fresh10 = (*p).u.s[0 as libc::c_int as usize];
        *fresh10 ^= RC[(i + 3 as libc::c_int) as usize];
        (*p).u.s[1 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[2 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[3 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[4 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b2 = ((*p).u.s[5 as libc::c_int as usize] ^ d0) << 3 as libc::c_int
            | ((*p).u.s[5 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 3 as libc::c_int;
        b3 = ((*p).u.s[6 as libc::c_int as usize] ^ d1) << 45 as libc::c_int
            | ((*p).u.s[6 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 45 as libc::c_int;
        b4 = ((*p).u.s[7 as libc::c_int as usize] ^ d2) << 61 as libc::c_int
            | ((*p).u.s[7 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 61 as libc::c_int;
        b0 = ((*p).u.s[8 as libc::c_int as usize] ^ d3) << 28 as libc::c_int
            | ((*p).u.s[8 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 28 as libc::c_int;
        b1 = ((*p).u.s[9 as libc::c_int as usize] ^ d4) << 20 as libc::c_int
            | ((*p).u.s[9 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 20 as libc::c_int;
        (*p).u.s[5 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[6 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[7 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[8 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[9 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b4 = ((*p).u.s[10 as libc::c_int as usize] ^ d0) << 18 as libc::c_int
            | ((*p).u.s[10 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 18 as libc::c_int;
        b0 = ((*p).u.s[11 as libc::c_int as usize] ^ d1) << 1 as libc::c_int
            | ((*p).u.s[11 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 1 as libc::c_int;
        b1 = ((*p).u.s[12 as libc::c_int as usize] ^ d2) << 6 as libc::c_int
            | ((*p).u.s[12 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 6 as libc::c_int;
        b2 = ((*p).u.s[13 as libc::c_int as usize] ^ d3) << 25 as libc::c_int
            | ((*p).u.s[13 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 25 as libc::c_int;
        b3 = ((*p).u.s[14 as libc::c_int as usize] ^ d4) << 8 as libc::c_int
            | ((*p).u.s[14 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 8 as libc::c_int;
        (*p).u.s[10 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[11 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[12 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[13 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[14 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b1 = ((*p).u.s[15 as libc::c_int as usize] ^ d0) << 36 as libc::c_int
            | ((*p).u.s[15 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 36 as libc::c_int;
        b2 = ((*p).u.s[16 as libc::c_int as usize] ^ d1) << 10 as libc::c_int
            | ((*p).u.s[16 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 10 as libc::c_int;
        b3 = ((*p).u.s[17 as libc::c_int as usize] ^ d2) << 15 as libc::c_int
            | ((*p).u.s[17 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 15 as libc::c_int;
        b4 = ((*p).u.s[18 as libc::c_int as usize] ^ d3) << 56 as libc::c_int
            | ((*p).u.s[18 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 56 as libc::c_int;
        b0 = ((*p).u.s[19 as libc::c_int as usize] ^ d4) << 27 as libc::c_int
            | ((*p).u.s[19 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 27 as libc::c_int;
        (*p).u.s[15 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[16 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[17 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[18 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[19 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b3 = ((*p).u.s[20 as libc::c_int as usize] ^ d0) << 41 as libc::c_int
            | ((*p).u.s[20 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 41 as libc::c_int;
        b4 = ((*p).u.s[21 as libc::c_int as usize] ^ d1) << 2 as libc::c_int
            | ((*p).u.s[21 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 2 as libc::c_int;
        b0 = ((*p).u.s[22 as libc::c_int as usize] ^ d2) << 62 as libc::c_int
            | ((*p).u.s[22 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 62 as libc::c_int;
        b1 = ((*p).u.s[23 as libc::c_int as usize] ^ d3) << 55 as libc::c_int
            | ((*p).u.s[23 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 55 as libc::c_int;
        b2 = ((*p).u.s[24 as libc::c_int as usize] ^ d4) << 39 as libc::c_int
            | ((*p).u.s[24 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 39 as libc::c_int;
        (*p).u.s[20 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[21 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[22 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[23 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[24 as libc::c_int as usize] = b4 ^ !b0 & b1;
        i += 4 as libc::c_int;
    }
}
unsafe extern "C" fn SHA3Init(mut p: *mut SHA3Context, mut iSize: libc::c_int) {
    memset(
        p as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<SHA3Context>() as libc::c_ulong,
    );
    if iSize >= 128 as libc::c_int && iSize <= 512 as libc::c_int {
        (*p)
            .nRate = ((1600 as libc::c_int
            - (iSize + 31 as libc::c_int & !(31 as libc::c_int)) * 2 as libc::c_int)
            / 8 as libc::c_int) as libc::c_uint;
    } else {
        (*p)
            .nRate = ((1600 as libc::c_int - 2 as libc::c_int * 256 as libc::c_int)
            / 8 as libc::c_int) as libc::c_uint;
    };
}
unsafe extern "C" fn SHA3Update(
    mut p: *mut SHA3Context,
    mut aData: *const libc::c_uchar,
    mut nData: libc::c_uint,
) {
    let mut i: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    if aData.is_null() {
        return;
    }
    if ((*p).nLoaded).wrapping_rem(8 as libc::c_int as libc::c_uint)
        == 0 as libc::c_int as libc::c_uint
        && aData.offset_from(0 as *const libc::c_uchar) as libc::c_long
            & 7 as libc::c_int as libc::c_long == 0 as libc::c_int as libc::c_long
    {
        while i.wrapping_add(7 as libc::c_int as libc::c_uint) < nData {
            let ref mut fresh11 = (*p)
                .u
                .s[((*p).nLoaded).wrapping_div(8 as libc::c_int as libc::c_uint)
                as usize];
            *fresh11
                ^= *(&*aData.offset(i as isize) as *const libc::c_uchar as *mut u64_0);
            let ref mut fresh12 = (*p).nLoaded;
            *fresh12 = (*fresh12).wrapping_add(8 as libc::c_int as libc::c_uint);
            if (*p).nLoaded >= (*p).nRate {
                KeccakF1600Step(p);
                (*p).nLoaded = 0 as libc::c_int as libc::c_uint;
            }
            i = i.wrapping_add(8 as libc::c_int as libc::c_uint);
        }
    }
    while i < nData {
        let ref mut fresh13 = (*p).u.x[(*p).nLoaded as usize];
        *fresh13 = (*fresh13 as libc::c_int ^ *aData.offset(i as isize) as libc::c_int)
            as libc::c_uchar;
        let ref mut fresh14 = (*p).nLoaded;
        *fresh14 = (*fresh14).wrapping_add(1);
        if (*p).nLoaded == (*p).nRate {
            KeccakF1600Step(p);
            (*p).nLoaded = 0 as libc::c_int as libc::c_uint;
        }
        i = i.wrapping_add(1);
    }
}
unsafe extern "C" fn SHA3Final(mut p: *mut SHA3Context) -> *mut libc::c_uchar {
    let mut i: libc::c_uint = 0;
    if (*p).nLoaded == ((*p).nRate).wrapping_sub(1 as libc::c_int as libc::c_uint) {
        let c1: libc::c_uchar = 0x86 as libc::c_int as libc::c_uchar;
        SHA3Update(p, &c1, 1 as libc::c_int as libc::c_uint);
    } else {
        let c2: libc::c_uchar = 0x6 as libc::c_int as libc::c_uchar;
        let c3: libc::c_uchar = 0x80 as libc::c_int as libc::c_uchar;
        SHA3Update(p, &c2, 1 as libc::c_int as libc::c_uint);
        (*p).nLoaded = ((*p).nRate).wrapping_sub(1 as libc::c_int as libc::c_uint);
        SHA3Update(p, &c3, 1 as libc::c_int as libc::c_uint);
    }
    i = 0 as libc::c_int as libc::c_uint;
    while i < (*p).nRate {
        (*p)
            .u
            .x[i.wrapping_add((*p).nRate)
            as usize] = (*p).u.x[(i ^ (*p).ixMask) as usize];
        i = i.wrapping_add(1);
    }
    return &mut *((*p).u.x).as_mut_ptr().offset((*p).nRate as isize)
        as *mut libc::c_uchar;
}
unsafe extern "C" fn sha3Func(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut cx: SHA3Context = SHA3Context {
        u: C2RustUnnamed_15 { s: [0; 25] },
        nRate: 0,
        nLoaded: 0,
        ixMask: 0,
    };
    let mut eType: libc::c_int = sqlite3_value_type(
        *argv.offset(0 as libc::c_int as isize),
    );
    let mut nByte: libc::c_int = sqlite3_value_bytes(
        *argv.offset(0 as libc::c_int as isize),
    );
    let mut iSize: libc::c_int = 0;
    if argc == 1 as libc::c_int {
        iSize = 256 as libc::c_int;
    } else {
        iSize = sqlite3_value_int(*argv.offset(1 as libc::c_int as isize));
        if iSize != 224 as libc::c_int && iSize != 256 as libc::c_int
            && iSize != 384 as libc::c_int && iSize != 512 as libc::c_int
        {
            sqlite3_result_error(
                context,
                b"SHA3 size should be one of: 224 256 384 512\0" as *const u8
                    as *const libc::c_char,
                -(1 as libc::c_int),
            );
            return;
        }
    }
    if eType == 5 as libc::c_int {
        return;
    }
    SHA3Init(&mut cx, iSize);
    if eType == 4 as libc::c_int {
        SHA3Update(
            &mut cx,
            sqlite3_value_blob(*argv.offset(0 as libc::c_int as isize))
                as *const libc::c_uchar,
            nByte as libc::c_uint,
        );
    } else {
        SHA3Update(
            &mut cx,
            sqlite3_value_text(*argv.offset(0 as libc::c_int as isize)),
            nByte as libc::c_uint,
        );
    }
    sqlite3_result_blob(
        context,
        SHA3Final(&mut cx) as *const libc::c_void,
        iSize / 8 as libc::c_int,
        ::std::mem::transmute::<
            libc::intptr_t,
            sqlite3_destructor_type,
        >(-(1 as libc::c_int) as libc::intptr_t),
    );
}
unsafe extern "C" fn sha3_step_vformat(
    mut p: *mut SHA3Context,
    mut zFormat: *const libc::c_char,
    mut args: ...
) {
    let mut ap: ::std::ffi::VaListImpl;
    let mut n: libc::c_int = 0;
    let mut zBuf: [libc::c_char; 50] = [0; 50];
    ap = args.clone();
    sqlite3_vsnprintf(
        ::std::mem::size_of::<[libc::c_char; 50]>() as libc::c_ulong as libc::c_int,
        zBuf.as_mut_ptr(),
        zFormat,
        ap.as_va_list(),
    );
    n = strlen(zBuf.as_mut_ptr()) as libc::c_int;
    SHA3Update(p, zBuf.as_mut_ptr() as *mut libc::c_uchar, n as libc::c_uint);
}
unsafe extern "C" fn sha3QueryFunc(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut db: *mut sqlite3 = sqlite3_context_db_handle(context);
    let mut zSql: *const libc::c_char = sqlite3_value_text(
        *argv.offset(0 as libc::c_int as isize),
    ) as *const libc::c_char;
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut nCol: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut z: *const libc::c_char = 0 as *const libc::c_char;
    let mut cx: SHA3Context = SHA3Context {
        u: C2RustUnnamed_15 { s: [0; 25] },
        nRate: 0,
        nLoaded: 0,
        ixMask: 0,
    };
    let mut iSize: libc::c_int = 0;
    if argc == 1 as libc::c_int {
        iSize = 256 as libc::c_int;
    } else {
        iSize = sqlite3_value_int(*argv.offset(1 as libc::c_int as isize));
        if iSize != 224 as libc::c_int && iSize != 256 as libc::c_int
            && iSize != 384 as libc::c_int && iSize != 512 as libc::c_int
        {
            sqlite3_result_error(
                context,
                b"SHA3 size should be one of: 224 256 384 512\0" as *const u8
                    as *const libc::c_char,
                -(1 as libc::c_int),
            );
            return;
        }
    }
    if zSql.is_null() {
        return;
    }
    SHA3Init(&mut cx, iSize);
    while *zSql.offset(0 as libc::c_int as isize) != 0 {
        rc = sqlite3_prepare_v2(db, zSql, -(1 as libc::c_int), &mut pStmt, &mut zSql);
        if rc != 0 {
            let mut zMsg: *mut libc::c_char = sqlite3_mprintf(
                b"error SQL statement [%s]: %s\0" as *const u8 as *const libc::c_char,
                zSql,
                sqlite3_errmsg(db),
            );
            sqlite3_finalize(pStmt);
            sqlite3_result_error(context, zMsg, -(1 as libc::c_int));
            sqlite3_free(zMsg as *mut libc::c_void);
            return;
        }
        if sqlite3_stmt_readonly(pStmt) == 0 {
            let mut zMsg_0: *mut libc::c_char = sqlite3_mprintf(
                b"non-query: [%s]\0" as *const u8 as *const libc::c_char,
                sqlite3_sql(pStmt),
            );
            sqlite3_finalize(pStmt);
            sqlite3_result_error(context, zMsg_0, -(1 as libc::c_int));
            sqlite3_free(zMsg_0 as *mut libc::c_void);
            return;
        }
        nCol = sqlite3_column_count(pStmt);
        z = sqlite3_sql(pStmt);
        if !z.is_null() {
            n = strlen(z) as libc::c_int;
            sha3_step_vformat(
                &mut cx as *mut SHA3Context,
                b"S%d:\0" as *const u8 as *const libc::c_char,
                n,
            );
            SHA3Update(&mut cx, z as *mut libc::c_uchar, n as libc::c_uint);
        }
        while 100 as libc::c_int == sqlite3_step(pStmt) {
            SHA3Update(
                &mut cx,
                b"R\0" as *const u8 as *const libc::c_char as *const libc::c_uchar,
                1 as libc::c_int as libc::c_uint,
            );
            i = 0 as libc::c_int;
            while i < nCol {
                match sqlite3_column_type(pStmt, i) {
                    5 => {
                        SHA3Update(
                            &mut cx,
                            b"N\0" as *const u8 as *const libc::c_char
                                as *const libc::c_uchar,
                            1 as libc::c_int as libc::c_uint,
                        );
                    }
                    1 => {
                        let mut u: sqlite3_uint64 = 0;
                        let mut j: libc::c_int = 0;
                        let mut x: [libc::c_uchar; 9] = [0; 9];
                        let mut v: sqlite3_int64 = sqlite3_column_int64(pStmt, i);
                        memcpy(
                            &mut u as *mut sqlite3_uint64 as *mut libc::c_void,
                            &mut v as *mut sqlite3_int64 as *const libc::c_void,
                            8 as libc::c_int as libc::c_ulong,
                        );
                        j = 8 as libc::c_int;
                        while j >= 1 as libc::c_int {
                            x[j
                                as usize] = (u & 0xff as libc::c_int as libc::c_ulonglong)
                                as libc::c_uchar;
                            u >>= 8 as libc::c_int;
                            j -= 1;
                        }
                        x[0 as libc::c_int as usize] = 'I' as i32 as libc::c_uchar;
                        SHA3Update(
                            &mut cx,
                            x.as_mut_ptr(),
                            9 as libc::c_int as libc::c_uint,
                        );
                    }
                    2 => {
                        let mut u_0: sqlite3_uint64 = 0;
                        let mut j_0: libc::c_int = 0;
                        let mut x_0: [libc::c_uchar; 9] = [0; 9];
                        let mut r: libc::c_double = sqlite3_column_double(pStmt, i);
                        memcpy(
                            &mut u_0 as *mut sqlite3_uint64 as *mut libc::c_void,
                            &mut r as *mut libc::c_double as *const libc::c_void,
                            8 as libc::c_int as libc::c_ulong,
                        );
                        j_0 = 8 as libc::c_int;
                        while j_0 >= 1 as libc::c_int {
                            x_0[j_0
                                as usize] = (u_0 & 0xff as libc::c_int as libc::c_ulonglong)
                                as libc::c_uchar;
                            u_0 >>= 8 as libc::c_int;
                            j_0 -= 1;
                        }
                        x_0[0 as libc::c_int as usize] = 'F' as i32 as libc::c_uchar;
                        SHA3Update(
                            &mut cx,
                            x_0.as_mut_ptr(),
                            9 as libc::c_int as libc::c_uint,
                        );
                    }
                    3 => {
                        let mut n2: libc::c_int = sqlite3_column_bytes(pStmt, i);
                        let mut z2: *const libc::c_uchar = sqlite3_column_text(pStmt, i);
                        sha3_step_vformat(
                            &mut cx as *mut SHA3Context,
                            b"T%d:\0" as *const u8 as *const libc::c_char,
                            n2,
                        );
                        SHA3Update(&mut cx, z2, n2 as libc::c_uint);
                    }
                    4 => {
                        let mut n2_0: libc::c_int = sqlite3_column_bytes(pStmt, i);
                        let mut z2_0: *const libc::c_uchar = sqlite3_column_blob(
                            pStmt,
                            i,
                        ) as *const libc::c_uchar;
                        sha3_step_vformat(
                            &mut cx as *mut SHA3Context,
                            b"B%d:\0" as *const u8 as *const libc::c_char,
                            n2_0,
                        );
                        SHA3Update(&mut cx, z2_0, n2_0 as libc::c_uint);
                    }
                    _ => {}
                }
                i += 1;
            }
        }
        sqlite3_finalize(pStmt);
    }
    sqlite3_result_blob(
        context,
        SHA3Final(&mut cx) as *const libc::c_void,
        iSize / 8 as libc::c_int,
        ::std::mem::transmute::<
            libc::intptr_t,
            sqlite3_destructor_type,
        >(-(1 as libc::c_int) as libc::intptr_t),
    );
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_shathree_init(
    mut db: *mut sqlite3,
    mut pzErrMsg: *mut *mut libc::c_char,
    mut pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    rc = sqlite3_create_function(
        db,
        b"sha3\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
        1 as libc::c_int | 0x200000 as libc::c_int | 0x800 as libc::c_int,
        0 as *mut libc::c_void,
        Some(
            sha3Func
                as unsafe extern "C" fn(
                    *mut sqlite3_context,
                    libc::c_int,
                    *mut *mut sqlite3_value,
                ) -> (),
        ),
        None,
        None,
    );
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_function(
            db,
            b"sha3\0" as *const u8 as *const libc::c_char,
            2 as libc::c_int,
            1 as libc::c_int | 0x200000 as libc::c_int | 0x800 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                sha3Func
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
    }
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_function(
            db,
            b"sha3_query\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            1 as libc::c_int | 0x80000 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                sha3QueryFunc
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
    }
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_function(
            db,
            b"sha3_query\0" as *const u8 as *const libc::c_char,
            2 as libc::c_int,
            1 as libc::c_int | 0x80000 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                sha3QueryFunc
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
    }
    return rc;
}
unsafe extern "C" fn uintCollFunc(
    mut notUsed: *mut libc::c_void,
    mut nKey1: libc::c_int,
    mut pKey1: *const libc::c_void,
    mut nKey2: libc::c_int,
    mut pKey2: *const libc::c_void,
) -> libc::c_int {
    let mut zA: *const libc::c_uchar = pKey1 as *const libc::c_uchar;
    let mut zB: *const libc::c_uchar = pKey2 as *const libc::c_uchar;
    let mut i: libc::c_int = 0 as libc::c_int;
    let mut j: libc::c_int = 0 as libc::c_int;
    let mut x: libc::c_int = 0;
    while i < nKey1 && j < nKey2 {
        x = *zA.offset(i as isize) as libc::c_int
            - *zB.offset(j as isize) as libc::c_int;
        if *(*__ctype_b_loc()).offset(*zA.offset(i as isize) as libc::c_int as isize)
            as libc::c_int & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
            != 0
        {
            let mut k: libc::c_int = 0;
            if *(*__ctype_b_loc()).offset(*zB.offset(j as isize) as libc::c_int as isize)
                as libc::c_int & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
                == 0
            {
                return x;
            }
            while i < nKey1 && *zA.offset(i as isize) as libc::c_int == '0' as i32 {
                i += 1;
            }
            while j < nKey2 && *zB.offset(j as isize) as libc::c_int == '0' as i32 {
                j += 1;
            }
            k = 0 as libc::c_int;
            while i + k < nKey1
                && *(*__ctype_b_loc())
                    .offset(*zA.offset((i + k) as isize) as libc::c_int as isize)
                    as libc::c_int
                    & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int != 0
                && j + k < nKey2
                && *(*__ctype_b_loc())
                    .offset(*zB.offset((j + k) as isize) as libc::c_int as isize)
                    as libc::c_int
                    & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int != 0
            {
                k += 1;
            }
            if i + k < nKey1
                && *(*__ctype_b_loc())
                    .offset(*zA.offset((i + k) as isize) as libc::c_int as isize)
                    as libc::c_int
                    & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int != 0
            {
                return 1 as libc::c_int
            } else {
                if j + k < nKey2
                    && *(*__ctype_b_loc())
                        .offset(*zB.offset((j + k) as isize) as libc::c_int as isize)
                        as libc::c_int
                        & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int != 0
                {
                    return -(1 as libc::c_int)
                } else {
                    x = memcmp(
                        zA.offset(i as isize) as *const libc::c_void,
                        zB.offset(j as isize) as *const libc::c_void,
                        k as libc::c_ulong,
                    );
                    if x != 0 {
                        return x;
                    }
                    i += k;
                    j += k;
                }
            }
        } else if x != 0 {
            return x
        } else {
            i += 1;
            j += 1;
        }
    }
    return nKey1 - i - (nKey2 - j);
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_uint_init(
    mut db: *mut sqlite3,
    mut pzErrMsg: *mut *mut libc::c_char,
    mut pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    return sqlite3_create_collation(
        db,
        b"uint\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
        0 as *mut libc::c_void,
        Some(
            uintCollFunc
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    libc::c_int,
                    *const libc::c_void,
                    libc::c_int,
                    *const libc::c_void,
                ) -> libc::c_int,
        ),
    );
}
unsafe extern "C" fn decimal_clear(mut p: *mut Decimal) {
    sqlite3_free((*p).a as *mut libc::c_void);
}
unsafe extern "C" fn decimal_free(mut p: *mut Decimal) {
    if !p.is_null() {
        decimal_clear(p);
        sqlite3_free(p as *mut libc::c_void);
    }
}
unsafe extern "C" fn decimal_new(
    mut pCtx: *mut sqlite3_context,
    mut pIn: *mut sqlite3_value,
    mut nAlt: libc::c_int,
    mut zAlt: *const libc::c_uchar,
) -> *mut Decimal {
    let mut current_block: u64;
    let mut p: *mut Decimal = 0 as *mut Decimal;
    let mut n: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut zIn: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut iExp: libc::c_int = 0 as libc::c_int;
    p = sqlite3_malloc(::std::mem::size_of::<Decimal>() as libc::c_ulong as libc::c_int)
        as *mut Decimal;
    if !p.is_null() {
        (*p).sign = 0 as libc::c_int as libc::c_char;
        (*p).oom = 0 as libc::c_int as libc::c_char;
        (*p).isInit = 1 as libc::c_int as libc::c_char;
        (*p).isNull = 0 as libc::c_int as libc::c_char;
        (*p).nDigit = 0 as libc::c_int;
        (*p).nFrac = 0 as libc::c_int;
        if !zAlt.is_null() {
            n = nAlt;
            zIn = zAlt;
        } else {
            if sqlite3_value_type(pIn) == 5 as libc::c_int {
                let ref mut fresh15 = (*p).a;
                *fresh15 = 0 as *mut libc::c_schar;
                (*p).isNull = 1 as libc::c_int as libc::c_char;
                return p;
            }
            n = sqlite3_value_bytes(pIn);
            zIn = sqlite3_value_text(pIn);
        }
        let ref mut fresh16 = (*p).a;
        *fresh16 = sqlite3_malloc64((n + 1 as libc::c_int) as sqlite3_uint64)
            as *mut libc::c_schar;
        if !((*p).a).is_null() {
            i = 0 as libc::c_int;
            while *(*__ctype_b_loc())
                .offset(*zIn.offset(i as isize) as libc::c_int as isize) as libc::c_int
                & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0
            {
                i += 1;
            }
            if *zIn.offset(i as isize) as libc::c_int == '-' as i32 {
                (*p).sign = 1 as libc::c_int as libc::c_char;
                i += 1;
            } else if *zIn.offset(i as isize) as libc::c_int == '+' as i32 {
                i += 1;
            }
            while i < n && *zIn.offset(i as isize) as libc::c_int == '0' as i32 {
                i += 1;
            }
            while i < n {
                let mut c: libc::c_char = *zIn.offset(i as isize) as libc::c_char;
                if c as libc::c_int >= '0' as i32 && c as libc::c_int <= '9' as i32 {
                    let ref mut fresh17 = (*p).nDigit;
                    let fresh18 = *fresh17;
                    *fresh17 = *fresh17 + 1;
                    *((*p).a)
                        .offset(
                            fresh18 as isize,
                        ) = (c as libc::c_int - '0' as i32) as libc::c_schar;
                } else if c as libc::c_int == '.' as i32 {
                    (*p).nFrac = (*p).nDigit + 1 as libc::c_int;
                } else if c as libc::c_int == 'e' as i32
                    || c as libc::c_int == 'E' as i32
                {
                    let mut j: libc::c_int = i + 1 as libc::c_int;
                    let mut neg: libc::c_int = 0 as libc::c_int;
                    if j >= n {
                        break;
                    }
                    if *zIn.offset(j as isize) as libc::c_int == '-' as i32 {
                        neg = 1 as libc::c_int;
                        j += 1;
                    } else if *zIn.offset(j as isize) as libc::c_int == '+' as i32 {
                        j += 1;
                    }
                    while j < n && iExp < 1000000 as libc::c_int {
                        if *zIn.offset(j as isize) as libc::c_int >= '0' as i32
                            && *zIn.offset(j as isize) as libc::c_int <= '9' as i32
                        {
                            iExp = iExp * 10 as libc::c_int
                                + *zIn.offset(j as isize) as libc::c_int - '0' as i32;
                        }
                        j += 1;
                    }
                    if neg != 0 {
                        iExp = -iExp;
                    }
                    break;
                }
                i += 1;
            }
            if (*p).nFrac != 0 {
                (*p).nFrac = (*p).nDigit - ((*p).nFrac - 1 as libc::c_int);
            }
            if iExp > 0 as libc::c_int {
                if (*p).nFrac > 0 as libc::c_int {
                    if iExp <= (*p).nFrac {
                        (*p).nFrac -= iExp;
                        iExp = 0 as libc::c_int;
                    } else {
                        iExp -= (*p).nFrac;
                        (*p).nFrac = 0 as libc::c_int;
                    }
                }
                if iExp > 0 as libc::c_int {
                    let ref mut fresh19 = (*p).a;
                    *fresh19 = sqlite3_realloc64(
                        (*p).a as *mut libc::c_void,
                        ((*p).nDigit + iExp + 1 as libc::c_int) as sqlite3_uint64,
                    ) as *mut libc::c_schar;
                    if ((*p).a).is_null() {
                        current_block = 5169285401812211599;
                    } else {
                        memset(
                            ((*p).a).offset((*p).nDigit as isize) as *mut libc::c_void,
                            0 as libc::c_int,
                            iExp as libc::c_ulong,
                        );
                        (*p).nDigit += iExp;
                        current_block = 17995254032144898061;
                    }
                } else {
                    current_block = 17995254032144898061;
                }
            } else if iExp < 0 as libc::c_int {
                let mut nExtra: libc::c_int = 0;
                iExp = -iExp;
                nExtra = (*p).nDigit - (*p).nFrac - 1 as libc::c_int;
                if nExtra != 0 {
                    if nExtra >= iExp {
                        (*p).nFrac += iExp;
                        iExp = 0 as libc::c_int;
                    } else {
                        iExp -= nExtra;
                        (*p).nFrac = (*p).nDigit - 1 as libc::c_int;
                    }
                }
                if iExp > 0 as libc::c_int {
                    let ref mut fresh20 = (*p).a;
                    *fresh20 = sqlite3_realloc64(
                        (*p).a as *mut libc::c_void,
                        ((*p).nDigit + iExp + 1 as libc::c_int) as sqlite3_uint64,
                    ) as *mut libc::c_schar;
                    if ((*p).a).is_null() {
                        current_block = 5169285401812211599;
                    } else {
                        memmove(
                            ((*p).a).offset(iExp as isize) as *mut libc::c_void,
                            (*p).a as *const libc::c_void,
                            (*p).nDigit as libc::c_ulong,
                        );
                        memset(
                            (*p).a as *mut libc::c_void,
                            0 as libc::c_int,
                            iExp as libc::c_ulong,
                        );
                        (*p).nDigit += iExp;
                        (*p).nFrac += iExp;
                        current_block = 17995254032144898061;
                    }
                } else {
                    current_block = 17995254032144898061;
                }
            } else {
                current_block = 17995254032144898061;
            }
            match current_block {
                5169285401812211599 => {}
                _ => return p,
            }
        }
    }
    if !pCtx.is_null() {
        sqlite3_result_error_nomem(pCtx);
    }
    sqlite3_free(p as *mut libc::c_void);
    return 0 as *mut Decimal;
}
unsafe extern "C" fn decimal_result(
    mut pCtx: *mut sqlite3_context,
    mut p: *mut Decimal,
) {
    let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    if p.is_null() || (*p).oom as libc::c_int != 0 {
        sqlite3_result_error_nomem(pCtx);
        return;
    }
    if (*p).isNull != 0 {
        sqlite3_result_null(pCtx);
        return;
    }
    z = sqlite3_malloc((*p).nDigit + 4 as libc::c_int) as *mut libc::c_char;
    if z.is_null() {
        sqlite3_result_error_nomem(pCtx);
        return;
    }
    i = 0 as libc::c_int;
    if (*p).nDigit == 0 as libc::c_int
        || (*p).nDigit == 1 as libc::c_int
            && *((*p).a).offset(0 as libc::c_int as isize) as libc::c_int
                == 0 as libc::c_int
    {
        (*p).sign = 0 as libc::c_int as libc::c_char;
    }
    if (*p).sign != 0 {
        *z.offset(0 as libc::c_int as isize) = '-' as i32 as libc::c_char;
        i = 1 as libc::c_int;
    }
    n = (*p).nDigit - (*p).nFrac;
    if n <= 0 as libc::c_int {
        let fresh21 = i;
        i = i + 1;
        *z.offset(fresh21 as isize) = '0' as i32 as libc::c_char;
    }
    j = 0 as libc::c_int;
    while n > 1 as libc::c_int
        && *((*p).a).offset(j as isize) as libc::c_int == 0 as libc::c_int
    {
        j += 1;
        n -= 1;
    }
    while n > 0 as libc::c_int {
        let fresh22 = i;
        i = i + 1;
        *z
            .offset(
                fresh22 as isize,
            ) = (*((*p).a).offset(j as isize) as libc::c_int + '0' as i32)
            as libc::c_char;
        j += 1;
        n -= 1;
    }
    if (*p).nFrac != 0 {
        let fresh23 = i;
        i = i + 1;
        *z.offset(fresh23 as isize) = '.' as i32 as libc::c_char;
        loop {
            let fresh24 = i;
            i = i + 1;
            *z
                .offset(
                    fresh24 as isize,
                ) = (*((*p).a).offset(j as isize) as libc::c_int + '0' as i32)
                as libc::c_char;
            j += 1;
            if !(j < (*p).nDigit) {
                break;
            }
        }
    }
    *z.offset(i as isize) = 0 as libc::c_int as libc::c_char;
    sqlite3_result_text(
        pCtx,
        z,
        i,
        Some(sqlite3_free as unsafe extern "C" fn(*mut libc::c_void) -> ()),
    );
}
unsafe extern "C" fn decimalFunc(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut p: *mut Decimal = decimal_new(
        context,
        *argv.offset(0 as libc::c_int as isize),
        0 as libc::c_int,
        0 as *const libc::c_uchar,
    );
    decimal_result(context, p);
    decimal_free(p);
}
unsafe extern "C" fn decimal_cmp(
    mut pA: *const Decimal,
    mut pB: *const Decimal,
) -> libc::c_int {
    let mut nASig: libc::c_int = 0;
    let mut nBSig: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    if (*pA).sign as libc::c_int != (*pB).sign as libc::c_int {
        return if (*pA).sign as libc::c_int != 0 {
            -(1 as libc::c_int)
        } else {
            1 as libc::c_int
        };
    }
    if (*pA).sign != 0 {
        let mut pTemp: *const Decimal = pA;
        pA = pB;
        pB = pTemp;
    }
    nASig = (*pA).nDigit - (*pA).nFrac;
    nBSig = (*pB).nDigit - (*pB).nFrac;
    if nASig != nBSig {
        return nASig - nBSig;
    }
    n = (*pA).nDigit;
    if n > (*pB).nDigit {
        n = (*pB).nDigit;
    }
    rc = memcmp(
        (*pA).a as *const libc::c_void,
        (*pB).a as *const libc::c_void,
        n as libc::c_ulong,
    );
    if rc == 0 as libc::c_int {
        rc = (*pA).nDigit - (*pB).nDigit;
    }
    return rc;
}
unsafe extern "C" fn decimalCmpFunc(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut pA: *mut Decimal = 0 as *mut Decimal;
    let mut pB: *mut Decimal = 0 as *mut Decimal;
    let mut rc: libc::c_int = 0;
    pA = decimal_new(
        context,
        *argv.offset(0 as libc::c_int as isize),
        0 as libc::c_int,
        0 as *const libc::c_uchar,
    );
    if !(pA.is_null() || (*pA).isNull as libc::c_int != 0) {
        pB = decimal_new(
            context,
            *argv.offset(1 as libc::c_int as isize),
            0 as libc::c_int,
            0 as *const libc::c_uchar,
        );
        if !(pB.is_null() || (*pB).isNull as libc::c_int != 0) {
            rc = decimal_cmp(pA, pB);
            if rc < 0 as libc::c_int {
                rc = -(1 as libc::c_int);
            } else if rc > 0 as libc::c_int {
                rc = 1 as libc::c_int;
            }
            sqlite3_result_int(context, rc);
        }
    }
    decimal_free(pA);
    decimal_free(pB);
}
unsafe extern "C" fn decimal_expand(
    mut p: *mut Decimal,
    mut nDigit: libc::c_int,
    mut nFrac: libc::c_int,
) {
    let mut nAddSig: libc::c_int = 0;
    let mut nAddFrac: libc::c_int = 0;
    if p.is_null() {
        return;
    }
    nAddFrac = nFrac - (*p).nFrac;
    nAddSig = nDigit - (*p).nDigit - nAddFrac;
    if nAddFrac == 0 as libc::c_int && nAddSig == 0 as libc::c_int {
        return;
    }
    let ref mut fresh25 = (*p).a;
    *fresh25 = sqlite3_realloc64(
        (*p).a as *mut libc::c_void,
        (nDigit + 1 as libc::c_int) as sqlite3_uint64,
    ) as *mut libc::c_schar;
    if ((*p).a).is_null() {
        (*p).oom = 1 as libc::c_int as libc::c_char;
        return;
    }
    if nAddSig != 0 {
        memmove(
            ((*p).a).offset(nAddSig as isize) as *mut libc::c_void,
            (*p).a as *const libc::c_void,
            (*p).nDigit as libc::c_ulong,
        );
        memset((*p).a as *mut libc::c_void, 0 as libc::c_int, nAddSig as libc::c_ulong);
        (*p).nDigit += nAddSig;
    }
    if nAddFrac != 0 {
        memset(
            ((*p).a).offset((*p).nDigit as isize) as *mut libc::c_void,
            0 as libc::c_int,
            nAddFrac as libc::c_ulong,
        );
        (*p).nDigit += nAddFrac;
        (*p).nFrac += nAddFrac;
    }
}
unsafe extern "C" fn decimal_add(mut pA: *mut Decimal, mut pB: *mut Decimal) {
    let mut nSig: libc::c_int = 0;
    let mut nFrac: libc::c_int = 0;
    let mut nDigit: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    if pA.is_null() {
        return;
    }
    if (*pA).oom as libc::c_int != 0 || pB.is_null() || (*pB).oom as libc::c_int != 0 {
        (*pA).oom = 1 as libc::c_int as libc::c_char;
        return;
    }
    if (*pA).isNull as libc::c_int != 0 || (*pB).isNull as libc::c_int != 0 {
        (*pA).isNull = 1 as libc::c_int as libc::c_char;
        return;
    }
    nSig = (*pA).nDigit - (*pA).nFrac;
    if nSig != 0
        && *((*pA).a).offset(0 as libc::c_int as isize) as libc::c_int
            == 0 as libc::c_int
    {
        nSig -= 1;
    }
    if nSig < (*pB).nDigit - (*pB).nFrac {
        nSig = (*pB).nDigit - (*pB).nFrac;
    }
    nFrac = (*pA).nFrac;
    if nFrac < (*pB).nFrac {
        nFrac = (*pB).nFrac;
    }
    nDigit = nSig + nFrac + 1 as libc::c_int;
    decimal_expand(pA, nDigit, nFrac);
    decimal_expand(pB, nDigit, nFrac);
    if (*pA).oom as libc::c_int != 0 || (*pB).oom as libc::c_int != 0 {
        (*pA).oom = 1 as libc::c_int as libc::c_char;
    } else if (*pA).sign as libc::c_int == (*pB).sign as libc::c_int {
        let mut carry: libc::c_int = 0 as libc::c_int;
        i = nDigit - 1 as libc::c_int;
        while i >= 0 as libc::c_int {
            let mut x: libc::c_int = *((*pA).a).offset(i as isize) as libc::c_int
                + *((*pB).a).offset(i as isize) as libc::c_int + carry;
            if x >= 10 as libc::c_int {
                carry = 1 as libc::c_int;
                *((*pA).a).offset(i as isize) = (x - 10 as libc::c_int) as libc::c_schar;
            } else {
                carry = 0 as libc::c_int;
                *((*pA).a).offset(i as isize) = x as libc::c_schar;
            }
            i -= 1;
        }
    } else {
        let mut aA: *mut libc::c_schar = 0 as *mut libc::c_schar;
        let mut aB: *mut libc::c_schar = 0 as *mut libc::c_schar;
        let mut borrow: libc::c_int = 0 as libc::c_int;
        rc = memcmp(
            (*pA).a as *const libc::c_void,
            (*pB).a as *const libc::c_void,
            nDigit as libc::c_ulong,
        );
        if rc < 0 as libc::c_int {
            aA = (*pB).a;
            aB = (*pA).a;
            (*pA).sign = ((*pA).sign == 0) as libc::c_int as libc::c_char;
        } else {
            aA = (*pA).a;
            aB = (*pB).a;
        }
        i = nDigit - 1 as libc::c_int;
        while i >= 0 as libc::c_int {
            let mut x_0: libc::c_int = *aA.offset(i as isize) as libc::c_int
                - *aB.offset(i as isize) as libc::c_int - borrow;
            if x_0 < 0 as libc::c_int {
                *((*pA).a)
                    .offset(i as isize) = (x_0 + 10 as libc::c_int) as libc::c_schar;
                borrow = 1 as libc::c_int;
            } else {
                *((*pA).a).offset(i as isize) = x_0 as libc::c_schar;
                borrow = 0 as libc::c_int;
            }
            i -= 1;
        }
    };
}
unsafe extern "C" fn decimalCollFunc(
    mut notUsed: *mut libc::c_void,
    mut nKey1: libc::c_int,
    mut pKey1: *const libc::c_void,
    mut nKey2: libc::c_int,
    mut pKey2: *const libc::c_void,
) -> libc::c_int {
    let mut zA: *const libc::c_uchar = pKey1 as *const libc::c_uchar;
    let mut zB: *const libc::c_uchar = pKey2 as *const libc::c_uchar;
    let mut pA: *mut Decimal = decimal_new(
        0 as *mut sqlite3_context,
        0 as *mut sqlite3_value,
        nKey1,
        zA,
    );
    let mut pB: *mut Decimal = decimal_new(
        0 as *mut sqlite3_context,
        0 as *mut sqlite3_value,
        nKey2,
        zB,
    );
    let mut rc: libc::c_int = 0;
    if pA.is_null() || pB.is_null() {
        rc = 0 as libc::c_int;
    } else {
        rc = decimal_cmp(pA, pB);
    }
    decimal_free(pA);
    decimal_free(pB);
    return rc;
}
unsafe extern "C" fn decimalAddFunc(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut pA: *mut Decimal = decimal_new(
        context,
        *argv.offset(0 as libc::c_int as isize),
        0 as libc::c_int,
        0 as *const libc::c_uchar,
    );
    let mut pB: *mut Decimal = decimal_new(
        context,
        *argv.offset(1 as libc::c_int as isize),
        0 as libc::c_int,
        0 as *const libc::c_uchar,
    );
    decimal_add(pA, pB);
    decimal_result(context, pA);
    decimal_free(pA);
    decimal_free(pB);
}
unsafe extern "C" fn decimalSubFunc(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut pA: *mut Decimal = decimal_new(
        context,
        *argv.offset(0 as libc::c_int as isize),
        0 as libc::c_int,
        0 as *const libc::c_uchar,
    );
    let mut pB: *mut Decimal = decimal_new(
        context,
        *argv.offset(1 as libc::c_int as isize),
        0 as libc::c_int,
        0 as *const libc::c_uchar,
    );
    if !pB.is_null() {
        (*pB).sign = ((*pB).sign == 0) as libc::c_int as libc::c_char;
        decimal_add(pA, pB);
        decimal_result(context, pA);
    }
    decimal_free(pA);
    decimal_free(pB);
}
unsafe extern "C" fn decimalSumStep(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut p: *mut Decimal = 0 as *mut Decimal;
    let mut pArg: *mut Decimal = 0 as *mut Decimal;
    p = sqlite3_aggregate_context(
        context,
        ::std::mem::size_of::<Decimal>() as libc::c_ulong as libc::c_int,
    ) as *mut Decimal;
    if p.is_null() {
        return;
    }
    if (*p).isInit == 0 {
        (*p).isInit = 1 as libc::c_int as libc::c_char;
        let ref mut fresh26 = (*p).a;
        *fresh26 = sqlite3_malloc(2 as libc::c_int) as *mut libc::c_schar;
        if ((*p).a).is_null() {
            (*p).oom = 1 as libc::c_int as libc::c_char;
        } else {
            *((*p).a)
                .offset(0 as libc::c_int as isize) = 0 as libc::c_int as libc::c_schar;
        }
        (*p).nDigit = 1 as libc::c_int;
        (*p).nFrac = 0 as libc::c_int;
    }
    if sqlite3_value_type(*argv.offset(0 as libc::c_int as isize)) == 5 as libc::c_int {
        return;
    }
    pArg = decimal_new(
        context,
        *argv.offset(0 as libc::c_int as isize),
        0 as libc::c_int,
        0 as *const libc::c_uchar,
    );
    decimal_add(p, pArg);
    decimal_free(pArg);
}
unsafe extern "C" fn decimalSumInverse(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut p: *mut Decimal = 0 as *mut Decimal;
    let mut pArg: *mut Decimal = 0 as *mut Decimal;
    p = sqlite3_aggregate_context(
        context,
        ::std::mem::size_of::<Decimal>() as libc::c_ulong as libc::c_int,
    ) as *mut Decimal;
    if p.is_null() {
        return;
    }
    if sqlite3_value_type(*argv.offset(0 as libc::c_int as isize)) == 5 as libc::c_int {
        return;
    }
    pArg = decimal_new(
        context,
        *argv.offset(0 as libc::c_int as isize),
        0 as libc::c_int,
        0 as *const libc::c_uchar,
    );
    if !pArg.is_null() {
        (*pArg).sign = ((*pArg).sign == 0) as libc::c_int as libc::c_char;
    }
    decimal_add(p, pArg);
    decimal_free(pArg);
}
unsafe extern "C" fn decimalSumValue(mut context: *mut sqlite3_context) {
    let mut p: *mut Decimal = sqlite3_aggregate_context(context, 0 as libc::c_int)
        as *mut Decimal;
    if p.is_null() {
        return;
    }
    decimal_result(context, p);
}
unsafe extern "C" fn decimalSumFinalize(mut context: *mut sqlite3_context) {
    let mut p: *mut Decimal = sqlite3_aggregate_context(context, 0 as libc::c_int)
        as *mut Decimal;
    if p.is_null() {
        return;
    }
    decimal_result(context, p);
    decimal_clear(p);
}
unsafe extern "C" fn decimalMulFunc(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut pA: *mut Decimal = decimal_new(
        context,
        *argv.offset(0 as libc::c_int as isize),
        0 as libc::c_int,
        0 as *const libc::c_uchar,
    );
    let mut pB: *mut Decimal = decimal_new(
        context,
        *argv.offset(1 as libc::c_int as isize),
        0 as libc::c_int,
        0 as *const libc::c_uchar,
    );
    let mut acc: *mut libc::c_schar = 0 as *mut libc::c_schar;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut k: libc::c_int = 0;
    let mut minFrac: libc::c_int = 0;
    if !(pA.is_null() || (*pA).oom as libc::c_int != 0
        || (*pA).isNull as libc::c_int != 0 || pB.is_null()
        || (*pB).oom as libc::c_int != 0 || (*pB).isNull as libc::c_int != 0)
    {
        acc = sqlite3_malloc64(
            ((*pA).nDigit + (*pB).nDigit + 2 as libc::c_int) as sqlite3_uint64,
        ) as *mut libc::c_schar;
        if acc.is_null() {
            sqlite3_result_error_nomem(context);
        } else {
            memset(
                acc as *mut libc::c_void,
                0 as libc::c_int,
                ((*pA).nDigit + (*pB).nDigit + 2 as libc::c_int) as libc::c_ulong,
            );
            minFrac = (*pA).nFrac;
            if (*pB).nFrac < minFrac {
                minFrac = (*pB).nFrac;
            }
            i = (*pA).nDigit - 1 as libc::c_int;
            while i >= 0 as libc::c_int {
                let mut f: libc::c_schar = *((*pA).a).offset(i as isize);
                let mut carry: libc::c_int = 0 as libc::c_int;
                let mut x: libc::c_int = 0;
                j = (*pB).nDigit - 1 as libc::c_int;
                k = i + j + 3 as libc::c_int;
                while j >= 0 as libc::c_int {
                    x = *acc.offset(k as isize) as libc::c_int
                        + f as libc::c_int * *((*pB).a).offset(j as isize) as libc::c_int
                        + carry;
                    *acc.offset(k as isize) = (x % 10 as libc::c_int) as libc::c_schar;
                    carry = x / 10 as libc::c_int;
                    j -= 1;
                    k -= 1;
                }
                x = *acc.offset(k as isize) as libc::c_int + carry;
                *acc.offset(k as isize) = (x % 10 as libc::c_int) as libc::c_schar;
                let ref mut fresh27 = *acc.offset((k - 1 as libc::c_int) as isize);
                *fresh27 = (*fresh27 as libc::c_int + x / 10 as libc::c_int)
                    as libc::c_schar;
                i -= 1;
            }
            sqlite3_free((*pA).a as *mut libc::c_void);
            let ref mut fresh28 = (*pA).a;
            *fresh28 = acc;
            acc = 0 as *mut libc::c_schar;
            (*pA).nDigit += (*pB).nDigit + 2 as libc::c_int;
            (*pA).nFrac += (*pB).nFrac;
            let ref mut fresh29 = (*pA).sign;
            *fresh29 = (*fresh29 as libc::c_int ^ (*pB).sign as libc::c_int)
                as libc::c_char;
            while (*pA).nFrac > minFrac
                && *((*pA).a).offset(((*pA).nDigit - 1 as libc::c_int) as isize)
                    as libc::c_int == 0 as libc::c_int
            {
                let ref mut fresh30 = (*pA).nFrac;
                *fresh30 -= 1;
                let ref mut fresh31 = (*pA).nDigit;
                *fresh31 -= 1;
            }
            decimal_result(context, pA);
        }
    }
    sqlite3_free(acc as *mut libc::c_void);
    decimal_free(pA);
    decimal_free(pB);
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_decimal_init(
    mut db: *mut sqlite3,
    mut pzErrMsg: *mut *mut libc::c_char,
    mut pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    static mut aFunc: [C2RustUnnamed_16; 5] = unsafe {
        [
            {
                let mut init = C2RustUnnamed_16 {
                    zFuncName: b"decimal\0" as *const u8 as *const libc::c_char,
                    nArg: 1 as libc::c_int,
                    xFunc: Some(
                        decimalFunc
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let mut init = C2RustUnnamed_16 {
                    zFuncName: b"decimal_cmp\0" as *const u8 as *const libc::c_char,
                    nArg: 2 as libc::c_int,
                    xFunc: Some(
                        decimalCmpFunc
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let mut init = C2RustUnnamed_16 {
                    zFuncName: b"decimal_add\0" as *const u8 as *const libc::c_char,
                    nArg: 2 as libc::c_int,
                    xFunc: Some(
                        decimalAddFunc
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let mut init = C2RustUnnamed_16 {
                    zFuncName: b"decimal_sub\0" as *const u8 as *const libc::c_char,
                    nArg: 2 as libc::c_int,
                    xFunc: Some(
                        decimalSubFunc
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let mut init = C2RustUnnamed_16 {
                    zFuncName: b"decimal_mul\0" as *const u8 as *const libc::c_char,
                    nArg: 2 as libc::c_int,
                    xFunc: Some(
                        decimalMulFunc
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
        ]
    };
    let mut i: libc::c_uint = 0;
    i = 0 as libc::c_int as libc::c_uint;
    while (i as libc::c_ulong)
        < (::std::mem::size_of::<[C2RustUnnamed_16; 5]>() as libc::c_ulong)
            .wrapping_div(::std::mem::size_of::<C2RustUnnamed_16>() as libc::c_ulong)
        && rc == 0 as libc::c_int
    {
        rc = sqlite3_create_function(
            db,
            aFunc[i as usize].zFuncName,
            aFunc[i as usize].nArg,
            1 as libc::c_int | 0x200000 as libc::c_int | 0x800 as libc::c_int,
            0 as *mut libc::c_void,
            aFunc[i as usize].xFunc,
            None,
            None,
        );
        i = i.wrapping_add(1);
    }
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_window_function(
            db,
            b"decimal_sum\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            1 as libc::c_int | 0x200000 as libc::c_int | 0x800 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                decimalSumStep
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            Some(decimalSumFinalize as unsafe extern "C" fn(*mut sqlite3_context) -> ()),
            Some(decimalSumValue as unsafe extern "C" fn(*mut sqlite3_context) -> ()),
            Some(
                decimalSumInverse
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
        );
    }
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_collation(
            db,
            b"decimal\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                decimalCollFunc
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        libc::c_int,
                        *const libc::c_void,
                        libc::c_int,
                        *const libc::c_void,
                    ) -> libc::c_int,
            ),
        );
    }
    return rc;
}
unsafe extern "C" fn ieee754func(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    if argc == 1 as libc::c_int {
        let mut m: sqlite3_int64 = 0;
        let mut a: sqlite3_int64 = 0;
        let mut r: libc::c_double = 0.;
        let mut e: libc::c_int = 0;
        let mut isNeg: libc::c_int = 0;
        let mut zResult: [libc::c_char; 100] = [0; 100];
        if sqlite3_value_type(*argv.offset(0 as libc::c_int as isize))
            == 4 as libc::c_int
            && sqlite3_value_bytes(*argv.offset(0 as libc::c_int as isize))
                as libc::c_ulong
                == ::std::mem::size_of::<libc::c_double>() as libc::c_ulong
        {
            let mut x: *const libc::c_uchar = sqlite3_value_blob(
                *argv.offset(0 as libc::c_int as isize),
            ) as *const libc::c_uchar;
            let mut i: libc::c_uint = 0;
            let mut v: sqlite3_uint64 = 0 as libc::c_int as sqlite3_uint64;
            i = 0 as libc::c_int as libc::c_uint;
            while (i as libc::c_ulong)
                < ::std::mem::size_of::<libc::c_double>() as libc::c_ulong
            {
                v = v << 8 as libc::c_int | *x.offset(i as isize) as libc::c_ulonglong;
                i = i.wrapping_add(1);
            }
            memcpy(
                &mut r as *mut libc::c_double as *mut libc::c_void,
                &mut v as *mut sqlite3_uint64 as *const libc::c_void,
                ::std::mem::size_of::<libc::c_double>() as libc::c_ulong,
            );
        } else {
            r = sqlite3_value_double(*argv.offset(0 as libc::c_int as isize));
        }
        if r < 0.0f64 {
            isNeg = 1 as libc::c_int;
            r = -r;
        } else {
            isNeg = 0 as libc::c_int;
        }
        memcpy(
            &mut a as *mut sqlite3_int64 as *mut libc::c_void,
            &mut r as *mut libc::c_double as *const libc::c_void,
            ::std::mem::size_of::<sqlite3_int64>() as libc::c_ulong,
        );
        if a == 0 as libc::c_int as libc::c_longlong {
            e = 0 as libc::c_int;
            m = 0 as libc::c_int as sqlite3_int64;
        } else {
            e = (a >> 52 as libc::c_int) as libc::c_int;
            m = a
                & ((1 as libc::c_int as sqlite3_int64) << 52 as libc::c_int)
                    - 1 as libc::c_int as libc::c_longlong;
            if e == 0 as libc::c_int {
                m <<= 1 as libc::c_int;
            } else {
                m |= (1 as libc::c_int as sqlite3_int64) << 52 as libc::c_int;
            }
            while e < 1075 as libc::c_int && m > 0 as libc::c_int as libc::c_longlong
                && m & 1 as libc::c_int as libc::c_longlong
                    == 0 as libc::c_int as libc::c_longlong
            {
                m >>= 1 as libc::c_int;
                e += 1;
            }
            if isNeg != 0 {
                m = -m;
            }
        }
        match *(sqlite3_user_data(context) as *mut libc::c_int) {
            0 => {
                sqlite3_snprintf(
                    ::std::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong
                        as libc::c_int,
                    zResult.as_mut_ptr(),
                    b"ieee754(%lld,%d)\0" as *const u8 as *const libc::c_char,
                    m,
                    e - 1075 as libc::c_int,
                );
                sqlite3_result_text(
                    context,
                    zResult.as_mut_ptr(),
                    -(1 as libc::c_int),
                    ::std::mem::transmute::<
                        libc::intptr_t,
                        sqlite3_destructor_type,
                    >(-(1 as libc::c_int) as libc::intptr_t),
                );
            }
            1 => {
                sqlite3_result_int64(context, m);
            }
            2 => {
                sqlite3_result_int(context, e - 1075 as libc::c_int);
            }
            _ => {}
        }
    } else {
        let mut m_0: sqlite3_int64 = 0;
        let mut e_0: sqlite3_int64 = 0;
        let mut a_0: sqlite3_int64 = 0;
        let mut r_0: libc::c_double = 0.;
        let mut isNeg_0: libc::c_int = 0 as libc::c_int;
        m_0 = sqlite3_value_int64(*argv.offset(0 as libc::c_int as isize));
        e_0 = sqlite3_value_int64(*argv.offset(1 as libc::c_int as isize));
        if e_0 > 10000 as libc::c_int as libc::c_longlong {
            e_0 = 10000 as libc::c_int as sqlite3_int64;
        } else if e_0 < -(10000 as libc::c_int) as libc::c_longlong {
            e_0 = -(10000 as libc::c_int) as sqlite3_int64;
        }
        if m_0 < 0 as libc::c_int as libc::c_longlong {
            isNeg_0 = 1 as libc::c_int;
            m_0 = -m_0;
            if m_0 < 0 as libc::c_int as libc::c_longlong {
                return;
            }
        } else if m_0 == 0 as libc::c_int as libc::c_longlong
            && e_0 > -(1000 as libc::c_int) as libc::c_longlong
            && e_0 < 1000 as libc::c_int as libc::c_longlong
        {
            sqlite3_result_double(context, 0.0f64);
            return;
        }
        while m_0 >> 32 as libc::c_int & 0xffe00000 as libc::c_uint as libc::c_longlong
            != 0
        {
            m_0 >>= 1 as libc::c_int;
            e_0 += 1;
        }
        while m_0 != 0 as libc::c_int as libc::c_longlong
            && m_0 >> 32 as libc::c_int & 0xfff00000 as libc::c_uint as libc::c_longlong
                == 0 as libc::c_int as libc::c_longlong
        {
            m_0 <<= 1 as libc::c_int;
            e_0 -= 1;
        }
        e_0 += 1075 as libc::c_int as libc::c_longlong;
        if e_0 <= 0 as libc::c_int as libc::c_longlong {
            if 1 as libc::c_int as libc::c_longlong - e_0
                >= 64 as libc::c_int as libc::c_longlong
            {
                m_0 = 0 as libc::c_int as sqlite3_int64;
            } else {
                m_0 >>= 1 as libc::c_int as libc::c_longlong - e_0;
            }
            e_0 = 0 as libc::c_int as sqlite3_int64;
        } else if e_0 > 0x7ff as libc::c_int as libc::c_longlong {
            e_0 = 0x7ff as libc::c_int as sqlite3_int64;
        }
        a_0 = m_0
            & ((1 as libc::c_int as sqlite3_int64) << 52 as libc::c_int)
                - 1 as libc::c_int as libc::c_longlong;
        a_0 |= e_0 << 52 as libc::c_int;
        if isNeg_0 != 0 {
            a_0 = (a_0 as libc::c_ulonglong
                | (1 as libc::c_int as sqlite3_uint64) << 63 as libc::c_int)
                as sqlite3_int64;
        }
        memcpy(
            &mut r_0 as *mut libc::c_double as *mut libc::c_void,
            &mut a_0 as *mut sqlite3_int64 as *const libc::c_void,
            ::std::mem::size_of::<libc::c_double>() as libc::c_ulong,
        );
        sqlite3_result_double(context, r_0);
    };
}
unsafe extern "C" fn ieee754func_from_blob(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    if sqlite3_value_type(*argv.offset(0 as libc::c_int as isize)) == 4 as libc::c_int
        && sqlite3_value_bytes(*argv.offset(0 as libc::c_int as isize)) as libc::c_ulong
            == ::std::mem::size_of::<libc::c_double>() as libc::c_ulong
    {
        let mut r: libc::c_double = 0.;
        let mut x: *const libc::c_uchar = sqlite3_value_blob(
            *argv.offset(0 as libc::c_int as isize),
        ) as *const libc::c_uchar;
        let mut i: libc::c_uint = 0;
        let mut v: sqlite3_uint64 = 0 as libc::c_int as sqlite3_uint64;
        i = 0 as libc::c_int as libc::c_uint;
        while (i as libc::c_ulong)
            < ::std::mem::size_of::<libc::c_double>() as libc::c_ulong
        {
            v = v << 8 as libc::c_int | *x.offset(i as isize) as libc::c_ulonglong;
            i = i.wrapping_add(1);
        }
        memcpy(
            &mut r as *mut libc::c_double as *mut libc::c_void,
            &mut v as *mut sqlite3_uint64 as *const libc::c_void,
            ::std::mem::size_of::<libc::c_double>() as libc::c_ulong,
        );
        sqlite3_result_double(context, r);
    }
}
unsafe extern "C" fn ieee754func_to_blob(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    if sqlite3_value_type(*argv.offset(0 as libc::c_int as isize)) == 2 as libc::c_int
        || sqlite3_value_type(*argv.offset(0 as libc::c_int as isize))
            == 1 as libc::c_int
    {
        let mut r: libc::c_double = sqlite3_value_double(
            *argv.offset(0 as libc::c_int as isize),
        );
        let mut v: sqlite3_uint64 = 0;
        let mut a: [libc::c_uchar; 8] = [0; 8];
        let mut i: libc::c_uint = 0;
        memcpy(
            &mut v as *mut sqlite3_uint64 as *mut libc::c_void,
            &mut r as *mut libc::c_double as *const libc::c_void,
            ::std::mem::size_of::<libc::c_double>() as libc::c_ulong,
        );
        i = 1 as libc::c_int as libc::c_uint;
        while i as libc::c_ulong
            <= ::std::mem::size_of::<libc::c_double>() as libc::c_ulong
        {
            a[(::std::mem::size_of::<libc::c_double>() as libc::c_ulong)
                .wrapping_sub(i as libc::c_ulong)
                as usize] = (v & 0xff as libc::c_int as libc::c_ulonglong)
                as libc::c_uchar;
            v >>= 8 as libc::c_int;
            i = i.wrapping_add(1);
        }
        sqlite3_result_blob(
            context,
            a.as_mut_ptr() as *const libc::c_void,
            ::std::mem::size_of::<libc::c_double>() as libc::c_ulong as libc::c_int,
            ::std::mem::transmute::<
                libc::intptr_t,
                sqlite3_destructor_type,
            >(-(1 as libc::c_int) as libc::intptr_t),
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_ieee_init(
    mut db: *mut sqlite3,
    mut pzErrMsg: *mut *mut libc::c_char,
    mut pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    static mut aFunc: [C2RustUnnamed_17; 6] = unsafe {
        [
            {
                let mut init = C2RustUnnamed_17 {
                    zFName: b"ieee754\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    nArg: 1 as libc::c_int,
                    iAux: 0 as libc::c_int,
                    xFunc: Some(
                        ieee754func
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let mut init = C2RustUnnamed_17 {
                    zFName: b"ieee754\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    nArg: 2 as libc::c_int,
                    iAux: 0 as libc::c_int,
                    xFunc: Some(
                        ieee754func
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let mut init = C2RustUnnamed_17 {
                    zFName: b"ieee754_mantissa\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    nArg: 1 as libc::c_int,
                    iAux: 1 as libc::c_int,
                    xFunc: Some(
                        ieee754func
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let mut init = C2RustUnnamed_17 {
                    zFName: b"ieee754_exponent\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    nArg: 1 as libc::c_int,
                    iAux: 2 as libc::c_int,
                    xFunc: Some(
                        ieee754func
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let mut init = C2RustUnnamed_17 {
                    zFName: b"ieee754_to_blob\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    nArg: 1 as libc::c_int,
                    iAux: 0 as libc::c_int,
                    xFunc: Some(
                        ieee754func_to_blob
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let mut init = C2RustUnnamed_17 {
                    zFName: b"ieee754_from_blob\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    nArg: 1 as libc::c_int,
                    iAux: 0 as libc::c_int,
                    xFunc: Some(
                        ieee754func_from_blob
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
        ]
    };
    let mut i: libc::c_uint = 0;
    let mut rc: libc::c_int = 0 as libc::c_int;
    i = 0 as libc::c_int as libc::c_uint;
    while (i as libc::c_ulong)
        < (::std::mem::size_of::<[C2RustUnnamed_17; 6]>() as libc::c_ulong)
            .wrapping_div(::std::mem::size_of::<C2RustUnnamed_17>() as libc::c_ulong)
        && rc == 0 as libc::c_int
    {
        rc = sqlite3_create_function(
            db,
            aFunc[i as usize].zFName,
            aFunc[i as usize].nArg,
            1 as libc::c_int | 0x200000 as libc::c_int,
            &(*aFunc.as_ptr().offset(i as isize)).iAux as *const libc::c_int
                as *mut libc::c_void,
            aFunc[i as usize].xFunc,
            None,
            None,
        );
        i = i.wrapping_add(1);
    }
    return rc;
}
unsafe extern "C" fn seriesConnect(
    mut db: *mut sqlite3,
    mut pUnused: *mut libc::c_void,
    mut argcUnused: libc::c_int,
    mut argvUnused: *const *const libc::c_char,
    mut ppVtab: *mut *mut sqlite3_vtab,
    mut pzErrUnused: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut pNew: *mut sqlite3_vtab = 0 as *mut sqlite3_vtab;
    let mut rc: libc::c_int = 0;
    rc = sqlite3_declare_vtab(
        db,
        b"CREATE TABLE x(value,start hidden,stop hidden,step hidden)\0" as *const u8
            as *const libc::c_char,
    );
    if rc == 0 as libc::c_int {
        *ppVtab = sqlite3_malloc(
            ::std::mem::size_of::<sqlite3_vtab>() as libc::c_ulong as libc::c_int,
        ) as *mut sqlite3_vtab;
        pNew = *ppVtab;
        if pNew.is_null() {
            return 7 as libc::c_int;
        }
        memset(
            pNew as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<sqlite3_vtab>() as libc::c_ulong,
        );
        sqlite3_vtab_config(db, 2 as libc::c_int);
    }
    return rc;
}
unsafe extern "C" fn seriesDisconnect(mut pVtab: *mut sqlite3_vtab) -> libc::c_int {
    sqlite3_free(pVtab as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn seriesOpen(
    mut pUnused: *mut sqlite3_vtab,
    mut ppCursor: *mut *mut sqlite3_vtab_cursor,
) -> libc::c_int {
    let mut pCur: *mut series_cursor = 0 as *mut series_cursor;
    pCur = sqlite3_malloc(
        ::std::mem::size_of::<series_cursor>() as libc::c_ulong as libc::c_int,
    ) as *mut series_cursor;
    if pCur.is_null() {
        return 7 as libc::c_int;
    }
    memset(
        pCur as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<series_cursor>() as libc::c_ulong,
    );
    *ppCursor = &mut (*pCur).base;
    return 0 as libc::c_int;
}
unsafe extern "C" fn seriesClose(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    sqlite3_free(cur as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn seriesNext(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCur: *mut series_cursor = cur as *mut series_cursor;
    if (*pCur).isDesc != 0 {
        let ref mut fresh32 = (*pCur).iValue;
        *fresh32 -= (*pCur).iStep;
    } else {
        let ref mut fresh33 = (*pCur).iValue;
        *fresh33 += (*pCur).iStep;
    }
    let ref mut fresh34 = (*pCur).iRowid;
    *fresh34 += 1;
    return 0 as libc::c_int;
}
unsafe extern "C" fn seriesColumn(
    mut cur: *mut sqlite3_vtab_cursor,
    mut ctx: *mut sqlite3_context,
    mut i: libc::c_int,
) -> libc::c_int {
    let mut pCur: *mut series_cursor = cur as *mut series_cursor;
    let mut x: sqlite3_int64 = 0 as libc::c_int as sqlite3_int64;
    match i {
        1 => {
            x = (*pCur).mnValue;
        }
        2 => {
            x = (*pCur).mxValue;
        }
        3 => {
            x = (*pCur).iStep;
        }
        _ => {
            x = (*pCur).iValue;
        }
    }
    sqlite3_result_int64(ctx, x);
    return 0 as libc::c_int;
}
unsafe extern "C" fn seriesRowid(
    mut cur: *mut sqlite3_vtab_cursor,
    mut pRowid: *mut sqlite_int64,
) -> libc::c_int {
    let mut pCur: *mut series_cursor = cur as *mut series_cursor;
    *pRowid = (*pCur).iRowid;
    return 0 as libc::c_int;
}
unsafe extern "C" fn seriesEof(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCur: *mut series_cursor = cur as *mut series_cursor;
    if (*pCur).isDesc != 0 {
        return ((*pCur).iValue < (*pCur).mnValue) as libc::c_int
    } else {
        return ((*pCur).iValue > (*pCur).mxValue) as libc::c_int
    };
}
unsafe extern "C" fn seriesFilter(
    mut pVtabCursor: *mut sqlite3_vtab_cursor,
    mut idxNum: libc::c_int,
    mut idxStrUnused: *const libc::c_char,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) -> libc::c_int {
    let mut pCur: *mut series_cursor = pVtabCursor as *mut series_cursor;
    let mut i: libc::c_int = 0 as libc::c_int;
    if idxNum & 1 as libc::c_int != 0 {
        let fresh35 = i;
        i = i + 1;
        (*pCur).mnValue = sqlite3_value_int64(*argv.offset(fresh35 as isize));
    } else {
        (*pCur).mnValue = 0 as libc::c_int as sqlite3_int64;
    }
    if idxNum & 2 as libc::c_int != 0 {
        let fresh36 = i;
        i = i + 1;
        (*pCur).mxValue = sqlite3_value_int64(*argv.offset(fresh36 as isize));
    } else {
        (*pCur).mxValue = 0xffffffff as libc::c_uint as sqlite3_int64;
    }
    if idxNum & 4 as libc::c_int != 0 {
        let fresh37 = i;
        i = i + 1;
        (*pCur).iStep = sqlite3_value_int64(*argv.offset(fresh37 as isize));
        if (*pCur).iStep == 0 as libc::c_int as libc::c_longlong {
            (*pCur).iStep = 1 as libc::c_int as sqlite3_int64;
        } else if (*pCur).iStep < 0 as libc::c_int as libc::c_longlong {
            (*pCur).iStep = -(*pCur).iStep;
            if idxNum & 16 as libc::c_int == 0 as libc::c_int {
                idxNum |= 8 as libc::c_int;
            }
        }
    } else {
        (*pCur).iStep = 1 as libc::c_int as sqlite3_int64;
    }
    i = 0 as libc::c_int;
    while i < argc {
        if sqlite3_value_type(*argv.offset(i as isize)) == 5 as libc::c_int {
            (*pCur).mnValue = 1 as libc::c_int as sqlite3_int64;
            (*pCur).mxValue = 0 as libc::c_int as sqlite3_int64;
            break;
        } else {
            i += 1;
        }
    }
    if idxNum & 8 as libc::c_int != 0 {
        (*pCur).isDesc = 1 as libc::c_int;
        (*pCur).iValue = (*pCur).mxValue;
        if (*pCur).iStep > 0 as libc::c_int as libc::c_longlong {
            let ref mut fresh38 = (*pCur).iValue;
            *fresh38 -= ((*pCur).mxValue - (*pCur).mnValue) % (*pCur).iStep;
        }
    } else {
        (*pCur).isDesc = 0 as libc::c_int;
        (*pCur).iValue = (*pCur).mnValue;
    }
    (*pCur).iRowid = 1 as libc::c_int as sqlite3_int64;
    return 0 as libc::c_int;
}
unsafe extern "C" fn seriesBestIndex(
    mut pVTab: *mut sqlite3_vtab,
    mut pIdxInfo: *mut sqlite3_index_info,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut idxNum: libc::c_int = 0 as libc::c_int;
    let mut bStartSeen: libc::c_int = 0 as libc::c_int;
    let mut unusableMask: libc::c_int = 0 as libc::c_int;
    let mut nArg: libc::c_int = 0 as libc::c_int;
    let mut aIdx: [libc::c_int; 3] = [0; 3];
    let mut pConstraint: *const sqlite3_index_constraint = 0
        as *const sqlite3_index_constraint;
    aIdx[2 as libc::c_int as usize] = -(1 as libc::c_int);
    aIdx[1 as libc::c_int as usize] = aIdx[2 as libc::c_int as usize];
    aIdx[0 as libc::c_int as usize] = aIdx[1 as libc::c_int as usize];
    pConstraint = (*pIdxInfo).aConstraint;
    i = 0 as libc::c_int;
    while i < (*pIdxInfo).nConstraint {
        let mut iCol: libc::c_int = 0;
        let mut iMask: libc::c_int = 0;
        if !((*pConstraint).iColumn < 1 as libc::c_int) {
            iCol = (*pConstraint).iColumn - 1 as libc::c_int;
            iMask = (1 as libc::c_int) << iCol;
            if iCol == 0 as libc::c_int {
                bStartSeen = 1 as libc::c_int;
            }
            if (*pConstraint).usable as libc::c_int == 0 as libc::c_int {
                unusableMask |= iMask;
            } else if (*pConstraint).op as libc::c_int == 2 as libc::c_int {
                idxNum |= iMask;
                aIdx[iCol as usize] = i;
            }
        }
        i += 1;
        pConstraint = pConstraint.offset(1);
    }
    i = 0 as libc::c_int;
    while i < 3 as libc::c_int {
        j = aIdx[i as usize];
        if j >= 0 as libc::c_int {
            nArg += 1;
            (*((*pIdxInfo).aConstraintUsage).offset(j as isize)).argvIndex = nArg;
            (*((*pIdxInfo).aConstraintUsage).offset(j as isize))
                .omit = (0 as libc::c_int == 0) as libc::c_int as libc::c_uchar;
        }
        i += 1;
    }
    if bStartSeen == 0 {
        sqlite3_free((*pVTab).zErrMsg as *mut libc::c_void);
        let ref mut fresh39 = (*pVTab).zErrMsg;
        *fresh39 = sqlite3_mprintf(
            b"first argument to \"generate_series()\" missing or unusable\0" as *const u8
                as *const libc::c_char,
        );
        return 1 as libc::c_int;
    }
    if unusableMask & !idxNum != 0 as libc::c_int {
        return 19 as libc::c_int;
    }
    if idxNum & 3 as libc::c_int == 3 as libc::c_int {
        (*pIdxInfo)
            .estimatedCost = (2 as libc::c_int
            - (idxNum & 4 as libc::c_int != 0 as libc::c_int) as libc::c_int)
            as libc::c_double;
        (*pIdxInfo).estimatedRows = 1000 as libc::c_int as sqlite3_int64;
        if (*pIdxInfo).nOrderBy >= 1 as libc::c_int
            && (*((*pIdxInfo).aOrderBy).offset(0 as libc::c_int as isize)).iColumn
                == 0 as libc::c_int
        {
            if (*((*pIdxInfo).aOrderBy).offset(0 as libc::c_int as isize)).desc != 0 {
                idxNum |= 8 as libc::c_int;
            } else {
                idxNum |= 16 as libc::c_int;
            }
            (*pIdxInfo).orderByConsumed = 1 as libc::c_int;
        }
    } else {
        (*pIdxInfo).estimatedRows = 2147483647 as libc::c_int as sqlite3_int64;
    }
    (*pIdxInfo).idxNum = idxNum;
    return 0 as libc::c_int;
}
static mut seriesModule: sqlite3_module = unsafe {
    {
        let mut init = sqlite3_module {
            iVersion: 0 as libc::c_int,
            xCreate: None,
            xConnect: Some(
                seriesConnect
                    as unsafe extern "C" fn(
                        *mut sqlite3,
                        *mut libc::c_void,
                        libc::c_int,
                        *const *const libc::c_char,
                        *mut *mut sqlite3_vtab,
                        *mut *mut libc::c_char,
                    ) -> libc::c_int,
            ),
            xBestIndex: Some(
                seriesBestIndex
                    as unsafe extern "C" fn(
                        *mut sqlite3_vtab,
                        *mut sqlite3_index_info,
                    ) -> libc::c_int,
            ),
            xDisconnect: Some(
                seriesDisconnect
                    as unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int,
            ),
            xDestroy: None,
            xOpen: Some(
                seriesOpen
                    as unsafe extern "C" fn(
                        *mut sqlite3_vtab,
                        *mut *mut sqlite3_vtab_cursor,
                    ) -> libc::c_int,
            ),
            xClose: Some(
                seriesClose
                    as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
            ),
            xFilter: Some(
                seriesFilter
                    as unsafe extern "C" fn(
                        *mut sqlite3_vtab_cursor,
                        libc::c_int,
                        *const libc::c_char,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> libc::c_int,
            ),
            xNext: Some(
                seriesNext
                    as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
            ),
            xEof: Some(
                seriesEof
                    as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
            ),
            xColumn: Some(
                seriesColumn
                    as unsafe extern "C" fn(
                        *mut sqlite3_vtab_cursor,
                        *mut sqlite3_context,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            xRowid: Some(
                seriesRowid
                    as unsafe extern "C" fn(
                        *mut sqlite3_vtab_cursor,
                        *mut sqlite_int64,
                    ) -> libc::c_int,
            ),
            xUpdate: None,
            xBegin: None,
            xSync: None,
            xCommit: None,
            xRollback: None,
            xFindFunction: None,
            xRename: None,
            xSavepoint: None,
            xRelease: None,
            xRollbackTo: None,
            xShadowName: None,
        };
        init
    }
};
#[no_mangle]
pub unsafe extern "C" fn sqlite3_series_init(
    mut db: *mut sqlite3,
    mut pzErrMsg: *mut *mut libc::c_char,
    mut pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if sqlite3_libversion_number() < 3008012 as libc::c_int && !pzErrMsg.is_null() {
        *pzErrMsg = sqlite3_mprintf(
            b"generate_series() requires SQLite 3.8.12 or later\0" as *const u8
                as *const libc::c_char,
        );
        return 1 as libc::c_int;
    }
    rc = sqlite3_create_module(
        db,
        b"generate_series\0" as *const u8 as *const libc::c_char,
        &mut seriesModule,
        0 as *mut libc::c_void,
    );
    return rc;
}
unsafe extern "C" fn re_add_state(mut pSet: *mut ReStateSet, mut newState: libc::c_int) {
    let mut i: libc::c_uint = 0;
    i = 0 as libc::c_int as libc::c_uint;
    while i < (*pSet).nState {
        if *((*pSet).aState).offset(i as isize) as libc::c_int == newState {
            return;
        }
        i = i.wrapping_add(1);
    }
    let ref mut fresh40 = (*pSet).nState;
    let fresh41 = *fresh40;
    *fresh40 = (*fresh40).wrapping_add(1);
    *((*pSet).aState).offset(fresh41 as isize) = newState as ReStateNumber;
}
unsafe extern "C" fn re_next_char(mut p: *mut ReInput) -> libc::c_uint {
    let mut c: libc::c_uint = 0;
    if (*p).i >= (*p).mx {
        return 0 as libc::c_int as libc::c_uint;
    }
    let ref mut fresh42 = (*p).i;
    let fresh43 = *fresh42;
    *fresh42 = *fresh42 + 1;
    c = *((*p).z).offset(fresh43 as isize) as libc::c_uint;
    if c >= 0x80 as libc::c_int as libc::c_uint {
        if c & 0xe0 as libc::c_int as libc::c_uint == 0xc0 as libc::c_int as libc::c_uint
            && (*p).i < (*p).mx
            && *((*p).z).offset((*p).i as isize) as libc::c_int & 0xc0 as libc::c_int
                == 0x80 as libc::c_int
        {
            let ref mut fresh44 = (*p).i;
            let fresh45 = *fresh44;
            *fresh44 = *fresh44 + 1;
            c = (c & 0x1f as libc::c_int as libc::c_uint) << 6 as libc::c_int
                | (*((*p).z).offset(fresh45 as isize) as libc::c_int
                    & 0x3f as libc::c_int) as libc::c_uint;
            if c < 0x80 as libc::c_int as libc::c_uint {
                c = 0xfffd as libc::c_int as libc::c_uint;
            }
        } else if c & 0xf0 as libc::c_int as libc::c_uint
            == 0xe0 as libc::c_int as libc::c_uint
            && ((*p).i + 1 as libc::c_int) < (*p).mx
            && *((*p).z).offset((*p).i as isize) as libc::c_int & 0xc0 as libc::c_int
                == 0x80 as libc::c_int
            && *((*p).z).offset(((*p).i + 1 as libc::c_int) as isize) as libc::c_int
                & 0xc0 as libc::c_int == 0x80 as libc::c_int
        {
            c = (c & 0xf as libc::c_int as libc::c_uint) << 12 as libc::c_int
                | ((*((*p).z).offset((*p).i as isize) as libc::c_int
                    & 0x3f as libc::c_int) << 6 as libc::c_int) as libc::c_uint
                | (*((*p).z).offset(((*p).i + 1 as libc::c_int) as isize) as libc::c_int
                    & 0x3f as libc::c_int) as libc::c_uint;
            (*p).i += 2 as libc::c_int;
            if c <= 0x7ff as libc::c_int as libc::c_uint
                || c >= 0xd800 as libc::c_int as libc::c_uint
                    && c <= 0xdfff as libc::c_int as libc::c_uint
            {
                c = 0xfffd as libc::c_int as libc::c_uint;
            }
        } else if c & 0xf8 as libc::c_int as libc::c_uint
            == 0xf0 as libc::c_int as libc::c_uint
            && ((*p).i + 2 as libc::c_int) < (*p).mx
            && *((*p).z).offset((*p).i as isize) as libc::c_int & 0xc0 as libc::c_int
                == 0x80 as libc::c_int
            && *((*p).z).offset(((*p).i + 1 as libc::c_int) as isize) as libc::c_int
                & 0xc0 as libc::c_int == 0x80 as libc::c_int
            && *((*p).z).offset(((*p).i + 2 as libc::c_int) as isize) as libc::c_int
                & 0xc0 as libc::c_int == 0x80 as libc::c_int
        {
            c = (c & 0x7 as libc::c_int as libc::c_uint) << 18 as libc::c_int
                | ((*((*p).z).offset((*p).i as isize) as libc::c_int
                    & 0x3f as libc::c_int) << 12 as libc::c_int) as libc::c_uint
                | ((*((*p).z).offset(((*p).i + 1 as libc::c_int) as isize) as libc::c_int
                    & 0x3f as libc::c_int) << 6 as libc::c_int) as libc::c_uint
                | (*((*p).z).offset(((*p).i + 2 as libc::c_int) as isize) as libc::c_int
                    & 0x3f as libc::c_int) as libc::c_uint;
            (*p).i += 3 as libc::c_int;
            if c <= 0xffff as libc::c_int as libc::c_uint
                || c > 0x10ffff as libc::c_int as libc::c_uint
            {
                c = 0xfffd as libc::c_int as libc::c_uint;
            }
        } else {
            c = 0xfffd as libc::c_int as libc::c_uint;
        }
    }
    return c;
}
unsafe extern "C" fn re_next_char_nocase(mut p: *mut ReInput) -> libc::c_uint {
    let mut c: libc::c_uint = re_next_char(p);
    if c >= 'A' as i32 as libc::c_uint && c <= 'Z' as i32 as libc::c_uint {
        c = c.wrapping_add(('a' as i32 - 'A' as i32) as libc::c_uint);
    }
    return c;
}
unsafe extern "C" fn re_word_char(mut c: libc::c_int) -> libc::c_int {
    return (c >= '0' as i32 && c <= '9' as i32 || c >= 'a' as i32 && c <= 'z' as i32
        || c >= 'A' as i32 && c <= 'Z' as i32 || c == '_' as i32) as libc::c_int;
}
unsafe extern "C" fn re_digit_char(mut c: libc::c_int) -> libc::c_int {
    return (c >= '0' as i32 && c <= '9' as i32) as libc::c_int;
}
unsafe extern "C" fn re_space_char(mut c: libc::c_int) -> libc::c_int {
    return (c == ' ' as i32 || c == '\t' as i32 || c == '\n' as i32 || c == '\r' as i32
        || c == '\u{b}' as i32 || c == '\u{c}' as i32) as libc::c_int;
}
unsafe extern "C" fn sqlite3re_match(
    mut pRe: *mut ReCompiled,
    mut zIn: *const libc::c_uchar,
    mut nIn: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut aStateSet: [ReStateSet; 2] = [ReStateSet {
        nState: 0,
        aState: 0 as *mut ReStateNumber,
    }; 2];
    let mut pThis: *mut ReStateSet = 0 as *mut ReStateSet;
    let mut pNext: *mut ReStateSet = 0 as *mut ReStateSet;
    let mut aSpace: [ReStateNumber; 100] = [0; 100];
    let mut pToFree: *mut ReStateNumber = 0 as *mut ReStateNumber;
    let mut i: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut iSwap: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut c: libc::c_int = 0xfffffff as libc::c_int;
    let mut cPrev: libc::c_int = 0 as libc::c_int;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut in_0: ReInput = ReInput {
        z: 0 as *const libc::c_uchar,
        i: 0,
        mx: 0,
    };
    in_0.z = zIn;
    in_0.i = 0 as libc::c_int;
    in_0
        .mx = if nIn >= 0 as libc::c_int {
        nIn
    } else {
        strlen(zIn as *const libc::c_char) as libc::c_int
    };
    if (*pRe).nInit != 0 {
        let mut x: libc::c_uchar = (*pRe).zInit[0 as libc::c_int as usize];
        while in_0.i + (*pRe).nInit <= in_0.mx
            && (*zIn.offset(in_0.i as isize) as libc::c_int != x as libc::c_int
                || strncmp(
                    (zIn as *const libc::c_char).offset(in_0.i as isize),
                    ((*pRe).zInit).as_mut_ptr() as *const libc::c_char,
                    (*pRe).nInit as libc::c_ulong,
                ) != 0 as libc::c_int)
        {
            in_0.i += 1;
        }
        if in_0.i + (*pRe).nInit > in_0.mx {
            return 0 as libc::c_int;
        }
        c = 0xfffffff as libc::c_int - 1 as libc::c_int;
    }
    if (*pRe).nState as libc::c_ulong
        <= (::std::mem::size_of::<[ReStateNumber; 100]>() as libc::c_ulong)
            .wrapping_div(
                (::std::mem::size_of::<ReStateNumber>() as libc::c_ulong)
                    .wrapping_mul(2 as libc::c_int as libc::c_ulong),
            )
    {
        pToFree = 0 as *mut ReStateNumber;
        aStateSet[0 as libc::c_int as usize].aState = aSpace.as_mut_ptr();
    } else {
        pToFree = sqlite3_malloc64(
            (::std::mem::size_of::<ReStateNumber>() as libc::c_ulong)
                .wrapping_mul(2 as libc::c_int as libc::c_ulong)
                .wrapping_mul((*pRe).nState as libc::c_ulong) as sqlite3_uint64,
        ) as *mut ReStateNumber;
        if pToFree.is_null() {
            return -(1 as libc::c_int);
        }
        aStateSet[0 as libc::c_int as usize].aState = pToFree;
    }
    aStateSet[1 as libc::c_int as usize]
        .aState = &mut *((*aStateSet.as_mut_ptr().offset(0 as libc::c_int as isize))
        .aState)
        .offset((*pRe).nState as isize) as *mut ReStateNumber;
    pNext = &mut *aStateSet.as_mut_ptr().offset(1 as libc::c_int as isize)
        as *mut ReStateSet;
    (*pNext).nState = 0 as libc::c_int as libc::c_uint;
    re_add_state(pNext, 0 as libc::c_int);
    's_136: loop {
        if !(c != 0 as libc::c_int && (*pNext).nState > 0 as libc::c_int as libc::c_uint)
        {
            current_block = 4691324637564808323;
            break;
        }
        cPrev = c;
        c = ((*pRe).xNextChar).expect("non-null function pointer")(&mut in_0)
            as libc::c_int;
        pThis = pNext;
        pNext = &mut *aStateSet.as_mut_ptr().offset(iSwap as isize) as *mut ReStateSet;
        iSwap = (1 as libc::c_int as libc::c_uint).wrapping_sub(iSwap);
        (*pNext).nState = 0 as libc::c_int as libc::c_uint;
        i = 0 as libc::c_int as libc::c_uint;
        while i < (*pThis).nState {
            let mut x_0: libc::c_int = *((*pThis).aState).offset(i as isize)
                as libc::c_int;
            match *((*pRe).aOp).offset(x_0 as isize) as libc::c_int {
                1 => {
                    if *((*pRe).aArg).offset(x_0 as isize) == c {
                        re_add_state(pNext, x_0 + 1 as libc::c_int);
                    }
                    current_block = 8704759739624374314;
                }
                18 => {
                    if cPrev == 0xfffffff as libc::c_int {
                        re_add_state(pThis, x_0 + 1 as libc::c_int);
                    }
                    current_block = 8704759739624374314;
                }
                2 => {
                    if c != 0 as libc::c_int {
                        re_add_state(pNext, x_0 + 1 as libc::c_int);
                    }
                    current_block = 8704759739624374314;
                }
                11 => {
                    if re_word_char(c) != 0 {
                        re_add_state(pNext, x_0 + 1 as libc::c_int);
                    }
                    current_block = 8704759739624374314;
                }
                12 => {
                    if re_word_char(c) == 0 && c != 0 as libc::c_int {
                        re_add_state(pNext, x_0 + 1 as libc::c_int);
                    }
                    current_block = 8704759739624374314;
                }
                13 => {
                    if re_digit_char(c) != 0 {
                        re_add_state(pNext, x_0 + 1 as libc::c_int);
                    }
                    current_block = 8704759739624374314;
                }
                14 => {
                    if re_digit_char(c) == 0 && c != 0 as libc::c_int {
                        re_add_state(pNext, x_0 + 1 as libc::c_int);
                    }
                    current_block = 8704759739624374314;
                }
                15 => {
                    if re_space_char(c) != 0 {
                        re_add_state(pNext, x_0 + 1 as libc::c_int);
                    }
                    current_block = 8704759739624374314;
                }
                16 => {
                    if re_space_char(c) == 0 && c != 0 as libc::c_int {
                        re_add_state(pNext, x_0 + 1 as libc::c_int);
                    }
                    current_block = 8704759739624374314;
                }
                17 => {
                    if re_word_char(c) != re_word_char(cPrev) {
                        re_add_state(pThis, x_0 + 1 as libc::c_int);
                    }
                    current_block = 8704759739624374314;
                }
                3 => {
                    re_add_state(pNext, x_0);
                    re_add_state(pThis, x_0 + 1 as libc::c_int);
                    current_block = 8704759739624374314;
                }
                4 => {
                    re_add_state(pThis, x_0 + *((*pRe).aArg).offset(x_0 as isize));
                    re_add_state(pThis, x_0 + 1 as libc::c_int);
                    current_block = 8704759739624374314;
                }
                5 => {
                    re_add_state(pThis, x_0 + *((*pRe).aArg).offset(x_0 as isize));
                    current_block = 8704759739624374314;
                }
                6 => {
                    rc = 1 as libc::c_int;
                    current_block = 9177663572014039438;
                    break 's_136;
                }
                8 => {
                    if c == 0 as libc::c_int {
                        current_block = 8704759739624374314;
                    } else {
                        current_block = 479107131381816815;
                    }
                }
                7 => {
                    current_block = 479107131381816815;
                }
                _ => {
                    current_block = 8704759739624374314;
                }
            }
            match current_block {
                479107131381816815 => {
                    let mut j: libc::c_int = 1 as libc::c_int;
                    let mut n: libc::c_int = *((*pRe).aArg).offset(x_0 as isize);
                    let mut hit: libc::c_int = 0 as libc::c_int;
                    j = 1 as libc::c_int;
                    while j > 0 as libc::c_int && j < n {
                        if *((*pRe).aOp).offset((x_0 + j) as isize) as libc::c_int
                            == 9 as libc::c_int
                        {
                            if *((*pRe).aArg).offset((x_0 + j) as isize) == c {
                                hit = 1 as libc::c_int;
                                j = -(1 as libc::c_int);
                            }
                        } else if *((*pRe).aArg).offset((x_0 + j) as isize) <= c
                            && *((*pRe).aArg)
                                .offset((x_0 + j + 1 as libc::c_int) as isize) >= c
                        {
                            hit = 1 as libc::c_int;
                            j = -(1 as libc::c_int);
                        } else {
                            j += 1;
                        }
                        j += 1;
                    }
                    if *((*pRe).aOp).offset(x_0 as isize) as libc::c_int
                        == 8 as libc::c_int
                    {
                        hit = (hit == 0) as libc::c_int;
                    }
                    if hit != 0 {
                        re_add_state(pNext, x_0 + n);
                    }
                }
                _ => {}
            }
            i = i.wrapping_add(1);
        }
    }
    match current_block {
        4691324637564808323 => {
            i = 0 as libc::c_int as libc::c_uint;
            while i < (*pNext).nState {
                let mut x_1: libc::c_int = *((*pNext).aState).offset(i as isize)
                    as libc::c_int;
                while *((*pRe).aOp).offset(x_1 as isize) as libc::c_int
                    == 5 as libc::c_int
                {
                    x_1 += *((*pRe).aArg).offset(x_1 as isize);
                }
                if *((*pRe).aOp).offset(x_1 as isize) as libc::c_int == 6 as libc::c_int
                {
                    rc = 1 as libc::c_int;
                    break;
                } else {
                    i = i.wrapping_add(1);
                }
            }
        }
        _ => {}
    }
    sqlite3_free(pToFree as *mut libc::c_void);
    return rc;
}
unsafe extern "C" fn re_resize(
    mut p: *mut ReCompiled,
    mut N: libc::c_int,
) -> libc::c_int {
    let mut aOp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut aArg: *mut libc::c_int = 0 as *mut libc::c_int;
    aOp = sqlite3_realloc64(
        (*p).aOp as *mut libc::c_void,
        (N as libc::c_ulong)
            .wrapping_mul(::std::mem::size_of::<libc::c_char>() as libc::c_ulong)
            as sqlite3_uint64,
    ) as *mut libc::c_char;
    if aOp.is_null() {
        return 1 as libc::c_int;
    }
    let ref mut fresh46 = (*p).aOp;
    *fresh46 = aOp;
    aArg = sqlite3_realloc64(
        (*p).aArg as *mut libc::c_void,
        (N as libc::c_ulong)
            .wrapping_mul(::std::mem::size_of::<libc::c_int>() as libc::c_ulong)
            as sqlite3_uint64,
    ) as *mut libc::c_int;
    if aArg.is_null() {
        return 1 as libc::c_int;
    }
    let ref mut fresh47 = (*p).aArg;
    *fresh47 = aArg;
    (*p).nAlloc = N as libc::c_uint;
    return 0 as libc::c_int;
}
unsafe extern "C" fn re_insert(
    mut p: *mut ReCompiled,
    mut iBefore: libc::c_int,
    mut op: libc::c_int,
    mut arg: libc::c_int,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    if (*p).nAlloc <= (*p).nState
        && re_resize(
            p,
            ((*p).nAlloc).wrapping_mul(2 as libc::c_int as libc::c_uint) as libc::c_int,
        ) != 0
    {
        return 0 as libc::c_int;
    }
    i = (*p).nState as libc::c_int;
    while i > iBefore {
        *((*p).aOp)
            .offset(i as isize) = *((*p).aOp).offset((i - 1 as libc::c_int) as isize);
        *((*p).aArg)
            .offset(i as isize) = *((*p).aArg).offset((i - 1 as libc::c_int) as isize);
        i -= 1;
    }
    let ref mut fresh48 = (*p).nState;
    *fresh48 = (*fresh48).wrapping_add(1);
    *((*p).aOp).offset(iBefore as isize) = op as libc::c_char;
    *((*p).aArg).offset(iBefore as isize) = arg;
    return iBefore;
}
unsafe extern "C" fn re_append(
    mut p: *mut ReCompiled,
    mut op: libc::c_int,
    mut arg: libc::c_int,
) -> libc::c_int {
    return re_insert(p, (*p).nState as libc::c_int, op, arg);
}
unsafe extern "C" fn re_copy(
    mut p: *mut ReCompiled,
    mut iStart: libc::c_int,
    mut N: libc::c_int,
) {
    if ((*p).nState).wrapping_add(N as libc::c_uint) >= (*p).nAlloc
        && re_resize(
            p,
            ((*p).nAlloc)
                .wrapping_mul(2 as libc::c_int as libc::c_uint)
                .wrapping_add(N as libc::c_uint) as libc::c_int,
        ) != 0
    {
        return;
    }
    memcpy(
        &mut *((*p).aOp).offset((*p).nState as isize) as *mut libc::c_char
            as *mut libc::c_void,
        &mut *((*p).aOp).offset(iStart as isize) as *mut libc::c_char
            as *const libc::c_void,
        (N as libc::c_ulong)
            .wrapping_mul(::std::mem::size_of::<libc::c_char>() as libc::c_ulong),
    );
    memcpy(
        &mut *((*p).aArg).offset((*p).nState as isize) as *mut libc::c_int
            as *mut libc::c_void,
        &mut *((*p).aArg).offset(iStart as isize) as *mut libc::c_int
            as *const libc::c_void,
        (N as libc::c_ulong)
            .wrapping_mul(::std::mem::size_of::<libc::c_int>() as libc::c_ulong),
    );
    let ref mut fresh49 = (*p).nState;
    *fresh49 = (*fresh49).wrapping_add(N as libc::c_uint);
}
unsafe extern "C" fn re_hex(
    mut c: libc::c_int,
    mut pV: *mut libc::c_int,
) -> libc::c_int {
    if c >= '0' as i32 && c <= '9' as i32 {
        c -= '0' as i32;
    } else if c >= 'a' as i32 && c <= 'f' as i32 {
        c -= 'a' as i32 - 10 as libc::c_int;
    } else if c >= 'A' as i32 && c <= 'F' as i32 {
        c -= 'A' as i32 - 10 as libc::c_int;
    } else {
        return 0 as libc::c_int
    }
    *pV = *pV * 16 as libc::c_int + (c & 0xff as libc::c_int);
    return 1 as libc::c_int;
}
unsafe extern "C" fn re_esc_char(mut p: *mut ReCompiled) -> libc::c_uint {
    static mut zEsc: [libc::c_char; 21] = unsafe {
        *::std::mem::transmute::<
            &[u8; 21],
            &[libc::c_char; 21],
        >(b"afnrtv\\()*.+?[$^{|}]\0")
    };
    static mut zTrans: [libc::c_char; 7] = unsafe {
        *::std::mem::transmute::<&[u8; 7], &[libc::c_char; 7]>(b"\x07\x0C\n\r\t\x0B\0")
    };
    let mut i: libc::c_int = 0;
    let mut v: libc::c_int = 0 as libc::c_int;
    let mut c: libc::c_char = 0;
    if (*p).sIn.i >= (*p).sIn.mx {
        return 0 as libc::c_int as libc::c_uint;
    }
    c = *((*p).sIn.z).offset((*p).sIn.i as isize) as libc::c_char;
    if c as libc::c_int == 'u' as i32 && ((*p).sIn.i + 4 as libc::c_int) < (*p).sIn.mx {
        let mut zIn: *const libc::c_uchar = ((*p).sIn.z).offset((*p).sIn.i as isize);
        if re_hex(*zIn.offset(1 as libc::c_int as isize) as libc::c_int, &mut v) != 0
            && re_hex(*zIn.offset(2 as libc::c_int as isize) as libc::c_int, &mut v) != 0
            && re_hex(*zIn.offset(3 as libc::c_int as isize) as libc::c_int, &mut v) != 0
            && re_hex(*zIn.offset(4 as libc::c_int as isize) as libc::c_int, &mut v) != 0
        {
            (*p).sIn.i += 5 as libc::c_int;
            return v as libc::c_uint;
        }
    }
    if c as libc::c_int == 'x' as i32 && ((*p).sIn.i + 2 as libc::c_int) < (*p).sIn.mx {
        let mut zIn_0: *const libc::c_uchar = ((*p).sIn.z).offset((*p).sIn.i as isize);
        if re_hex(*zIn_0.offset(1 as libc::c_int as isize) as libc::c_int, &mut v) != 0
            && re_hex(*zIn_0.offset(2 as libc::c_int as isize) as libc::c_int, &mut v)
                != 0
        {
            (*p).sIn.i += 3 as libc::c_int;
            return v as libc::c_uint;
        }
    }
    i = 0 as libc::c_int;
    while zEsc[i as usize] as libc::c_int != 0
        && zEsc[i as usize] as libc::c_int != c as libc::c_int
    {
        i += 1;
    }
    if zEsc[i as usize] != 0 {
        if i < 6 as libc::c_int {
            c = zTrans[i as usize];
        }
        let ref mut fresh50 = (*p).sIn.i;
        *fresh50 += 1;
    } else {
        let ref mut fresh51 = (*p).zErr;
        *fresh51 = b"unknown \\ escape\0" as *const u8 as *const libc::c_char;
    }
    return c as libc::c_uint;
}
unsafe extern "C" fn rePeek(mut p: *mut ReCompiled) -> libc::c_uchar {
    return (if (*p).sIn.i < (*p).sIn.mx {
        *((*p).sIn.z).offset((*p).sIn.i as isize) as libc::c_int
    } else {
        0 as libc::c_int
    }) as libc::c_uchar;
}
unsafe extern "C" fn re_subcompile_re(mut p: *mut ReCompiled) -> *const libc::c_char {
    let mut zErr: *const libc::c_char = 0 as *const libc::c_char;
    let mut iStart: libc::c_int = 0;
    let mut iEnd: libc::c_int = 0;
    let mut iGoto: libc::c_int = 0;
    iStart = (*p).nState as libc::c_int;
    zErr = re_subcompile_string(p);
    if !zErr.is_null() {
        return zErr;
    }
    while rePeek(p) as libc::c_int == '|' as i32 {
        iEnd = (*p).nState as libc::c_int;
        re_insert(p, iStart, 4 as libc::c_int, iEnd + 2 as libc::c_int - iStart);
        iGoto = re_append(p, 5 as libc::c_int, 0 as libc::c_int);
        let ref mut fresh52 = (*p).sIn.i;
        *fresh52 += 1;
        zErr = re_subcompile_string(p);
        if !zErr.is_null() {
            return zErr;
        }
        *((*p).aArg)
            .offset(
                iGoto as isize,
            ) = ((*p).nState).wrapping_sub(iGoto as libc::c_uint) as libc::c_int;
    }
    return 0 as *const libc::c_char;
}
unsafe extern "C" fn re_subcompile_string(
    mut p: *mut ReCompiled,
) -> *const libc::c_char {
    let mut iPrev: libc::c_int = -(1 as libc::c_int);
    let mut iStart: libc::c_int = 0;
    let mut c: libc::c_uint = 0;
    let mut zErr: *const libc::c_char = 0 as *const libc::c_char;
    loop {
        c = ((*p).xNextChar).expect("non-null function pointer")(&mut (*p).sIn);
        if !(c != 0 as libc::c_int as libc::c_uint) {
            break;
        }
        iStart = (*p).nState as libc::c_int;
        match c {
            124 | 41 => {
                let ref mut fresh53 = (*p).sIn.i;
                *fresh53 -= 1;
                return 0 as *const libc::c_char;
            }
            40 => {
                zErr = re_subcompile_re(p);
                if !zErr.is_null() {
                    return zErr;
                }
                if rePeek(p) as libc::c_int != ')' as i32 {
                    return b"unmatched '('\0" as *const u8 as *const libc::c_char;
                }
                let ref mut fresh54 = (*p).sIn.i;
                *fresh54 += 1;
            }
            46 => {
                if rePeek(p) as libc::c_int == '*' as i32 {
                    re_append(p, 3 as libc::c_int, 0 as libc::c_int);
                    let ref mut fresh55 = (*p).sIn.i;
                    *fresh55 += 1;
                } else {
                    re_append(p, 2 as libc::c_int, 0 as libc::c_int);
                }
            }
            42 => {
                if iPrev < 0 as libc::c_int {
                    return b"'*' without operand\0" as *const u8 as *const libc::c_char;
                }
                re_insert(
                    p,
                    iPrev,
                    5 as libc::c_int,
                    ((*p).nState)
                        .wrapping_sub(iPrev as libc::c_uint)
                        .wrapping_add(1 as libc::c_int as libc::c_uint) as libc::c_int,
                );
                re_append(
                    p,
                    4 as libc::c_int,
                    (iPrev as libc::c_uint)
                        .wrapping_sub((*p).nState)
                        .wrapping_add(1 as libc::c_int as libc::c_uint) as libc::c_int,
                );
            }
            43 => {
                if iPrev < 0 as libc::c_int {
                    return b"'+' without operand\0" as *const u8 as *const libc::c_char;
                }
                re_append(
                    p,
                    4 as libc::c_int,
                    (iPrev as libc::c_uint).wrapping_sub((*p).nState) as libc::c_int,
                );
            }
            63 => {
                if iPrev < 0 as libc::c_int {
                    return b"'?' without operand\0" as *const u8 as *const libc::c_char;
                }
                re_insert(
                    p,
                    iPrev,
                    4 as libc::c_int,
                    ((*p).nState)
                        .wrapping_sub(iPrev as libc::c_uint)
                        .wrapping_add(1 as libc::c_int as libc::c_uint) as libc::c_int,
                );
            }
            36 => {
                re_append(p, 1 as libc::c_int, 0 as libc::c_int);
            }
            94 => {
                re_append(p, 18 as libc::c_int, 0 as libc::c_int);
            }
            123 => {
                let mut m: libc::c_int = 0 as libc::c_int;
                let mut n: libc::c_int = 0 as libc::c_int;
                let mut sz: libc::c_int = 0;
                let mut j: libc::c_int = 0;
                if iPrev < 0 as libc::c_int {
                    return b"'{m,n}' without operand\0" as *const u8
                        as *const libc::c_char;
                }
                loop {
                    c = rePeek(p) as libc::c_uint;
                    if !(c >= '0' as i32 as libc::c_uint
                        && c <= '9' as i32 as libc::c_uint)
                    {
                        break;
                    }
                    m = ((m * 10 as libc::c_int) as libc::c_uint)
                        .wrapping_add(c)
                        .wrapping_sub('0' as i32 as libc::c_uint) as libc::c_int;
                    let ref mut fresh56 = (*p).sIn.i;
                    *fresh56 += 1;
                }
                n = m;
                if c == ',' as i32 as libc::c_uint {
                    let ref mut fresh57 = (*p).sIn.i;
                    *fresh57 += 1;
                    n = 0 as libc::c_int;
                    loop {
                        c = rePeek(p) as libc::c_uint;
                        if !(c >= '0' as i32 as libc::c_uint
                            && c <= '9' as i32 as libc::c_uint)
                        {
                            break;
                        }
                        n = ((n * 10 as libc::c_int) as libc::c_uint)
                            .wrapping_add(c)
                            .wrapping_sub('0' as i32 as libc::c_uint) as libc::c_int;
                        let ref mut fresh58 = (*p).sIn.i;
                        *fresh58 += 1;
                    }
                }
                if c != '}' as i32 as libc::c_uint {
                    return b"unmatched '{'\0" as *const u8 as *const libc::c_char;
                }
                if n > 0 as libc::c_int && n < m {
                    return b"n less than m in '{m,n}'\0" as *const u8
                        as *const libc::c_char;
                }
                let ref mut fresh59 = (*p).sIn.i;
                *fresh59 += 1;
                sz = ((*p).nState).wrapping_sub(iPrev as libc::c_uint) as libc::c_int;
                if m == 0 as libc::c_int {
                    if n == 0 as libc::c_int {
                        return b"both m and n are zero in '{m,n}'\0" as *const u8
                            as *const libc::c_char;
                    }
                    re_insert(p, iPrev, 4 as libc::c_int, sz + 1 as libc::c_int);
                    iPrev += 1;
                    n -= 1;
                } else {
                    j = 1 as libc::c_int;
                    while j < m {
                        re_copy(p, iPrev, sz);
                        j += 1;
                    }
                }
                j = m;
                while j < n {
                    re_append(p, 4 as libc::c_int, sz + 1 as libc::c_int);
                    re_copy(p, iPrev, sz);
                    j += 1;
                }
                if n == 0 as libc::c_int && m > 0 as libc::c_int {
                    re_append(p, 4 as libc::c_int, -sz);
                }
            }
            91 => {
                let mut iFirst: libc::c_int = (*p).nState as libc::c_int;
                if rePeek(p) as libc::c_int == '^' as i32 {
                    re_append(p, 8 as libc::c_int, 0 as libc::c_int);
                    let ref mut fresh60 = (*p).sIn.i;
                    *fresh60 += 1;
                } else {
                    re_append(p, 7 as libc::c_int, 0 as libc::c_int);
                }
                loop {
                    c = ((*p).xNextChar)
                        .expect("non-null function pointer")(&mut (*p).sIn);
                    if !(c != 0 as libc::c_int as libc::c_uint) {
                        break;
                    }
                    if c == '[' as i32 as libc::c_uint
                        && rePeek(p) as libc::c_int == ':' as i32
                    {
                        return b"POSIX character classes not supported\0" as *const u8
                            as *const libc::c_char;
                    }
                    if c == '\\' as i32 as libc::c_uint {
                        c = re_esc_char(p);
                    }
                    if rePeek(p) as libc::c_int == '-' as i32 {
                        re_append(p, 10 as libc::c_int, c as libc::c_int);
                        let ref mut fresh61 = (*p).sIn.i;
                        *fresh61 += 1;
                        c = ((*p).xNextChar)
                            .expect("non-null function pointer")(&mut (*p).sIn);
                        if c == '\\' as i32 as libc::c_uint {
                            c = re_esc_char(p);
                        }
                        re_append(p, 10 as libc::c_int, c as libc::c_int);
                    } else {
                        re_append(p, 9 as libc::c_int, c as libc::c_int);
                    }
                    if !(rePeek(p) as libc::c_int == ']' as i32) {
                        continue;
                    }
                    let ref mut fresh62 = (*p).sIn.i;
                    *fresh62 += 1;
                    break;
                }
                if c == 0 as libc::c_int as libc::c_uint {
                    return b"unclosed '['\0" as *const u8 as *const libc::c_char;
                }
                *((*p).aArg)
                    .offset(
                        iFirst as isize,
                    ) = ((*p).nState).wrapping_sub(iFirst as libc::c_uint)
                    as libc::c_int;
            }
            92 => {
                let mut specialOp: libc::c_int = 0 as libc::c_int;
                match rePeek(p) as libc::c_int {
                    98 => {
                        specialOp = 17 as libc::c_int;
                    }
                    100 => {
                        specialOp = 13 as libc::c_int;
                    }
                    68 => {
                        specialOp = 14 as libc::c_int;
                    }
                    115 => {
                        specialOp = 15 as libc::c_int;
                    }
                    83 => {
                        specialOp = 16 as libc::c_int;
                    }
                    119 => {
                        specialOp = 11 as libc::c_int;
                    }
                    87 => {
                        specialOp = 12 as libc::c_int;
                    }
                    _ => {}
                }
                if specialOp != 0 {
                    let ref mut fresh63 = (*p).sIn.i;
                    *fresh63 += 1;
                    re_append(p, specialOp, 0 as libc::c_int);
                } else {
                    c = re_esc_char(p);
                    re_append(p, 1 as libc::c_int, c as libc::c_int);
                }
            }
            _ => {
                re_append(p, 1 as libc::c_int, c as libc::c_int);
            }
        }
        iPrev = iStart;
    }
    return 0 as *const libc::c_char;
}
unsafe extern "C" fn sqlite3re_free(mut pRe: *mut ReCompiled) {
    if !pRe.is_null() {
        sqlite3_free((*pRe).aOp as *mut libc::c_void);
        sqlite3_free((*pRe).aArg as *mut libc::c_void);
        sqlite3_free(pRe as *mut libc::c_void);
    }
}
unsafe extern "C" fn sqlite3re_compile(
    mut ppRe: *mut *mut ReCompiled,
    mut zIn: *const libc::c_char,
    mut noCase: libc::c_int,
) -> *const libc::c_char {
    let mut pRe: *mut ReCompiled = 0 as *mut ReCompiled;
    let mut zErr: *const libc::c_char = 0 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    *ppRe = 0 as *mut ReCompiled;
    pRe = sqlite3_malloc(
        ::std::mem::size_of::<ReCompiled>() as libc::c_ulong as libc::c_int,
    ) as *mut ReCompiled;
    if pRe.is_null() {
        return b"out of memory\0" as *const u8 as *const libc::c_char;
    }
    memset(
        pRe as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<ReCompiled>() as libc::c_ulong,
    );
    let ref mut fresh64 = (*pRe).xNextChar;
    *fresh64 = if noCase != 0 {
        Some(re_next_char_nocase as unsafe extern "C" fn(*mut ReInput) -> libc::c_uint)
    } else {
        Some(re_next_char as unsafe extern "C" fn(*mut ReInput) -> libc::c_uint)
    };
    if re_resize(pRe, 30 as libc::c_int) != 0 {
        sqlite3re_free(pRe);
        return b"out of memory\0" as *const u8 as *const libc::c_char;
    }
    if *zIn.offset(0 as libc::c_int as isize) as libc::c_int == '^' as i32 {
        zIn = zIn.offset(1);
    } else {
        re_append(pRe, 3 as libc::c_int, 0 as libc::c_int);
    }
    let ref mut fresh65 = (*pRe).sIn.z;
    *fresh65 = zIn as *mut libc::c_uchar;
    (*pRe).sIn.i = 0 as libc::c_int;
    (*pRe).sIn.mx = strlen(zIn) as libc::c_int;
    zErr = re_subcompile_re(pRe);
    if !zErr.is_null() {
        sqlite3re_free(pRe);
        return zErr;
    }
    if (*pRe).sIn.i >= (*pRe).sIn.mx {
        re_append(pRe, 6 as libc::c_int, 0 as libc::c_int);
        *ppRe = pRe;
    } else {
        sqlite3re_free(pRe);
        return b"unrecognized character\0" as *const u8 as *const libc::c_char;
    }
    if *((*pRe).aOp).offset(0 as libc::c_int as isize) as libc::c_int == 3 as libc::c_int
        && noCase == 0
    {
        j = 0 as libc::c_int;
        i = 1 as libc::c_int;
        while j
            < ::std::mem::size_of::<[libc::c_uchar; 12]>() as libc::c_ulong
                as libc::c_int - 2 as libc::c_int
            && *((*pRe).aOp).offset(i as isize) as libc::c_int == 1 as libc::c_int
        {
            let mut x: libc::c_uint = *((*pRe).aArg).offset(i as isize) as libc::c_uint;
            if x <= 0x7f as libc::c_int as libc::c_uint {
                let fresh66 = j;
                j = j + 1;
                (*pRe).zInit[fresh66 as usize] = x as libc::c_uchar;
            } else if x <= 0x7ff as libc::c_int as libc::c_uint {
                let fresh67 = j;
                j = j + 1;
                (*pRe)
                    .zInit[fresh67
                    as usize] = (0xc0 as libc::c_int as libc::c_uint
                    | x >> 6 as libc::c_int) as libc::c_uchar;
                let fresh68 = j;
                j = j + 1;
                (*pRe)
                    .zInit[fresh68
                    as usize] = (0x80 as libc::c_int as libc::c_uint
                    | x & 0x3f as libc::c_int as libc::c_uint) as libc::c_uchar;
            } else {
                if !(x <= 0xffff as libc::c_int as libc::c_uint) {
                    break;
                }
                let fresh69 = j;
                j = j + 1;
                (*pRe)
                    .zInit[fresh69
                    as usize] = (0xe0 as libc::c_int as libc::c_uint
                    | x >> 12 as libc::c_int) as libc::c_uchar;
                let fresh70 = j;
                j = j + 1;
                (*pRe)
                    .zInit[fresh70
                    as usize] = (0x80 as libc::c_int as libc::c_uint
                    | x >> 6 as libc::c_int & 0x3f as libc::c_int as libc::c_uint)
                    as libc::c_uchar;
                let fresh71 = j;
                j = j + 1;
                (*pRe)
                    .zInit[fresh71
                    as usize] = (0x80 as libc::c_int as libc::c_uint
                    | x & 0x3f as libc::c_int as libc::c_uint) as libc::c_uchar;
            }
            i += 1;
        }
        if j > 0 as libc::c_int
            && (*pRe).zInit[(j - 1 as libc::c_int) as usize] as libc::c_int
                == 0 as libc::c_int
        {
            j -= 1;
        }
        (*pRe).nInit = j;
    }
    return (*pRe).zErr;
}
unsafe extern "C" fn re_sql_func(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut pRe: *mut ReCompiled = 0 as *mut ReCompiled;
    let mut zPattern: *const libc::c_char = 0 as *const libc::c_char;
    let mut zStr: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut zErr: *const libc::c_char = 0 as *const libc::c_char;
    let mut setAux: libc::c_int = 0 as libc::c_int;
    pRe = sqlite3_get_auxdata(context, 0 as libc::c_int) as *mut ReCompiled;
    if pRe.is_null() {
        zPattern = sqlite3_value_text(*argv.offset(0 as libc::c_int as isize))
            as *const libc::c_char;
        if zPattern.is_null() {
            return;
        }
        zErr = sqlite3re_compile(
            &mut pRe,
            zPattern,
            (sqlite3_user_data(context) != 0 as *mut libc::c_void) as libc::c_int,
        );
        if !zErr.is_null() {
            sqlite3re_free(pRe);
            sqlite3_result_error(context, zErr, -(1 as libc::c_int));
            return;
        }
        if pRe.is_null() {
            sqlite3_result_error_nomem(context);
            return;
        }
        setAux = 1 as libc::c_int;
    }
    zStr = sqlite3_value_text(*argv.offset(1 as libc::c_int as isize));
    if !zStr.is_null() {
        sqlite3_result_int(context, sqlite3re_match(pRe, zStr, -(1 as libc::c_int)));
    }
    if setAux != 0 {
        sqlite3_set_auxdata(
            context,
            0 as libc::c_int,
            pRe as *mut libc::c_void,
            ::std::mem::transmute::<
                Option::<unsafe extern "C" fn(*mut ReCompiled) -> ()>,
                Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
            >(Some(sqlite3re_free as unsafe extern "C" fn(*mut ReCompiled) -> ())),
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_regexp_init(
    mut db: *mut sqlite3,
    mut pzErrMsg: *mut *mut libc::c_char,
    mut pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    rc = sqlite3_create_function(
        db,
        b"regexp\0" as *const u8 as *const libc::c_char,
        2 as libc::c_int,
        1 as libc::c_int | 0x200000 as libc::c_int | 0x800 as libc::c_int,
        0 as *mut libc::c_void,
        Some(
            re_sql_func
                as unsafe extern "C" fn(
                    *mut sqlite3_context,
                    libc::c_int,
                    *mut *mut sqlite3_value,
                ) -> (),
        ),
        None,
        None,
    );
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_function(
            db,
            b"regexpi\0" as *const u8 as *const libc::c_char,
            2 as libc::c_int,
            1 as libc::c_int | 0x200000 as libc::c_int | 0x800 as libc::c_int,
            db as *mut libc::c_void,
            Some(
                re_sql_func
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
    }
    return rc;
}
unsafe extern "C" fn readFileContents(
    mut ctx: *mut sqlite3_context,
    mut zName: *const libc::c_char,
) {
    let mut in_0: *mut FILE = 0 as *mut FILE;
    let mut nIn: sqlite3_int64 = 0;
    let mut pBuf: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut db: *mut sqlite3 = 0 as *mut sqlite3;
    let mut mxBlob: libc::c_int = 0;
    in_0 = fopen(zName, b"rb\0" as *const u8 as *const libc::c_char);
    if in_0.is_null() {
        return;
    }
    fseek(in_0, 0 as libc::c_int as libc::c_long, 2 as libc::c_int);
    nIn = ftell(in_0) as sqlite3_int64;
    rewind(in_0);
    db = sqlite3_context_db_handle(ctx);
    mxBlob = sqlite3_limit(db, 0 as libc::c_int, -(1 as libc::c_int));
    if nIn > mxBlob as libc::c_longlong {
        sqlite3_result_error_code(ctx, 18 as libc::c_int);
        fclose(in_0);
        return;
    }
    pBuf = sqlite3_malloc64(
        (if nIn != 0 { nIn } else { 1 as libc::c_int as libc::c_longlong })
            as sqlite3_uint64,
    );
    if pBuf.is_null() {
        sqlite3_result_error_nomem(ctx);
        fclose(in_0);
        return;
    }
    if nIn
        == fread(pBuf, 1 as libc::c_int as libc::c_ulong, nIn as size_t, in_0)
            as sqlite3_int64
    {
        sqlite3_result_blob64(
            ctx,
            pBuf,
            nIn as sqlite3_uint64,
            Some(sqlite3_free as unsafe extern "C" fn(*mut libc::c_void) -> ()),
        );
    } else {
        sqlite3_result_error_code(ctx, 10 as libc::c_int);
        sqlite3_free(pBuf);
    }
    fclose(in_0);
}
unsafe extern "C" fn readfileFunc(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut zName: *const libc::c_char = 0 as *const libc::c_char;
    zName = sqlite3_value_text(*argv.offset(0 as libc::c_int as isize))
        as *const libc::c_char;
    if zName.is_null() {
        return;
    }
    readFileContents(context, zName);
}
unsafe extern "C" fn ctxErrorMsg(
    mut ctx: *mut sqlite3_context,
    mut zFmt: *const libc::c_char,
    mut args: ...
) {
    let mut zMsg: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut ap: ::std::ffi::VaListImpl;
    ap = args.clone();
    zMsg = sqlite3_vmprintf(zFmt, ap.as_va_list());
    sqlite3_result_error(ctx, zMsg, -(1 as libc::c_int));
    sqlite3_free(zMsg as *mut libc::c_void);
}
unsafe extern "C" fn fileStat(
    mut zPath: *const libc::c_char,
    mut pStatBuf: *mut stat,
) -> libc::c_int {
    return stat(zPath, pStatBuf);
}
unsafe extern "C" fn fileLinkStat(
    mut zPath: *const libc::c_char,
    mut pStatBuf: *mut stat,
) -> libc::c_int {
    return lstat(zPath, pStatBuf);
}
unsafe extern "C" fn makeDirectory(mut zFile: *const libc::c_char) -> libc::c_int {
    let mut zCopy: *mut libc::c_char = sqlite3_mprintf(
        b"%s\0" as *const u8 as *const libc::c_char,
        zFile,
    );
    let mut rc: libc::c_int = 0 as libc::c_int;
    if zCopy.is_null() {
        rc = 7 as libc::c_int;
    } else {
        let mut nCopy: libc::c_int = strlen(zCopy) as libc::c_int;
        let mut i: libc::c_int = 1 as libc::c_int;
        while rc == 0 as libc::c_int {
            let mut sStat: stat = stat {
                st_dev: 0,
                st_ino: 0,
                st_nlink: 0,
                st_mode: 0,
                st_uid: 0,
                st_gid: 0,
                __pad0: 0,
                st_rdev: 0,
                st_size: 0,
                st_blksize: 0,
                st_blocks: 0,
                st_atim: timespec { tv_sec: 0, tv_nsec: 0 },
                st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },
                st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },
                __glibc_reserved: [0; 3],
            };
            let mut rc2: libc::c_int = 0;
            while *zCopy.offset(i as isize) as libc::c_int != '/' as i32 && i < nCopy {
                i += 1;
            }
            if i == nCopy {
                break;
            }
            *zCopy.offset(i as isize) = '\0' as i32 as libc::c_char;
            rc2 = fileStat(zCopy, &mut sStat);
            if rc2 != 0 as libc::c_int {
                if mkdir(zCopy, 0o777 as libc::c_int as __mode_t) != 0 {
                    rc = 1 as libc::c_int;
                }
            } else if !(sStat.st_mode & 0o170000 as libc::c_int as libc::c_uint
                == 0o40000 as libc::c_int as libc::c_uint)
            {
                rc = 1 as libc::c_int;
            }
            *zCopy.offset(i as isize) = '/' as i32 as libc::c_char;
            i += 1;
        }
        sqlite3_free(zCopy as *mut libc::c_void);
    }
    return rc;
}
unsafe extern "C" fn writeFile(
    mut pCtx: *mut sqlite3_context,
    mut zFile: *const libc::c_char,
    mut pData: *mut sqlite3_value,
    mut mode: mode_t,
    mut mtime: sqlite3_int64,
) -> libc::c_int {
    if zFile.is_null() {
        return 1 as libc::c_int;
    }
    if mode & 0o170000 as libc::c_int as libc::c_uint
        == 0o120000 as libc::c_int as libc::c_uint
    {
        let mut zTo: *const libc::c_char = sqlite3_value_text(pData)
            as *const libc::c_char;
        if zTo.is_null() || symlink(zTo, zFile) < 0 as libc::c_int {
            return 1 as libc::c_int;
        }
    } else if mode & 0o170000 as libc::c_int as libc::c_uint
        == 0o40000 as libc::c_int as libc::c_uint
    {
        if mkdir(zFile, mode) != 0 {
            let mut sStat: stat = stat {
                st_dev: 0,
                st_ino: 0,
                st_nlink: 0,
                st_mode: 0,
                st_uid: 0,
                st_gid: 0,
                __pad0: 0,
                st_rdev: 0,
                st_size: 0,
                st_blksize: 0,
                st_blocks: 0,
                st_atim: timespec { tv_sec: 0, tv_nsec: 0 },
                st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },
                st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },
                __glibc_reserved: [0; 3],
            };
            if *__errno_location() != 17 as libc::c_int
                || 0 as libc::c_int != fileStat(zFile, &mut sStat)
                || !(sStat.st_mode & 0o170000 as libc::c_int as libc::c_uint
                    == 0o40000 as libc::c_int as libc::c_uint)
                || sStat.st_mode & 0o777 as libc::c_int as libc::c_uint
                    != mode & 0o777 as libc::c_int as libc::c_uint
                    && 0 as libc::c_int
                        != chmod(zFile, mode & 0o777 as libc::c_int as libc::c_uint)
            {
                return 1 as libc::c_int;
            }
        }
    } else {
        let mut nWrite: sqlite3_int64 = 0 as libc::c_int as sqlite3_int64;
        let mut z: *const libc::c_char = 0 as *const libc::c_char;
        let mut rc: libc::c_int = 0 as libc::c_int;
        let mut out: *mut FILE = fopen(
            zFile,
            b"wb\0" as *const u8 as *const libc::c_char,
        );
        if out.is_null() {
            return 1 as libc::c_int;
        }
        z = sqlite3_value_blob(pData) as *const libc::c_char;
        if !z.is_null() {
            let mut n: sqlite3_int64 = fwrite(
                z as *const libc::c_void,
                1 as libc::c_int as libc::c_ulong,
                sqlite3_value_bytes(pData) as libc::c_ulong,
                out,
            ) as sqlite3_int64;
            nWrite = sqlite3_value_bytes(pData) as sqlite3_int64;
            if nWrite != n {
                rc = 1 as libc::c_int;
            }
        }
        fclose(out);
        if rc == 0 as libc::c_int && mode != 0
            && chmod(zFile, mode & 0o777 as libc::c_int as libc::c_uint) != 0
        {
            rc = 1 as libc::c_int;
        }
        if rc != 0 {
            return 2 as libc::c_int;
        }
        sqlite3_result_int64(pCtx, nWrite);
    }
    if mtime >= 0 as libc::c_int as libc::c_longlong {
        let mut times: [timeval; 2] = [timeval { tv_sec: 0, tv_usec: 0 }; 2];
        times[1 as libc::c_int as usize].tv_usec = 0 as libc::c_int as __suseconds_t;
        times[0 as libc::c_int as usize]
            .tv_usec = times[1 as libc::c_int as usize].tv_usec;
        times[0 as libc::c_int as usize].tv_sec = time(0 as *mut time_t);
        times[1 as libc::c_int as usize].tv_sec = mtime as __time_t;
        if utimes(zFile, times.as_mut_ptr() as *const timeval) != 0 {
            return 1 as libc::c_int;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn writefileFunc(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut zFile: *const libc::c_char = 0 as *const libc::c_char;
    let mut mode: mode_t = 0 as libc::c_int as mode_t;
    let mut res: libc::c_int = 0;
    let mut mtime: sqlite3_int64 = -(1 as libc::c_int) as sqlite3_int64;
    if argc < 2 as libc::c_int || argc > 4 as libc::c_int {
        sqlite3_result_error(
            context,
            b"wrong number of arguments to function writefile()\0" as *const u8
                as *const libc::c_char,
            -(1 as libc::c_int),
        );
        return;
    }
    zFile = sqlite3_value_text(*argv.offset(0 as libc::c_int as isize))
        as *const libc::c_char;
    if zFile.is_null() {
        return;
    }
    if argc >= 3 as libc::c_int {
        mode = sqlite3_value_int(*argv.offset(2 as libc::c_int as isize)) as mode_t;
    }
    if argc == 4 as libc::c_int {
        mtime = sqlite3_value_int64(*argv.offset(3 as libc::c_int as isize));
    }
    res = writeFile(
        context,
        zFile,
        *argv.offset(1 as libc::c_int as isize),
        mode,
        mtime,
    );
    if res == 1 as libc::c_int && *__errno_location() == 2 as libc::c_int {
        if makeDirectory(zFile) == 0 as libc::c_int {
            res = writeFile(
                context,
                zFile,
                *argv.offset(1 as libc::c_int as isize),
                mode,
                mtime,
            );
        }
    }
    if argc > 2 as libc::c_int && res != 0 as libc::c_int {
        if mode & 0o170000 as libc::c_int as libc::c_uint
            == 0o120000 as libc::c_int as libc::c_uint
        {
            ctxErrorMsg(
                context,
                b"failed to create symlink: %s\0" as *const u8 as *const libc::c_char,
                zFile,
            );
        } else if mode & 0o170000 as libc::c_int as libc::c_uint
            == 0o40000 as libc::c_int as libc::c_uint
        {
            ctxErrorMsg(
                context,
                b"failed to create directory: %s\0" as *const u8 as *const libc::c_char,
                zFile,
            );
        } else {
            ctxErrorMsg(
                context,
                b"failed to write file: %s\0" as *const u8 as *const libc::c_char,
                zFile,
            );
        }
    }
}
unsafe extern "C" fn lsModeFunc(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut i: libc::c_int = 0;
    let mut iMode: libc::c_int = sqlite3_value_int(
        *argv.offset(0 as libc::c_int as isize),
    );
    let mut z: [libc::c_char; 16] = [0; 16];
    if iMode & 0o170000 as libc::c_int == 0o120000 as libc::c_int {
        z[0 as libc::c_int as usize] = 'l' as i32 as libc::c_char;
    } else if iMode & 0o170000 as libc::c_int == 0o100000 as libc::c_int {
        z[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
    } else if iMode & 0o170000 as libc::c_int == 0o40000 as libc::c_int {
        z[0 as libc::c_int as usize] = 'd' as i32 as libc::c_char;
    } else {
        z[0 as libc::c_int as usize] = '?' as i32 as libc::c_char;
    }
    i = 0 as libc::c_int;
    while i < 3 as libc::c_int {
        let mut m: libc::c_int = iMode >> (2 as libc::c_int - i) * 3 as libc::c_int;
        let mut a: *mut libc::c_char = &mut *z
            .as_mut_ptr()
            .offset((1 as libc::c_int + i * 3 as libc::c_int) as isize)
            as *mut libc::c_char;
        *a
            .offset(
                0 as libc::c_int as isize,
            ) = (if m & 0x4 as libc::c_int != 0 { 'r' as i32 } else { '-' as i32 })
            as libc::c_char;
        *a
            .offset(
                1 as libc::c_int as isize,
            ) = (if m & 0x2 as libc::c_int != 0 { 'w' as i32 } else { '-' as i32 })
            as libc::c_char;
        *a
            .offset(
                2 as libc::c_int as isize,
            ) = (if m & 0x1 as libc::c_int != 0 { 'x' as i32 } else { '-' as i32 })
            as libc::c_char;
        i += 1;
    }
    z[10 as libc::c_int as usize] = '\0' as i32 as libc::c_char;
    sqlite3_result_text(
        context,
        z.as_mut_ptr(),
        -(1 as libc::c_int),
        ::std::mem::transmute::<
            libc::intptr_t,
            sqlite3_destructor_type,
        >(-(1 as libc::c_int) as libc::intptr_t),
    );
}
unsafe extern "C" fn fsdirConnect(
    mut db: *mut sqlite3,
    mut pAux: *mut libc::c_void,
    mut argc: libc::c_int,
    mut argv: *const *const libc::c_char,
    mut ppVtab: *mut *mut sqlite3_vtab,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut pNew: *mut fsdir_tab = 0 as *mut fsdir_tab;
    let mut rc: libc::c_int = 0;
    rc = sqlite3_declare_vtab(
        db,
        b"CREATE TABLE x(name,mode,mtime,data,path HIDDEN,dir HIDDEN)\0" as *const u8
            as *const libc::c_char,
    );
    if rc == 0 as libc::c_int {
        pNew = sqlite3_malloc(
            ::std::mem::size_of::<fsdir_tab>() as libc::c_ulong as libc::c_int,
        ) as *mut fsdir_tab;
        if pNew.is_null() {
            return 7 as libc::c_int;
        }
        memset(
            pNew as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<fsdir_tab>() as libc::c_ulong,
        );
        sqlite3_vtab_config(db, 3 as libc::c_int);
    }
    *ppVtab = pNew as *mut sqlite3_vtab;
    return rc;
}
unsafe extern "C" fn fsdirDisconnect(mut pVtab: *mut sqlite3_vtab) -> libc::c_int {
    sqlite3_free(pVtab as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn fsdirOpen(
    mut p: *mut sqlite3_vtab,
    mut ppCursor: *mut *mut sqlite3_vtab_cursor,
) -> libc::c_int {
    let mut pCur: *mut fsdir_cursor = 0 as *mut fsdir_cursor;
    pCur = sqlite3_malloc(
        ::std::mem::size_of::<fsdir_cursor>() as libc::c_ulong as libc::c_int,
    ) as *mut fsdir_cursor;
    if pCur.is_null() {
        return 7 as libc::c_int;
    }
    memset(
        pCur as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<fsdir_cursor>() as libc::c_ulong,
    );
    (*pCur).iLvl = -(1 as libc::c_int);
    *ppCursor = &mut (*pCur).base;
    return 0 as libc::c_int;
}
unsafe extern "C" fn fsdirResetCursor(mut pCur: *mut fsdir_cursor) {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i <= (*pCur).iLvl {
        let mut pLvl: *mut FsdirLevel = &mut *((*pCur).aLvl).offset(i as isize)
            as *mut FsdirLevel;
        if !((*pLvl).pDir).is_null() {
            closedir((*pLvl).pDir);
        }
        sqlite3_free((*pLvl).zDir as *mut libc::c_void);
        i += 1;
    }
    sqlite3_free((*pCur).zPath as *mut libc::c_void);
    sqlite3_free((*pCur).aLvl as *mut libc::c_void);
    let ref mut fresh72 = (*pCur).aLvl;
    *fresh72 = 0 as *mut FsdirLevel;
    let ref mut fresh73 = (*pCur).zPath;
    *fresh73 = 0 as *mut libc::c_char;
    let ref mut fresh74 = (*pCur).zBase;
    *fresh74 = 0 as *const libc::c_char;
    (*pCur).nBase = 0 as libc::c_int;
    (*pCur).nLvl = 0 as libc::c_int;
    (*pCur).iLvl = -(1 as libc::c_int);
    (*pCur).iRowid = 1 as libc::c_int as sqlite3_int64;
}
unsafe extern "C" fn fsdirClose(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCur: *mut fsdir_cursor = cur as *mut fsdir_cursor;
    fsdirResetCursor(pCur);
    sqlite3_free(pCur as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn fsdirSetErrmsg(
    mut pCur: *mut fsdir_cursor,
    mut zFmt: *const libc::c_char,
    mut args: ...
) {
    let mut ap: ::std::ffi::VaListImpl;
    ap = args.clone();
    let ref mut fresh75 = (*(*pCur).base.pVtab).zErrMsg;
    *fresh75 = sqlite3_vmprintf(zFmt, ap.as_va_list());
}
unsafe extern "C" fn fsdirNext(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCur: *mut fsdir_cursor = cur as *mut fsdir_cursor;
    let mut m: mode_t = (*pCur).sStat.st_mode;
    let ref mut fresh76 = (*pCur).iRowid;
    *fresh76 += 1;
    if m & 0o170000 as libc::c_int as libc::c_uint
        == 0o40000 as libc::c_int as libc::c_uint
    {
        let mut iNew: libc::c_int = (*pCur).iLvl + 1 as libc::c_int;
        let mut pLvl: *mut FsdirLevel = 0 as *mut FsdirLevel;
        if iNew >= (*pCur).nLvl {
            let mut nNew: libc::c_int = iNew + 1 as libc::c_int;
            let mut nByte: sqlite3_int64 = (nNew as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<FsdirLevel>() as libc::c_ulong)
                as sqlite3_int64;
            let mut aNew: *mut FsdirLevel = sqlite3_realloc64(
                (*pCur).aLvl as *mut libc::c_void,
                nByte as sqlite3_uint64,
            ) as *mut FsdirLevel;
            if aNew.is_null() {
                return 7 as libc::c_int;
            }
            memset(
                &mut *aNew.offset((*pCur).nLvl as isize) as *mut FsdirLevel
                    as *mut libc::c_void,
                0 as libc::c_int,
                (::std::mem::size_of::<FsdirLevel>() as libc::c_ulong)
                    .wrapping_mul((nNew - (*pCur).nLvl) as libc::c_ulong),
            );
            let ref mut fresh77 = (*pCur).aLvl;
            *fresh77 = aNew;
            (*pCur).nLvl = nNew;
        }
        (*pCur).iLvl = iNew;
        pLvl = &mut *((*pCur).aLvl).offset(iNew as isize) as *mut FsdirLevel;
        let ref mut fresh78 = (*pLvl).zDir;
        *fresh78 = (*pCur).zPath;
        let ref mut fresh79 = (*pCur).zPath;
        *fresh79 = 0 as *mut libc::c_char;
        let ref mut fresh80 = (*pLvl).pDir;
        *fresh80 = opendir((*pLvl).zDir);
        if ((*pLvl).pDir).is_null() {
            fsdirSetErrmsg(
                pCur,
                b"cannot read directory: %s\0" as *const u8 as *const libc::c_char,
                (*pCur).zPath,
            );
            return 1 as libc::c_int;
        }
    }
    while (*pCur).iLvl >= 0 as libc::c_int {
        let mut pLvl_0: *mut FsdirLevel = &mut *((*pCur).aLvl)
            .offset((*pCur).iLvl as isize) as *mut FsdirLevel;
        let mut pEntry: *mut dirent = readdir((*pLvl_0).pDir);
        if !pEntry.is_null() {
            if (*pEntry).d_name[0 as libc::c_int as usize] as libc::c_int == '.' as i32 {
                if (*pEntry).d_name[1 as libc::c_int as usize] as libc::c_int
                    == '.' as i32
                    && (*pEntry).d_name[2 as libc::c_int as usize] as libc::c_int
                        == '\0' as i32
                {
                    continue;
                }
                if (*pEntry).d_name[1 as libc::c_int as usize] as libc::c_int
                    == '\0' as i32
                {
                    continue;
                }
            }
            sqlite3_free((*pCur).zPath as *mut libc::c_void);
            let ref mut fresh81 = (*pCur).zPath;
            *fresh81 = sqlite3_mprintf(
                b"%s/%s\0" as *const u8 as *const libc::c_char,
                (*pLvl_0).zDir,
                ((*pEntry).d_name).as_mut_ptr(),
            );
            if ((*pCur).zPath).is_null() {
                return 7 as libc::c_int;
            }
            if fileLinkStat((*pCur).zPath, &mut (*pCur).sStat) != 0 {
                fsdirSetErrmsg(
                    pCur,
                    b"cannot stat file: %s\0" as *const u8 as *const libc::c_char,
                    (*pCur).zPath,
                );
                return 1 as libc::c_int;
            }
            return 0 as libc::c_int;
        } else {
            closedir((*pLvl_0).pDir);
            sqlite3_free((*pLvl_0).zDir as *mut libc::c_void);
            let ref mut fresh82 = (*pLvl_0).pDir;
            *fresh82 = 0 as *mut DIR;
            let ref mut fresh83 = (*pLvl_0).zDir;
            *fresh83 = 0 as *mut libc::c_char;
            let ref mut fresh84 = (*pCur).iLvl;
            *fresh84 -= 1;
        }
    }
    sqlite3_free((*pCur).zPath as *mut libc::c_void);
    let ref mut fresh85 = (*pCur).zPath;
    *fresh85 = 0 as *mut libc::c_char;
    return 0 as libc::c_int;
}
unsafe extern "C" fn fsdirColumn(
    mut cur: *mut sqlite3_vtab_cursor,
    mut ctx: *mut sqlite3_context,
    mut i: libc::c_int,
) -> libc::c_int {
    let mut pCur: *mut fsdir_cursor = cur as *mut fsdir_cursor;
    match i {
        0 => {
            sqlite3_result_text(
                ctx,
                &mut *((*pCur).zPath).offset((*pCur).nBase as isize),
                -(1 as libc::c_int),
                ::std::mem::transmute::<
                    libc::intptr_t,
                    sqlite3_destructor_type,
                >(-(1 as libc::c_int) as libc::intptr_t),
            );
        }
        1 => {
            sqlite3_result_int64(ctx, (*pCur).sStat.st_mode as sqlite3_int64);
        }
        2 => {
            sqlite3_result_int64(ctx, (*pCur).sStat.st_mtim.tv_sec as sqlite3_int64);
        }
        3 => {
            let mut m: mode_t = (*pCur).sStat.st_mode;
            if m & 0o170000 as libc::c_int as libc::c_uint
                == 0o40000 as libc::c_int as libc::c_uint
            {
                sqlite3_result_null(ctx);
            } else if m & 0o170000 as libc::c_int as libc::c_uint
                == 0o120000 as libc::c_int as libc::c_uint
            {
                let mut aStatic: [libc::c_char; 64] = [0; 64];
                let mut aBuf: *mut libc::c_char = aStatic.as_mut_ptr();
                let mut nBuf: sqlite3_int64 = 64 as libc::c_int as sqlite3_int64;
                let mut n: libc::c_int = 0;
                loop {
                    n = readlink((*pCur).zPath, aBuf, nBuf as size_t) as libc::c_int;
                    if (n as libc::c_longlong) < nBuf {
                        break;
                    }
                    if aBuf != aStatic.as_mut_ptr() {
                        sqlite3_free(aBuf as *mut libc::c_void);
                    }
                    nBuf = nBuf * 2 as libc::c_int as libc::c_longlong;
                    aBuf = sqlite3_malloc64(nBuf as sqlite3_uint64) as *mut libc::c_char;
                    if aBuf.is_null() {
                        sqlite3_result_error_nomem(ctx);
                        return 7 as libc::c_int;
                    }
                }
                sqlite3_result_text(
                    ctx,
                    aBuf,
                    n,
                    ::std::mem::transmute::<
                        libc::intptr_t,
                        sqlite3_destructor_type,
                    >(-(1 as libc::c_int) as libc::intptr_t),
                );
                if aBuf != aStatic.as_mut_ptr() {
                    sqlite3_free(aBuf as *mut libc::c_void);
                }
            } else {
                readFileContents(ctx, (*pCur).zPath);
            }
        }
        4 | _ => {}
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn fsdirRowid(
    mut cur: *mut sqlite3_vtab_cursor,
    mut pRowid: *mut sqlite_int64,
) -> libc::c_int {
    let mut pCur: *mut fsdir_cursor = cur as *mut fsdir_cursor;
    *pRowid = (*pCur).iRowid;
    return 0 as libc::c_int;
}
unsafe extern "C" fn fsdirEof(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCur: *mut fsdir_cursor = cur as *mut fsdir_cursor;
    return ((*pCur).zPath == 0 as *mut libc::c_char) as libc::c_int;
}
unsafe extern "C" fn fsdirFilter(
    mut cur: *mut sqlite3_vtab_cursor,
    mut idxNum: libc::c_int,
    mut idxStr: *const libc::c_char,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) -> libc::c_int {
    let mut zDir: *const libc::c_char = 0 as *const libc::c_char;
    let mut pCur: *mut fsdir_cursor = cur as *mut fsdir_cursor;
    fsdirResetCursor(pCur);
    if idxNum == 0 as libc::c_int {
        fsdirSetErrmsg(
            pCur,
            b"table function fsdir requires an argument\0" as *const u8
                as *const libc::c_char,
        );
        return 1 as libc::c_int;
    }
    zDir = sqlite3_value_text(*argv.offset(0 as libc::c_int as isize))
        as *const libc::c_char;
    if zDir.is_null() {
        fsdirSetErrmsg(
            pCur,
            b"table function fsdir requires a non-NULL argument\0" as *const u8
                as *const libc::c_char,
        );
        return 1 as libc::c_int;
    }
    if argc == 2 as libc::c_int {
        let ref mut fresh86 = (*pCur).zBase;
        *fresh86 = sqlite3_value_text(*argv.offset(1 as libc::c_int as isize))
            as *const libc::c_char;
    }
    if !((*pCur).zBase).is_null() {
        (*pCur).nBase = strlen((*pCur).zBase) as libc::c_int + 1 as libc::c_int;
        let ref mut fresh87 = (*pCur).zPath;
        *fresh87 = sqlite3_mprintf(
            b"%s/%s\0" as *const u8 as *const libc::c_char,
            (*pCur).zBase,
            zDir,
        );
    } else {
        let ref mut fresh88 = (*pCur).zPath;
        *fresh88 = sqlite3_mprintf(b"%s\0" as *const u8 as *const libc::c_char, zDir);
    }
    if ((*pCur).zPath).is_null() {
        return 7 as libc::c_int;
    }
    if fileLinkStat((*pCur).zPath, &mut (*pCur).sStat) != 0 {
        fsdirSetErrmsg(
            pCur,
            b"cannot stat file: %s\0" as *const u8 as *const libc::c_char,
            (*pCur).zPath,
        );
        return 1 as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn fsdirBestIndex(
    mut tab: *mut sqlite3_vtab,
    mut pIdxInfo: *mut sqlite3_index_info,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut idxPath: libc::c_int = -(1 as libc::c_int);
    let mut idxDir: libc::c_int = -(1 as libc::c_int);
    let mut seenPath: libc::c_int = 0 as libc::c_int;
    let mut seenDir: libc::c_int = 0 as libc::c_int;
    let mut pConstraint: *const sqlite3_index_constraint = 0
        as *const sqlite3_index_constraint;
    pConstraint = (*pIdxInfo).aConstraint;
    i = 0 as libc::c_int;
    while i < (*pIdxInfo).nConstraint {
        if !((*pConstraint).op as libc::c_int != 2 as libc::c_int) {
            match (*pConstraint).iColumn {
                4 => {
                    if (*pConstraint).usable != 0 {
                        idxPath = i;
                        seenPath = 0 as libc::c_int;
                    } else if idxPath < 0 as libc::c_int {
                        seenPath = 1 as libc::c_int;
                    }
                }
                5 => {
                    if (*pConstraint).usable != 0 {
                        idxDir = i;
                        seenDir = 0 as libc::c_int;
                    } else if idxDir < 0 as libc::c_int {
                        seenDir = 1 as libc::c_int;
                    }
                }
                _ => {}
            }
        }
        i += 1;
        pConstraint = pConstraint.offset(1);
    }
    if seenPath != 0 || seenDir != 0 {
        return 19 as libc::c_int;
    }
    if idxPath < 0 as libc::c_int {
        (*pIdxInfo).idxNum = 0 as libc::c_int;
        (*pIdxInfo).estimatedRows = 0x7fffffff as libc::c_int as sqlite3_int64;
    } else {
        (*((*pIdxInfo).aConstraintUsage).offset(idxPath as isize))
            .omit = 1 as libc::c_int as libc::c_uchar;
        (*((*pIdxInfo).aConstraintUsage).offset(idxPath as isize))
            .argvIndex = 1 as libc::c_int;
        if idxDir >= 0 as libc::c_int {
            (*((*pIdxInfo).aConstraintUsage).offset(idxDir as isize))
                .omit = 1 as libc::c_int as libc::c_uchar;
            (*((*pIdxInfo).aConstraintUsage).offset(idxDir as isize))
                .argvIndex = 2 as libc::c_int;
            (*pIdxInfo).idxNum = 2 as libc::c_int;
            (*pIdxInfo).estimatedCost = 10.0f64;
        } else {
            (*pIdxInfo).idxNum = 1 as libc::c_int;
            (*pIdxInfo).estimatedCost = 100.0f64;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn fsdirRegister(mut db: *mut sqlite3) -> libc::c_int {
    static mut fsdirModule: sqlite3_module = unsafe {
        {
            let mut init = sqlite3_module {
                iVersion: 0 as libc::c_int,
                xCreate: None,
                xConnect: Some(
                    fsdirConnect
                        as unsafe extern "C" fn(
                            *mut sqlite3,
                            *mut libc::c_void,
                            libc::c_int,
                            *const *const libc::c_char,
                            *mut *mut sqlite3_vtab,
                            *mut *mut libc::c_char,
                        ) -> libc::c_int,
                ),
                xBestIndex: Some(
                    fsdirBestIndex
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab,
                            *mut sqlite3_index_info,
                        ) -> libc::c_int,
                ),
                xDisconnect: Some(
                    fsdirDisconnect
                        as unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int,
                ),
                xDestroy: None,
                xOpen: Some(
                    fsdirOpen
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab,
                            *mut *mut sqlite3_vtab_cursor,
                        ) -> libc::c_int,
                ),
                xClose: Some(
                    fsdirClose
                        as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xFilter: Some(
                    fsdirFilter
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab_cursor,
                            libc::c_int,
                            *const libc::c_char,
                            libc::c_int,
                            *mut *mut sqlite3_value,
                        ) -> libc::c_int,
                ),
                xNext: Some(
                    fsdirNext
                        as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xEof: Some(
                    fsdirEof
                        as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xColumn: Some(
                    fsdirColumn
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab_cursor,
                            *mut sqlite3_context,
                            libc::c_int,
                        ) -> libc::c_int,
                ),
                xRowid: Some(
                    fsdirRowid
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab_cursor,
                            *mut sqlite_int64,
                        ) -> libc::c_int,
                ),
                xUpdate: None,
                xBegin: None,
                xSync: None,
                xCommit: None,
                xRollback: None,
                xFindFunction: None,
                xRename: None,
                xSavepoint: None,
                xRelease: None,
                xRollbackTo: None,
                xShadowName: None,
            };
            init
        }
    };
    let mut rc: libc::c_int = sqlite3_create_module(
        db,
        b"fsdir\0" as *const u8 as *const libc::c_char,
        &mut fsdirModule,
        0 as *mut libc::c_void,
    );
    return rc;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_fileio_init(
    mut db: *mut sqlite3,
    mut pzErrMsg: *mut *mut libc::c_char,
    mut pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    rc = sqlite3_create_function(
        db,
        b"readfile\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
        1 as libc::c_int | 0x80000 as libc::c_int,
        0 as *mut libc::c_void,
        Some(
            readfileFunc
                as unsafe extern "C" fn(
                    *mut sqlite3_context,
                    libc::c_int,
                    *mut *mut sqlite3_value,
                ) -> (),
        ),
        None,
        None,
    );
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_function(
            db,
            b"writefile\0" as *const u8 as *const libc::c_char,
            -(1 as libc::c_int),
            1 as libc::c_int | 0x80000 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                writefileFunc
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
    }
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_function(
            db,
            b"lsmode\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            1 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                lsModeFunc
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
    }
    if rc == 0 as libc::c_int {
        rc = fsdirRegister(db);
    }
    return rc;
}
unsafe extern "C" fn completionConnect(
    mut db: *mut sqlite3,
    mut pAux: *mut libc::c_void,
    mut argc: libc::c_int,
    mut argv: *const *const libc::c_char,
    mut ppVtab: *mut *mut sqlite3_vtab,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut pNew: *mut completion_vtab = 0 as *mut completion_vtab;
    let mut rc: libc::c_int = 0;
    sqlite3_vtab_config(db, 2 as libc::c_int);
    rc = sqlite3_declare_vtab(
        db,
        b"CREATE TABLE x(  candidate TEXT,  prefix TEXT HIDDEN,  wholeline TEXT HIDDEN,  phase INT HIDDEN)\0"
            as *const u8 as *const libc::c_char,
    );
    if rc == 0 as libc::c_int {
        pNew = sqlite3_malloc(
            ::std::mem::size_of::<completion_vtab>() as libc::c_ulong as libc::c_int,
        ) as *mut completion_vtab;
        *ppVtab = pNew as *mut sqlite3_vtab;
        if pNew.is_null() {
            return 7 as libc::c_int;
        }
        memset(
            pNew as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<completion_vtab>() as libc::c_ulong,
        );
        let ref mut fresh89 = (*pNew).db;
        *fresh89 = db;
    }
    return rc;
}
unsafe extern "C" fn completionDisconnect(mut pVtab: *mut sqlite3_vtab) -> libc::c_int {
    sqlite3_free(pVtab as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn completionOpen(
    mut p: *mut sqlite3_vtab,
    mut ppCursor: *mut *mut sqlite3_vtab_cursor,
) -> libc::c_int {
    let mut pCur: *mut completion_cursor = 0 as *mut completion_cursor;
    pCur = sqlite3_malloc(
        ::std::mem::size_of::<completion_cursor>() as libc::c_ulong as libc::c_int,
    ) as *mut completion_cursor;
    if pCur.is_null() {
        return 7 as libc::c_int;
    }
    memset(
        pCur as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<completion_cursor>() as libc::c_ulong,
    );
    let ref mut fresh90 = (*pCur).db;
    *fresh90 = (*(p as *mut completion_vtab)).db;
    *ppCursor = &mut (*pCur).base;
    return 0 as libc::c_int;
}
unsafe extern "C" fn completionCursorReset(mut pCur: *mut completion_cursor) {
    sqlite3_free((*pCur).zPrefix as *mut libc::c_void);
    let ref mut fresh91 = (*pCur).zPrefix;
    *fresh91 = 0 as *mut libc::c_char;
    (*pCur).nPrefix = 0 as libc::c_int;
    sqlite3_free((*pCur).zLine as *mut libc::c_void);
    let ref mut fresh92 = (*pCur).zLine;
    *fresh92 = 0 as *mut libc::c_char;
    (*pCur).nLine = 0 as libc::c_int;
    sqlite3_finalize((*pCur).pStmt);
    let ref mut fresh93 = (*pCur).pStmt;
    *fresh93 = 0 as *mut sqlite3_stmt;
    (*pCur).j = 0 as libc::c_int;
}
unsafe extern "C" fn completionClose(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    completionCursorReset(cur as *mut completion_cursor);
    sqlite3_free(cur as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn completionNext(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCur: *mut completion_cursor = cur as *mut completion_cursor;
    let mut eNextPhase: libc::c_int = 0 as libc::c_int;
    let mut iCol: libc::c_int = -(1 as libc::c_int);
    let ref mut fresh94 = (*pCur).iRowid;
    *fresh94 += 1;
    while (*pCur).ePhase != 11 as libc::c_int {
        match (*pCur).ePhase {
            1 => {
                if (*pCur).j >= sqlite3_keyword_count() {
                    let ref mut fresh95 = (*pCur).zCurrentRow;
                    *fresh95 = 0 as *const libc::c_char;
                    (*pCur).ePhase = 7 as libc::c_int;
                } else {
                    let ref mut fresh96 = (*pCur).j;
                    let fresh97 = *fresh96;
                    *fresh96 = *fresh96 + 1;
                    sqlite3_keyword_name(
                        fresh97,
                        &mut (*pCur).zCurrentRow,
                        &mut (*pCur).szRow,
                    );
                }
                iCol = -(1 as libc::c_int);
            }
            7 => {
                if ((*pCur).pStmt).is_null() {
                    sqlite3_prepare_v2(
                        (*pCur).db,
                        b"PRAGMA database_list\0" as *const u8 as *const libc::c_char,
                        -(1 as libc::c_int),
                        &mut (*pCur).pStmt,
                        0 as *mut *const libc::c_char,
                    );
                }
                iCol = 1 as libc::c_int;
                eNextPhase = 8 as libc::c_int;
            }
            8 => {
                if ((*pCur).pStmt).is_null() {
                    let mut pS2: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
                    let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
                    let mut zSep: *const libc::c_char = b"\0" as *const u8
                        as *const libc::c_char;
                    sqlite3_prepare_v2(
                        (*pCur).db,
                        b"PRAGMA database_list\0" as *const u8 as *const libc::c_char,
                        -(1 as libc::c_int),
                        &mut pS2,
                        0 as *mut *const libc::c_char,
                    );
                    while sqlite3_step(pS2) == 100 as libc::c_int {
                        let mut zDb: *const libc::c_char = sqlite3_column_text(
                            pS2,
                            1 as libc::c_int,
                        ) as *const libc::c_char;
                        zSql = sqlite3_mprintf(
                            b"%z%sSELECT name FROM \"%w\".sqlite_schema\0" as *const u8
                                as *const libc::c_char,
                            zSql,
                            zSep,
                            zDb,
                        );
                        if zSql.is_null() {
                            return 7 as libc::c_int;
                        }
                        zSep = b" UNION \0" as *const u8 as *const libc::c_char;
                    }
                    sqlite3_finalize(pS2);
                    sqlite3_prepare_v2(
                        (*pCur).db,
                        zSql,
                        -(1 as libc::c_int),
                        &mut (*pCur).pStmt,
                        0 as *mut *const libc::c_char,
                    );
                    sqlite3_free(zSql as *mut libc::c_void);
                }
                iCol = 0 as libc::c_int;
                eNextPhase = 9 as libc::c_int;
            }
            9 => {
                if ((*pCur).pStmt).is_null() {
                    let mut pS2_0: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
                    let mut zSql_0: *mut libc::c_char = 0 as *mut libc::c_char;
                    let mut zSep_0: *const libc::c_char = b"\0" as *const u8
                        as *const libc::c_char;
                    sqlite3_prepare_v2(
                        (*pCur).db,
                        b"PRAGMA database_list\0" as *const u8 as *const libc::c_char,
                        -(1 as libc::c_int),
                        &mut pS2_0,
                        0 as *mut *const libc::c_char,
                    );
                    while sqlite3_step(pS2_0) == 100 as libc::c_int {
                        let mut zDb_0: *const libc::c_char = sqlite3_column_text(
                            pS2_0,
                            1 as libc::c_int,
                        ) as *const libc::c_char;
                        zSql_0 = sqlite3_mprintf(
                            b"%z%sSELECT pti.name FROM \"%w\".sqlite_schema AS sm JOIN pragma_table_info(sm.name,%Q) AS pti WHERE sm.type='table'\0"
                                as *const u8 as *const libc::c_char,
                            zSql_0,
                            zSep_0,
                            zDb_0,
                            zDb_0,
                        );
                        if zSql_0.is_null() {
                            return 7 as libc::c_int;
                        }
                        zSep_0 = b" UNION \0" as *const u8 as *const libc::c_char;
                    }
                    sqlite3_finalize(pS2_0);
                    sqlite3_prepare_v2(
                        (*pCur).db,
                        zSql_0,
                        -(1 as libc::c_int),
                        &mut (*pCur).pStmt,
                        0 as *mut *const libc::c_char,
                    );
                    sqlite3_free(zSql_0 as *mut libc::c_void);
                }
                iCol = 0 as libc::c_int;
                eNextPhase = 11 as libc::c_int;
            }
            _ => {}
        }
        if iCol < 0 as libc::c_int {
            if ((*pCur).zCurrentRow).is_null() {
                continue;
            }
        } else if sqlite3_step((*pCur).pStmt) == 100 as libc::c_int {
            let ref mut fresh98 = (*pCur).zCurrentRow;
            *fresh98 = sqlite3_column_text((*pCur).pStmt, iCol) as *const libc::c_char;
            (*pCur).szRow = sqlite3_column_bytes((*pCur).pStmt, iCol);
        } else {
            sqlite3_finalize((*pCur).pStmt);
            let ref mut fresh99 = (*pCur).pStmt;
            *fresh99 = 0 as *mut sqlite3_stmt;
            (*pCur).ePhase = eNextPhase;
            continue;
        }
        if (*pCur).nPrefix == 0 as libc::c_int {
            break;
        }
        if (*pCur).nPrefix <= (*pCur).szRow
            && sqlite3_strnicmp((*pCur).zPrefix, (*pCur).zCurrentRow, (*pCur).nPrefix)
                == 0 as libc::c_int
        {
            break;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn completionColumn(
    mut cur: *mut sqlite3_vtab_cursor,
    mut ctx: *mut sqlite3_context,
    mut i: libc::c_int,
) -> libc::c_int {
    let mut pCur: *mut completion_cursor = cur as *mut completion_cursor;
    match i {
        0 => {
            sqlite3_result_text(
                ctx,
                (*pCur).zCurrentRow,
                (*pCur).szRow,
                ::std::mem::transmute::<
                    libc::intptr_t,
                    sqlite3_destructor_type,
                >(-(1 as libc::c_int) as libc::intptr_t),
            );
        }
        1 => {
            sqlite3_result_text(
                ctx,
                (*pCur).zPrefix,
                -(1 as libc::c_int),
                ::std::mem::transmute::<
                    libc::intptr_t,
                    sqlite3_destructor_type,
                >(-(1 as libc::c_int) as libc::intptr_t),
            );
        }
        2 => {
            sqlite3_result_text(
                ctx,
                (*pCur).zLine,
                -(1 as libc::c_int),
                ::std::mem::transmute::<
                    libc::intptr_t,
                    sqlite3_destructor_type,
                >(-(1 as libc::c_int) as libc::intptr_t),
            );
        }
        3 => {
            sqlite3_result_int(ctx, (*pCur).ePhase);
        }
        _ => {}
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn completionRowid(
    mut cur: *mut sqlite3_vtab_cursor,
    mut pRowid: *mut sqlite_int64,
) -> libc::c_int {
    let mut pCur: *mut completion_cursor = cur as *mut completion_cursor;
    *pRowid = (*pCur).iRowid;
    return 0 as libc::c_int;
}
unsafe extern "C" fn completionEof(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCur: *mut completion_cursor = cur as *mut completion_cursor;
    return ((*pCur).ePhase >= 11 as libc::c_int) as libc::c_int;
}
unsafe extern "C" fn completionFilter(
    mut pVtabCursor: *mut sqlite3_vtab_cursor,
    mut idxNum: libc::c_int,
    mut idxStr: *const libc::c_char,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) -> libc::c_int {
    let mut pCur: *mut completion_cursor = pVtabCursor as *mut completion_cursor;
    let mut iArg: libc::c_int = 0 as libc::c_int;
    completionCursorReset(pCur);
    if idxNum & 1 as libc::c_int != 0 {
        (*pCur).nPrefix = sqlite3_value_bytes(*argv.offset(iArg as isize));
        if (*pCur).nPrefix > 0 as libc::c_int {
            let ref mut fresh100 = (*pCur).zPrefix;
            *fresh100 = sqlite3_mprintf(
                b"%s\0" as *const u8 as *const libc::c_char,
                sqlite3_value_text(*argv.offset(iArg as isize)),
            );
            if ((*pCur).zPrefix).is_null() {
                return 7 as libc::c_int;
            }
        }
        iArg = 1 as libc::c_int;
    }
    if idxNum & 2 as libc::c_int != 0 {
        (*pCur).nLine = sqlite3_value_bytes(*argv.offset(iArg as isize));
        if (*pCur).nLine > 0 as libc::c_int {
            let ref mut fresh101 = (*pCur).zLine;
            *fresh101 = sqlite3_mprintf(
                b"%s\0" as *const u8 as *const libc::c_char,
                sqlite3_value_text(*argv.offset(iArg as isize)),
            );
            if ((*pCur).zLine).is_null() {
                return 7 as libc::c_int;
            }
        }
    }
    if !((*pCur).zLine).is_null() && ((*pCur).zPrefix).is_null() {
        let mut i: libc::c_int = (*pCur).nLine;
        while i > 0 as libc::c_int
            && (*(*__ctype_b_loc())
                .offset(
                    *((*pCur).zLine).offset((i - 1 as libc::c_int) as isize)
                        as libc::c_int as isize,
                ) as libc::c_int
                & _ISalnum as libc::c_int as libc::c_ushort as libc::c_int != 0
                || *((*pCur).zLine).offset((i - 1 as libc::c_int) as isize)
                    as libc::c_int == '_' as i32)
        {
            i -= 1;
        }
        (*pCur).nPrefix = (*pCur).nLine - i;
        if (*pCur).nPrefix > 0 as libc::c_int {
            let ref mut fresh102 = (*pCur).zPrefix;
            *fresh102 = sqlite3_mprintf(
                b"%.*s\0" as *const u8 as *const libc::c_char,
                (*pCur).nPrefix,
                ((*pCur).zLine).offset(i as isize),
            );
            if ((*pCur).zPrefix).is_null() {
                return 7 as libc::c_int;
            }
        }
    }
    (*pCur).iRowid = 0 as libc::c_int as sqlite3_int64;
    (*pCur).ePhase = 1 as libc::c_int;
    return completionNext(pVtabCursor);
}
unsafe extern "C" fn completionBestIndex(
    mut tab: *mut sqlite3_vtab,
    mut pIdxInfo: *mut sqlite3_index_info,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut idxNum: libc::c_int = 0 as libc::c_int;
    let mut prefixIdx: libc::c_int = -(1 as libc::c_int);
    let mut wholelineIdx: libc::c_int = -(1 as libc::c_int);
    let mut nArg: libc::c_int = 0 as libc::c_int;
    let mut pConstraint: *const sqlite3_index_constraint = 0
        as *const sqlite3_index_constraint;
    pConstraint = (*pIdxInfo).aConstraint;
    i = 0 as libc::c_int;
    while i < (*pIdxInfo).nConstraint {
        if !((*pConstraint).usable as libc::c_int == 0 as libc::c_int) {
            if !((*pConstraint).op as libc::c_int != 2 as libc::c_int) {
                match (*pConstraint).iColumn {
                    1 => {
                        prefixIdx = i;
                        idxNum |= 1 as libc::c_int;
                    }
                    2 => {
                        wholelineIdx = i;
                        idxNum |= 2 as libc::c_int;
                    }
                    _ => {}
                }
            }
        }
        i += 1;
        pConstraint = pConstraint.offset(1);
    }
    if prefixIdx >= 0 as libc::c_int {
        nArg += 1;
        (*((*pIdxInfo).aConstraintUsage).offset(prefixIdx as isize)).argvIndex = nArg;
        (*((*pIdxInfo).aConstraintUsage).offset(prefixIdx as isize))
            .omit = 1 as libc::c_int as libc::c_uchar;
    }
    if wholelineIdx >= 0 as libc::c_int {
        nArg += 1;
        (*((*pIdxInfo).aConstraintUsage).offset(wholelineIdx as isize)).argvIndex = nArg;
        (*((*pIdxInfo).aConstraintUsage).offset(wholelineIdx as isize))
            .omit = 1 as libc::c_int as libc::c_uchar;
    }
    (*pIdxInfo).idxNum = idxNum;
    (*pIdxInfo)
        .estimatedCost = 5000 as libc::c_int as libc::c_double
        - (1000 as libc::c_int * nArg) as libc::c_double;
    (*pIdxInfo)
        .estimatedRows = (500 as libc::c_int - 100 as libc::c_int * nArg)
        as sqlite3_int64;
    return 0 as libc::c_int;
}
static mut completionModule: sqlite3_module = unsafe {
    {
        let mut init = sqlite3_module {
            iVersion: 0 as libc::c_int,
            xCreate: None,
            xConnect: Some(
                completionConnect
                    as unsafe extern "C" fn(
                        *mut sqlite3,
                        *mut libc::c_void,
                        libc::c_int,
                        *const *const libc::c_char,
                        *mut *mut sqlite3_vtab,
                        *mut *mut libc::c_char,
                    ) -> libc::c_int,
            ),
            xBestIndex: Some(
                completionBestIndex
                    as unsafe extern "C" fn(
                        *mut sqlite3_vtab,
                        *mut sqlite3_index_info,
                    ) -> libc::c_int,
            ),
            xDisconnect: Some(
                completionDisconnect
                    as unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int,
            ),
            xDestroy: None,
            xOpen: Some(
                completionOpen
                    as unsafe extern "C" fn(
                        *mut sqlite3_vtab,
                        *mut *mut sqlite3_vtab_cursor,
                    ) -> libc::c_int,
            ),
            xClose: Some(
                completionClose
                    as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
            ),
            xFilter: Some(
                completionFilter
                    as unsafe extern "C" fn(
                        *mut sqlite3_vtab_cursor,
                        libc::c_int,
                        *const libc::c_char,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> libc::c_int,
            ),
            xNext: Some(
                completionNext
                    as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
            ),
            xEof: Some(
                completionEof
                    as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
            ),
            xColumn: Some(
                completionColumn
                    as unsafe extern "C" fn(
                        *mut sqlite3_vtab_cursor,
                        *mut sqlite3_context,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            xRowid: Some(
                completionRowid
                    as unsafe extern "C" fn(
                        *mut sqlite3_vtab_cursor,
                        *mut sqlite_int64,
                    ) -> libc::c_int,
            ),
            xUpdate: None,
            xBegin: None,
            xSync: None,
            xCommit: None,
            xRollback: None,
            xFindFunction: None,
            xRename: None,
            xSavepoint: None,
            xRelease: None,
            xRollbackTo: None,
            xShadowName: None,
        };
        init
    }
};
#[no_mangle]
pub unsafe extern "C" fn sqlite3CompletionVtabInit(mut db: *mut sqlite3) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    rc = sqlite3_create_module(
        db,
        b"completion\0" as *const u8 as *const libc::c_char,
        &mut completionModule,
        0 as *mut libc::c_void,
    );
    return rc;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_completion_init(
    mut db: *mut sqlite3,
    mut pzErrMsg: *mut *mut libc::c_char,
    mut pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    rc = sqlite3CompletionVtabInit(db);
    return rc;
}
static mut apnd_vfs: sqlite3_vfs = unsafe {
    {
        let mut init = sqlite3_vfs {
            iVersion: 3 as libc::c_int,
            szOsFile: 0 as libc::c_int,
            mxPathname: 1024 as libc::c_int,
            pNext: 0 as *const sqlite3_vfs as *mut sqlite3_vfs,
            zName: b"apndvfs\0" as *const u8 as *const libc::c_char,
            pAppData: 0 as *const libc::c_void as *mut libc::c_void,
            xOpen: Some(
                apndOpen
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        *const libc::c_char,
                        *mut sqlite3_file,
                        libc::c_int,
                        *mut libc::c_int,
                    ) -> libc::c_int,
            ),
            xDelete: Some(
                apndDelete
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        *const libc::c_char,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            xAccess: Some(
                apndAccess
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        *const libc::c_char,
                        libc::c_int,
                        *mut libc::c_int,
                    ) -> libc::c_int,
            ),
            xFullPathname: Some(
                apndFullPathname
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        *const libc::c_char,
                        libc::c_int,
                        *mut libc::c_char,
                    ) -> libc::c_int,
            ),
            xDlOpen: Some(
                apndDlOpen
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        *const libc::c_char,
                    ) -> *mut libc::c_void,
            ),
            xDlError: Some(
                apndDlError
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        libc::c_int,
                        *mut libc::c_char,
                    ) -> (),
            ),
            xDlSym: Some(
                apndDlSym
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        *mut libc::c_void,
                        *const libc::c_char,
                    ) -> Option::<unsafe extern "C" fn() -> ()>,
            ),
            xDlClose: Some(
                apndDlClose
                    as unsafe extern "C" fn(*mut sqlite3_vfs, *mut libc::c_void) -> (),
            ),
            xRandomness: Some(
                apndRandomness
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        libc::c_int,
                        *mut libc::c_char,
                    ) -> libc::c_int,
            ),
            xSleep: Some(
                apndSleep
                    as unsafe extern "C" fn(*mut sqlite3_vfs, libc::c_int) -> libc::c_int,
            ),
            xCurrentTime: Some(
                apndCurrentTime
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        *mut libc::c_double,
                    ) -> libc::c_int,
            ),
            xGetLastError: Some(
                apndGetLastError
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        libc::c_int,
                        *mut libc::c_char,
                    ) -> libc::c_int,
            ),
            xCurrentTimeInt64: Some(
                apndCurrentTimeInt64
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        *mut sqlite3_int64,
                    ) -> libc::c_int,
            ),
            xSetSystemCall: Some(
                apndSetSystemCall
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        *const libc::c_char,
                        sqlite3_syscall_ptr,
                    ) -> libc::c_int,
            ),
            xGetSystemCall: Some(
                apndGetSystemCall
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        *const libc::c_char,
                    ) -> sqlite3_syscall_ptr,
            ),
            xNextSystemCall: Some(
                apndNextSystemCall
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        *const libc::c_char,
                    ) -> *const libc::c_char,
            ),
        };
        init
    }
};
static mut apnd_io_methods: sqlite3_io_methods = unsafe {
    {
        let mut init = sqlite3_io_methods {
            iVersion: 3 as libc::c_int,
            xClose: Some(
                apndClose as unsafe extern "C" fn(*mut sqlite3_file) -> libc::c_int,
            ),
            xRead: Some(
                apndRead
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        *mut libc::c_void,
                        libc::c_int,
                        sqlite3_int64,
                    ) -> libc::c_int,
            ),
            xWrite: Some(
                apndWrite
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        *const libc::c_void,
                        libc::c_int,
                        sqlite3_int64,
                    ) -> libc::c_int,
            ),
            xTruncate: Some(
                apndTruncate
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        sqlite3_int64,
                    ) -> libc::c_int,
            ),
            xSync: Some(
                apndSync
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            xFileSize: Some(
                apndFileSize
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        *mut sqlite3_int64,
                    ) -> libc::c_int,
            ),
            xLock: Some(
                apndLock
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            xUnlock: Some(
                apndUnlock
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            xCheckReservedLock: Some(
                apndCheckReservedLock
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        *mut libc::c_int,
                    ) -> libc::c_int,
            ),
            xFileControl: Some(
                apndFileControl
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        libc::c_int,
                        *mut libc::c_void,
                    ) -> libc::c_int,
            ),
            xSectorSize: Some(
                apndSectorSize as unsafe extern "C" fn(*mut sqlite3_file) -> libc::c_int,
            ),
            xDeviceCharacteristics: Some(
                apndDeviceCharacteristics
                    as unsafe extern "C" fn(*mut sqlite3_file) -> libc::c_int,
            ),
            xShmMap: Some(
                apndShmMap
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        libc::c_int,
                        libc::c_int,
                        libc::c_int,
                        *mut *mut libc::c_void,
                    ) -> libc::c_int,
            ),
            xShmLock: Some(
                apndShmLock
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        libc::c_int,
                        libc::c_int,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            xShmBarrier: Some(
                apndShmBarrier as unsafe extern "C" fn(*mut sqlite3_file) -> (),
            ),
            xShmUnmap: Some(
                apndShmUnmap
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            xFetch: Some(
                apndFetch
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        sqlite3_int64,
                        libc::c_int,
                        *mut *mut libc::c_void,
                    ) -> libc::c_int,
            ),
            xUnfetch: Some(
                apndUnfetch
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        sqlite3_int64,
                        *mut libc::c_void,
                    ) -> libc::c_int,
            ),
        };
        init
    }
};
unsafe extern "C" fn apndClose(mut pFile: *mut sqlite3_file) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xClose).expect("non-null function pointer")(pFile);
}
unsafe extern "C" fn apndRead(
    mut pFile: *mut sqlite3_file,
    mut zBuf: *mut libc::c_void,
    mut iAmt: libc::c_int,
    mut iOfst: sqlite_int64,
) -> libc::c_int {
    let mut paf: *mut ApndFile = pFile as *mut ApndFile;
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xRead)
        .expect("non-null function pointer")(pFile, zBuf, iAmt, (*paf).iPgOne + iOfst);
}
unsafe extern "C" fn apndWriteMark(
    mut paf: *mut ApndFile,
    mut pFile: *mut sqlite3_file,
    mut iWriteEnd: sqlite_int64,
) -> libc::c_int {
    let mut iPgOne: sqlite_int64 = (*paf).iPgOne;
    let mut a: [libc::c_uchar; 25] = [0; 25];
    let mut i: libc::c_int = 8 as libc::c_int;
    let mut rc: libc::c_int = 0;
    memcpy(
        a.as_mut_ptr() as *mut libc::c_void,
        b"Start-Of-SQLite3-\0" as *const u8 as *const libc::c_char
            as *const libc::c_void,
        17 as libc::c_int as libc::c_ulong,
    );
    loop {
        i -= 1;
        if !(i >= 0 as libc::c_int) {
            break;
        }
        a[(17 as libc::c_int + i)
            as usize] = (iPgOne & 0xff as libc::c_int as libc::c_longlong)
            as libc::c_uchar;
        iPgOne >>= 8 as libc::c_int;
    }
    iWriteEnd += (*paf).iPgOne;
    rc = ((*(*pFile).pMethods).xWrite)
        .expect(
            "non-null function pointer",
        )(
        pFile,
        a.as_mut_ptr() as *const libc::c_void,
        17 as libc::c_int + 8 as libc::c_int,
        iWriteEnd,
    );
    if 0 as libc::c_int == rc {
        (*paf).iMark = iWriteEnd;
    }
    return rc;
}
unsafe extern "C" fn apndWrite(
    mut pFile: *mut sqlite3_file,
    mut zBuf: *const libc::c_void,
    mut iAmt: libc::c_int,
    mut iOfst: sqlite_int64,
) -> libc::c_int {
    let mut paf: *mut ApndFile = pFile as *mut ApndFile;
    let mut iWriteEnd: sqlite_int64 = iOfst + iAmt as libc::c_longlong;
    if iWriteEnd >= 0x40000000 as libc::c_int as libc::c_longlong {
        return 13 as libc::c_int;
    }
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    if (*paf).iMark < 0 as libc::c_int as libc::c_longlong
        || (*paf).iPgOne + iWriteEnd > (*paf).iMark
    {
        let mut rc: libc::c_int = apndWriteMark(paf, pFile, iWriteEnd);
        if 0 as libc::c_int != rc {
            return rc;
        }
    }
    return ((*(*pFile).pMethods).xWrite)
        .expect("non-null function pointer")(pFile, zBuf, iAmt, (*paf).iPgOne + iOfst);
}
unsafe extern "C" fn apndTruncate(
    mut pFile: *mut sqlite3_file,
    mut size: sqlite_int64,
) -> libc::c_int {
    let mut paf: *mut ApndFile = pFile as *mut ApndFile;
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    if 0 as libc::c_int != apndWriteMark(paf, pFile, size) {
        return 10 as libc::c_int;
    }
    return ((*(*pFile).pMethods).xTruncate)
        .expect(
            "non-null function pointer",
        )(
        pFile,
        (*paf).iMark + (17 as libc::c_int + 8 as libc::c_int) as libc::c_longlong,
    );
}
unsafe extern "C" fn apndSync(
    mut pFile: *mut sqlite3_file,
    mut flags: libc::c_int,
) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xSync)
        .expect("non-null function pointer")(pFile, flags);
}
unsafe extern "C" fn apndFileSize(
    mut pFile: *mut sqlite3_file,
    mut pSize: *mut sqlite_int64,
) -> libc::c_int {
    let mut paf: *mut ApndFile = pFile as *mut ApndFile;
    *pSize = if (*paf).iMark >= 0 as libc::c_int as libc::c_longlong {
        (*paf).iMark - (*paf).iPgOne
    } else {
        0 as libc::c_int as libc::c_longlong
    };
    return 0 as libc::c_int;
}
unsafe extern "C" fn apndLock(
    mut pFile: *mut sqlite3_file,
    mut eLock: libc::c_int,
) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xLock)
        .expect("non-null function pointer")(pFile, eLock);
}
unsafe extern "C" fn apndUnlock(
    mut pFile: *mut sqlite3_file,
    mut eLock: libc::c_int,
) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xUnlock)
        .expect("non-null function pointer")(pFile, eLock);
}
unsafe extern "C" fn apndCheckReservedLock(
    mut pFile: *mut sqlite3_file,
    mut pResOut: *mut libc::c_int,
) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xCheckReservedLock)
        .expect("non-null function pointer")(pFile, pResOut);
}
unsafe extern "C" fn apndFileControl(
    mut pFile: *mut sqlite3_file,
    mut op: libc::c_int,
    mut pArg: *mut libc::c_void,
) -> libc::c_int {
    let mut paf: *mut ApndFile = pFile as *mut ApndFile;
    let mut rc: libc::c_int = 0;
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    if op == 5 as libc::c_int {
        let ref mut fresh103 = *(pArg as *mut sqlite3_int64);
        *fresh103 += (*paf).iPgOne;
    }
    rc = ((*(*pFile).pMethods).xFileControl)
        .expect("non-null function pointer")(pFile, op, pArg);
    if rc == 0 as libc::c_int && op == 12 as libc::c_int {
        let ref mut fresh104 = *(pArg as *mut *mut libc::c_char);
        *fresh104 = sqlite3_mprintf(
            b"apnd(%lld)/%z\0" as *const u8 as *const libc::c_char,
            (*paf).iPgOne,
            *(pArg as *mut *mut libc::c_char),
        );
    }
    return rc;
}
unsafe extern "C" fn apndSectorSize(mut pFile: *mut sqlite3_file) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xSectorSize).expect("non-null function pointer")(pFile);
}
unsafe extern "C" fn apndDeviceCharacteristics(
    mut pFile: *mut sqlite3_file,
) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xDeviceCharacteristics)
        .expect("non-null function pointer")(pFile);
}
unsafe extern "C" fn apndShmMap(
    mut pFile: *mut sqlite3_file,
    mut iPg: libc::c_int,
    mut pgsz: libc::c_int,
    mut bExtend: libc::c_int,
    mut pp: *mut *mut libc::c_void,
) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xShmMap)
        .expect("non-null function pointer")(pFile, iPg, pgsz, bExtend, pp);
}
unsafe extern "C" fn apndShmLock(
    mut pFile: *mut sqlite3_file,
    mut offset: libc::c_int,
    mut n: libc::c_int,
    mut flags: libc::c_int,
) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xShmLock)
        .expect("non-null function pointer")(pFile, offset, n, flags);
}
unsafe extern "C" fn apndShmBarrier(mut pFile: *mut sqlite3_file) {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    ((*(*pFile).pMethods).xShmBarrier).expect("non-null function pointer")(pFile);
}
unsafe extern "C" fn apndShmUnmap(
    mut pFile: *mut sqlite3_file,
    mut deleteFlag: libc::c_int,
) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xShmUnmap)
        .expect("non-null function pointer")(pFile, deleteFlag);
}
unsafe extern "C" fn apndFetch(
    mut pFile: *mut sqlite3_file,
    mut iOfst: sqlite3_int64,
    mut iAmt: libc::c_int,
    mut pp: *mut *mut libc::c_void,
) -> libc::c_int {
    let mut p: *mut ApndFile = pFile as *mut ApndFile;
    if (*p).iMark < 0 as libc::c_int as libc::c_longlong
        || iOfst + iAmt as libc::c_longlong > (*p).iMark
    {
        return 10 as libc::c_int;
    }
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xFetch)
        .expect("non-null function pointer")(pFile, iOfst + (*p).iPgOne, iAmt, pp);
}
unsafe extern "C" fn apndUnfetch(
    mut pFile: *mut sqlite3_file,
    mut iOfst: sqlite3_int64,
    mut pPage: *mut libc::c_void,
) -> libc::c_int {
    let mut p: *mut ApndFile = pFile as *mut ApndFile;
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xUnfetch)
        .expect("non-null function pointer")(pFile, iOfst + (*p).iPgOne, pPage);
}
unsafe extern "C" fn apndReadMark(
    mut sz: sqlite3_int64,
    mut pFile: *mut sqlite3_file,
) -> sqlite3_int64 {
    let mut rc: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut iMark: sqlite3_int64 = 0;
    let mut msbs: libc::c_int = 8 as libc::c_int * (8 as libc::c_int - 1 as libc::c_int);
    let mut a: [libc::c_uchar; 25] = [0; 25];
    if (17 as libc::c_int + 8 as libc::c_int) as libc::c_longlong
        != sz & 0x1ff as libc::c_int as libc::c_longlong
    {
        return -(1 as libc::c_int) as sqlite3_int64;
    }
    rc = ((*(*pFile).pMethods).xRead)
        .expect(
            "non-null function pointer",
        )(
        pFile,
        a.as_mut_ptr() as *mut libc::c_void,
        17 as libc::c_int + 8 as libc::c_int,
        sz - (17 as libc::c_int + 8 as libc::c_int) as libc::c_longlong,
    );
    if rc != 0 {
        return -(1 as libc::c_int) as sqlite3_int64;
    }
    if memcmp(
        a.as_mut_ptr() as *const libc::c_void,
        b"Start-Of-SQLite3-\0" as *const u8 as *const libc::c_char
            as *const libc::c_void,
        17 as libc::c_int as libc::c_ulong,
    ) != 0 as libc::c_int
    {
        return -(1 as libc::c_int) as sqlite3_int64;
    }
    iMark = ((a[17 as libc::c_int as usize] as libc::c_int & 0x7f as libc::c_int)
        as sqlite3_int64) << msbs;
    i = 1 as libc::c_int;
    while i < 8 as libc::c_int {
        msbs -= 8 as libc::c_int;
        iMark |= (a[(17 as libc::c_int + i) as usize] as sqlite3_int64) << msbs;
        i += 1;
    }
    if iMark
        > sz - (17 as libc::c_int + 8 as libc::c_int) as libc::c_longlong
            - 512 as libc::c_int as libc::c_longlong
    {
        return -(1 as libc::c_int) as sqlite3_int64;
    }
    if iMark & 0x1ff as libc::c_int as libc::c_longlong != 0 {
        return -(1 as libc::c_int) as sqlite3_int64;
    }
    return iMark;
}
static mut apvfsSqliteHdr: [libc::c_char; 16] = unsafe {
    *::std::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"SQLite format 3\0")
};
unsafe extern "C" fn apndIsAppendvfsDatabase(
    mut sz: sqlite3_int64,
    mut pFile: *mut sqlite3_file,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    let mut zHdr: [libc::c_char; 16] = [0; 16];
    let mut iMark: sqlite3_int64 = apndReadMark(sz, pFile);
    if iMark >= 0 as libc::c_int as libc::c_longlong {
        rc = ((*(*pFile).pMethods).xRead)
            .expect(
                "non-null function pointer",
            )(
            pFile,
            zHdr.as_mut_ptr() as *mut libc::c_void,
            ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong as libc::c_int,
            iMark,
        );
        if 0 as libc::c_int == rc
            && memcmp(
                zHdr.as_mut_ptr() as *const libc::c_void,
                apvfsSqliteHdr.as_ptr() as *const libc::c_void,
                ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
            ) == 0 as libc::c_int
            && sz & 0x1ff as libc::c_int as libc::c_longlong
                == (17 as libc::c_int + 8 as libc::c_int) as libc::c_longlong
            && sz
                >= (512 as libc::c_int + (17 as libc::c_int + 8 as libc::c_int))
                    as libc::c_longlong
        {
            return 1 as libc::c_int;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn apndIsOrdinaryDatabaseFile(
    mut sz: sqlite3_int64,
    mut pFile: *mut sqlite3_file,
) -> libc::c_int {
    let mut zHdr: [libc::c_char; 16] = [0; 16];
    if apndIsAppendvfsDatabase(sz, pFile) != 0
        || sz & 0x1ff as libc::c_int as libc::c_longlong
            != 0 as libc::c_int as libc::c_longlong
        || 0 as libc::c_int
            != ((*(*pFile).pMethods).xRead)
                .expect(
                    "non-null function pointer",
                )(
                pFile,
                zHdr.as_mut_ptr() as *mut libc::c_void,
                ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong
                    as libc::c_int,
                0 as libc::c_int as sqlite3_int64,
            )
        || memcmp(
            zHdr.as_mut_ptr() as *const libc::c_void,
            apvfsSqliteHdr.as_ptr() as *const libc::c_void,
            ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
        ) != 0 as libc::c_int
    {
        return 0 as libc::c_int
    } else {
        return 1 as libc::c_int
    };
}
unsafe extern "C" fn apndOpen(
    mut pApndVfs: *mut sqlite3_vfs,
    mut zName: *const libc::c_char,
    mut pFile: *mut sqlite3_file,
    mut flags: libc::c_int,
    mut pOutFlags: *mut libc::c_int,
) -> libc::c_int {
    let mut pApndFile: *mut ApndFile = pFile as *mut ApndFile;
    let mut pBaseFile: *mut sqlite3_file = (pFile as *mut ApndFile)
        .offset(1 as libc::c_int as isize) as *mut sqlite3_file;
    let mut pBaseVfs: *mut sqlite3_vfs = (*pApndVfs).pAppData as *mut sqlite3_vfs;
    let mut rc: libc::c_int = 0;
    let mut sz: sqlite3_int64 = 0 as libc::c_int as sqlite3_int64;
    if flags & 0x100 as libc::c_int == 0 as libc::c_int {
        return ((*pBaseVfs).xOpen)
            .expect(
                "non-null function pointer",
            )(pBaseVfs, zName, pFile, flags, pOutFlags);
    }
    memset(
        pApndFile as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<ApndFile>() as libc::c_ulong,
    );
    let ref mut fresh105 = (*pFile).pMethods;
    *fresh105 = &apnd_io_methods;
    (*pApndFile).iMark = -(1 as libc::c_int) as sqlite3_int64;
    rc = ((*pBaseVfs).xOpen)
        .expect(
            "non-null function pointer",
        )(pBaseVfs, zName, pBaseFile, flags, pOutFlags);
    if rc == 0 as libc::c_int {
        rc = ((*(*pBaseFile).pMethods).xFileSize)
            .expect("non-null function pointer")(pBaseFile, &mut sz);
        if rc != 0 {
            ((*(*pBaseFile).pMethods).xClose)
                .expect("non-null function pointer")(pBaseFile);
        }
    }
    if rc != 0 {
        let ref mut fresh106 = (*pFile).pMethods;
        *fresh106 = 0 as *const sqlite3_io_methods;
        return rc;
    }
    if apndIsOrdinaryDatabaseFile(sz, pBaseFile) != 0 {
        memmove(
            pApndFile as *mut libc::c_void,
            pBaseFile as *const libc::c_void,
            (*pBaseVfs).szOsFile as libc::c_ulong,
        );
        return 0 as libc::c_int;
    }
    (*pApndFile).iPgOne = apndReadMark(sz, pFile);
    if (*pApndFile).iPgOne >= 0 as libc::c_int as libc::c_longlong {
        (*pApndFile)
            .iMark = sz - (17 as libc::c_int + 8 as libc::c_int) as libc::c_longlong;
        return 0 as libc::c_int;
    }
    if flags & 0x4 as libc::c_int == 0 as libc::c_int {
        ((*(*pBaseFile).pMethods).xClose).expect("non-null function pointer")(pBaseFile);
        rc = 14 as libc::c_int;
        let ref mut fresh107 = (*pFile).pMethods;
        *fresh107 = 0 as *const sqlite3_io_methods;
    } else {
        (*pApndFile)
            .iPgOne = sz + (4096 as libc::c_int - 1 as libc::c_int) as sqlite3_int64
            & !((4096 as libc::c_int - 1 as libc::c_int) as sqlite3_int64);
    }
    return rc;
}
unsafe extern "C" fn apndDelete(
    mut pVfs: *mut sqlite3_vfs,
    mut zPath: *const libc::c_char,
    mut dirSync: libc::c_int,
) -> libc::c_int {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xDelete)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, zPath, dirSync);
}
unsafe extern "C" fn apndAccess(
    mut pVfs: *mut sqlite3_vfs,
    mut zPath: *const libc::c_char,
    mut flags: libc::c_int,
    mut pResOut: *mut libc::c_int,
) -> libc::c_int {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xAccess)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, zPath, flags, pResOut);
}
unsafe extern "C" fn apndFullPathname(
    mut pVfs: *mut sqlite3_vfs,
    mut zPath: *const libc::c_char,
    mut nOut: libc::c_int,
    mut zOut: *mut libc::c_char,
) -> libc::c_int {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xFullPathname)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, zPath, nOut, zOut);
}
unsafe extern "C" fn apndDlOpen(
    mut pVfs: *mut sqlite3_vfs,
    mut zPath: *const libc::c_char,
) -> *mut libc::c_void {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xDlOpen)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, zPath);
}
unsafe extern "C" fn apndDlError(
    mut pVfs: *mut sqlite3_vfs,
    mut nByte: libc::c_int,
    mut zErrMsg: *mut libc::c_char,
) {
    ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xDlError)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, nByte, zErrMsg);
}
unsafe extern "C" fn apndDlSym(
    mut pVfs: *mut sqlite3_vfs,
    mut p: *mut libc::c_void,
    mut zSym: *const libc::c_char,
) -> Option::<unsafe extern "C" fn() -> ()> {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xDlSym)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, p, zSym);
}
unsafe extern "C" fn apndDlClose(
    mut pVfs: *mut sqlite3_vfs,
    mut pHandle: *mut libc::c_void,
) {
    ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xDlClose)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, pHandle);
}
unsafe extern "C" fn apndRandomness(
    mut pVfs: *mut sqlite3_vfs,
    mut nByte: libc::c_int,
    mut zBufOut: *mut libc::c_char,
) -> libc::c_int {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xRandomness)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, nByte, zBufOut);
}
unsafe extern "C" fn apndSleep(
    mut pVfs: *mut sqlite3_vfs,
    mut nMicro: libc::c_int,
) -> libc::c_int {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xSleep)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, nMicro);
}
unsafe extern "C" fn apndCurrentTime(
    mut pVfs: *mut sqlite3_vfs,
    mut pTimeOut: *mut libc::c_double,
) -> libc::c_int {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xCurrentTime)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, pTimeOut);
}
unsafe extern "C" fn apndGetLastError(
    mut pVfs: *mut sqlite3_vfs,
    mut a: libc::c_int,
    mut b: *mut libc::c_char,
) -> libc::c_int {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xGetLastError)
        .expect("non-null function pointer")((*pVfs).pAppData as *mut sqlite3_vfs, a, b);
}
unsafe extern "C" fn apndCurrentTimeInt64(
    mut pVfs: *mut sqlite3_vfs,
    mut p: *mut sqlite3_int64,
) -> libc::c_int {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xCurrentTimeInt64)
        .expect("non-null function pointer")((*pVfs).pAppData as *mut sqlite3_vfs, p);
}
unsafe extern "C" fn apndSetSystemCall(
    mut pVfs: *mut sqlite3_vfs,
    mut zName: *const libc::c_char,
    mut pCall: sqlite3_syscall_ptr,
) -> libc::c_int {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xSetSystemCall)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, zName, pCall);
}
unsafe extern "C" fn apndGetSystemCall(
    mut pVfs: *mut sqlite3_vfs,
    mut zName: *const libc::c_char,
) -> sqlite3_syscall_ptr {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xGetSystemCall)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, zName);
}
unsafe extern "C" fn apndNextSystemCall(
    mut pVfs: *mut sqlite3_vfs,
    mut zName: *const libc::c_char,
) -> *const libc::c_char {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xNextSystemCall)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, zName);
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_appendvfs_init(
    mut db: *mut sqlite3,
    mut pzErrMsg: *mut *mut libc::c_char,
    mut pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut pOrig: *mut sqlite3_vfs = 0 as *mut sqlite3_vfs;
    pOrig = sqlite3_vfs_find(0 as *const libc::c_char);
    if pOrig.is_null() {
        return 1 as libc::c_int;
    }
    apnd_vfs.iVersion = (*pOrig).iVersion;
    apnd_vfs.pAppData = pOrig as *mut libc::c_void;
    apnd_vfs
        .szOsFile = ((*pOrig).szOsFile as libc::c_ulong)
        .wrapping_add(::std::mem::size_of::<ApndFile>() as libc::c_ulong) as libc::c_int;
    rc = sqlite3_vfs_register(&mut apnd_vfs, 0 as libc::c_int);
    if rc == 0 as libc::c_int {
        rc = 0 as libc::c_int | (1 as libc::c_int) << 8 as libc::c_int;
    }
    return rc;
}
static mut ZIPFILE_SCHEMA: [libc::c_char; 91] = unsafe {
    *::std::mem::transmute::<
        &[u8; 91],
        &[libc::c_char; 91],
    >(
        b"CREATE TABLE y(name PRIMARY KEY,mode,mtime,sz,rawdata,data,method,z HIDDEN) WITHOUT ROWID;\0",
    )
};
unsafe extern "C" fn zipfileCtxErrorMsg(
    mut ctx: *mut sqlite3_context,
    mut zFmt: *const libc::c_char,
    mut args: ...
) {
    let mut zMsg: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut ap: ::std::ffi::VaListImpl;
    ap = args.clone();
    zMsg = sqlite3_vmprintf(zFmt, ap.as_va_list());
    sqlite3_result_error(ctx, zMsg, -(1 as libc::c_int));
    sqlite3_free(zMsg as *mut libc::c_void);
}
unsafe extern "C" fn zipfileDequote(mut zIn: *mut libc::c_char) {
    let mut q: libc::c_char = *zIn.offset(0 as libc::c_int as isize);
    if q as libc::c_int == '"' as i32 || q as libc::c_int == '\'' as i32
        || q as libc::c_int == '`' as i32 || q as libc::c_int == '[' as i32
    {
        let mut iIn: libc::c_int = 1 as libc::c_int;
        let mut iOut: libc::c_int = 0 as libc::c_int;
        if q as libc::c_int == '[' as i32 {
            q = ']' as i32 as libc::c_char;
        }
        while *zIn.offset(iIn as isize) != 0 {
            let fresh108 = iIn;
            iIn = iIn + 1;
            let mut c: libc::c_char = *zIn.offset(fresh108 as isize);
            if c as libc::c_int == q as libc::c_int
                && {
                    let fresh109 = iIn;
                    iIn = iIn + 1;
                    *zIn.offset(fresh109 as isize) as libc::c_int != q as libc::c_int
                }
            {
                break;
            }
            let fresh110 = iOut;
            iOut = iOut + 1;
            *zIn.offset(fresh110 as isize) = c;
        }
        *zIn.offset(iOut as isize) = '\0' as i32 as libc::c_char;
    }
}
unsafe extern "C" fn zipfileConnect(
    mut db: *mut sqlite3,
    mut pAux: *mut libc::c_void,
    mut argc: libc::c_int,
    mut argv: *const *const libc::c_char,
    mut ppVtab: *mut *mut sqlite3_vtab,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut nByte: libc::c_int = (::std::mem::size_of::<ZipfileTab>() as libc::c_ulong)
        .wrapping_add((64 as libc::c_int * 1024 as libc::c_int) as libc::c_ulong)
        as libc::c_int;
    let mut nFile: libc::c_int = 0 as libc::c_int;
    let mut zFile: *const libc::c_char = 0 as *const libc::c_char;
    let mut pNew: *mut ZipfileTab = 0 as *mut ZipfileTab;
    let mut rc: libc::c_int = 0;
    if 0 as libc::c_int
        != sqlite3_stricmp(
            *argv.offset(2 as libc::c_int as isize),
            b"zipfile\0" as *const u8 as *const libc::c_char,
        ) && argc < 4 as libc::c_int || argc > 4 as libc::c_int
    {
        *pzErr = sqlite3_mprintf(
            b"zipfile constructor requires one argument\0" as *const u8
                as *const libc::c_char,
        );
        return 1 as libc::c_int;
    }
    if argc > 3 as libc::c_int {
        zFile = *argv.offset(3 as libc::c_int as isize);
        nFile = strlen(zFile) as libc::c_int + 1 as libc::c_int;
    }
    rc = sqlite3_declare_vtab(db, ZIPFILE_SCHEMA.as_ptr());
    if rc == 0 as libc::c_int {
        pNew = sqlite3_malloc64(
            (nByte as sqlite3_int64 + nFile as libc::c_longlong) as sqlite3_uint64,
        ) as *mut ZipfileTab;
        if pNew.is_null() {
            return 7 as libc::c_int;
        }
        memset(
            pNew as *mut libc::c_void,
            0 as libc::c_int,
            (nByte + nFile) as libc::c_ulong,
        );
        let ref mut fresh111 = (*pNew).db;
        *fresh111 = db;
        let ref mut fresh112 = (*pNew).aBuffer;
        *fresh112 = &mut *pNew.offset(1 as libc::c_int as isize) as *mut ZipfileTab
            as *mut u8_0;
        if !zFile.is_null() {
            let ref mut fresh113 = (*pNew).zFile;
            *fresh113 = &mut *((*pNew).aBuffer)
                .offset((64 as libc::c_int * 1024 as libc::c_int) as isize) as *mut u8_0
                as *mut libc::c_char;
            memcpy(
                (*pNew).zFile as *mut libc::c_void,
                zFile as *const libc::c_void,
                nFile as libc::c_ulong,
            );
            zipfileDequote((*pNew).zFile);
        }
    }
    sqlite3_vtab_config(db, 3 as libc::c_int);
    *ppVtab = pNew as *mut sqlite3_vtab;
    return rc;
}
unsafe extern "C" fn zipfileEntryFree(mut p: *mut ZipfileEntry) {
    if !p.is_null() {
        sqlite3_free((*p).cds.zFile as *mut libc::c_void);
        sqlite3_free(p as *mut libc::c_void);
    }
}
unsafe extern "C" fn zipfileCleanupTransaction(mut pTab: *mut ZipfileTab) {
    let mut pEntry: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
    let mut pNext: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
    if !((*pTab).pWriteFd).is_null() {
        fclose((*pTab).pWriteFd);
        let ref mut fresh114 = (*pTab).pWriteFd;
        *fresh114 = 0 as *mut FILE;
    }
    pEntry = (*pTab).pFirstEntry;
    while !pEntry.is_null() {
        pNext = (*pEntry).pNext;
        zipfileEntryFree(pEntry);
        pEntry = pNext;
    }
    let ref mut fresh115 = (*pTab).pFirstEntry;
    *fresh115 = 0 as *mut ZipfileEntry;
    let ref mut fresh116 = (*pTab).pLastEntry;
    *fresh116 = 0 as *mut ZipfileEntry;
    (*pTab).szCurrent = 0 as libc::c_int as i64_0;
    (*pTab).szOrig = 0 as libc::c_int as i64_0;
}
unsafe extern "C" fn zipfileDisconnect(mut pVtab: *mut sqlite3_vtab) -> libc::c_int {
    zipfileCleanupTransaction(pVtab as *mut ZipfileTab);
    sqlite3_free(pVtab as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn zipfileOpen(
    mut p: *mut sqlite3_vtab,
    mut ppCsr: *mut *mut sqlite3_vtab_cursor,
) -> libc::c_int {
    let mut pTab: *mut ZipfileTab = p as *mut ZipfileTab;
    let mut pCsr: *mut ZipfileCsr = 0 as *mut ZipfileCsr;
    pCsr = sqlite3_malloc(
        ::std::mem::size_of::<ZipfileCsr>() as libc::c_ulong as libc::c_int,
    ) as *mut ZipfileCsr;
    *ppCsr = pCsr as *mut sqlite3_vtab_cursor;
    if pCsr.is_null() {
        return 7 as libc::c_int;
    }
    memset(
        pCsr as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<ZipfileCsr>() as libc::c_ulong,
    );
    let ref mut fresh117 = (*pTab).iNextCsrid;
    *fresh117 += 1;
    (*pCsr).iId = *fresh117;
    let ref mut fresh118 = (*pCsr).pCsrNext;
    *fresh118 = (*pTab).pCsrList;
    let ref mut fresh119 = (*pTab).pCsrList;
    *fresh119 = pCsr;
    return 0 as libc::c_int;
}
unsafe extern "C" fn zipfileResetCursor(mut pCsr: *mut ZipfileCsr) {
    let mut p: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
    let mut pNext: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
    (*pCsr).bEof = 0 as libc::c_int as u8_0;
    if !((*pCsr).pFile).is_null() {
        fclose((*pCsr).pFile);
        let ref mut fresh120 = (*pCsr).pFile;
        *fresh120 = 0 as *mut FILE;
        zipfileEntryFree((*pCsr).pCurrent);
        let ref mut fresh121 = (*pCsr).pCurrent;
        *fresh121 = 0 as *mut ZipfileEntry;
    }
    p = (*pCsr).pFreeEntry;
    while !p.is_null() {
        pNext = (*p).pNext;
        zipfileEntryFree(p);
        p = pNext;
    }
}
unsafe extern "C" fn zipfileClose(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCsr: *mut ZipfileCsr = cur as *mut ZipfileCsr;
    let mut pTab: *mut ZipfileTab = (*pCsr).base.pVtab as *mut ZipfileTab;
    let mut pp: *mut *mut ZipfileCsr = 0 as *mut *mut ZipfileCsr;
    zipfileResetCursor(pCsr);
    pp = &mut (*pTab).pCsrList;
    while *pp != pCsr {
        pp = &mut (**pp).pCsrNext;
    }
    *pp = (*pCsr).pCsrNext;
    sqlite3_free(pCsr as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn zipfileTableErr(
    mut pTab: *mut ZipfileTab,
    mut zFmt: *const libc::c_char,
    mut args: ...
) {
    let mut ap: ::std::ffi::VaListImpl;
    ap = args.clone();
    sqlite3_free((*pTab).base.zErrMsg as *mut libc::c_void);
    let ref mut fresh122 = (*pTab).base.zErrMsg;
    *fresh122 = sqlite3_vmprintf(zFmt, ap.as_va_list());
}
unsafe extern "C" fn zipfileCursorErr(
    mut pCsr: *mut ZipfileCsr,
    mut zFmt: *const libc::c_char,
    mut args: ...
) {
    let mut ap: ::std::ffi::VaListImpl;
    ap = args.clone();
    sqlite3_free((*(*pCsr).base.pVtab).zErrMsg as *mut libc::c_void);
    let ref mut fresh123 = (*(*pCsr).base.pVtab).zErrMsg;
    *fresh123 = sqlite3_vmprintf(zFmt, ap.as_va_list());
}
unsafe extern "C" fn zipfileReadData(
    mut pFile: *mut FILE,
    mut aRead: *mut u8_0,
    mut nRead: libc::c_int,
    mut iOff: i64_0,
    mut pzErrmsg: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut n: size_t = 0;
    fseek(pFile, iOff as libc::c_long, 0 as libc::c_int);
    n = fread(
        aRead as *mut libc::c_void,
        1 as libc::c_int as libc::c_ulong,
        nRead as libc::c_ulong,
        pFile,
    );
    if n as libc::c_int != nRead {
        *pzErrmsg = sqlite3_mprintf(
            b"error in fread()\0" as *const u8 as *const libc::c_char,
        );
        return 1 as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn zipfileAppendData(
    mut pTab: *mut ZipfileTab,
    mut aWrite: *const u8_0,
    mut nWrite: libc::c_int,
) -> libc::c_int {
    if nWrite > 0 as libc::c_int {
        let mut n: size_t = nWrite as size_t;
        fseek((*pTab).pWriteFd, (*pTab).szCurrent as libc::c_long, 0 as libc::c_int);
        n = fwrite(
            aWrite as *const libc::c_void,
            1 as libc::c_int as libc::c_ulong,
            nWrite as libc::c_ulong,
            (*pTab).pWriteFd,
        );
        if n as libc::c_int != nWrite {
            let ref mut fresh124 = (*pTab).base.zErrMsg;
            *fresh124 = sqlite3_mprintf(
                b"error in fwrite()\0" as *const u8 as *const libc::c_char,
            );
            return 1 as libc::c_int;
        }
        let ref mut fresh125 = (*pTab).szCurrent;
        *fresh125 += nWrite as libc::c_longlong;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn zipfileGetU16(mut aBuf: *const u8_0) -> u16_0 {
    return (((*aBuf.offset(1 as libc::c_int as isize) as libc::c_int)
        << 8 as libc::c_int) + *aBuf.offset(0 as libc::c_int as isize) as libc::c_int)
        as u16_0;
}
unsafe extern "C" fn zipfileGetU32(mut aBuf: *const u8_0) -> u32_0 {
    if aBuf.is_null() {
        return 0 as libc::c_int as u32_0;
    }
    return ((*aBuf.offset(3 as libc::c_int as isize) as u32_0) << 24 as libc::c_int)
        .wrapping_add(
            (*aBuf.offset(2 as libc::c_int as isize) as u32_0) << 16 as libc::c_int,
        )
        .wrapping_add(
            (*aBuf.offset(1 as libc::c_int as isize) as u32_0) << 8 as libc::c_int,
        )
        .wrapping_add(
            (*aBuf.offset(0 as libc::c_int as isize) as u32_0) << 0 as libc::c_int,
        );
}
unsafe extern "C" fn zipfilePutU16(mut aBuf: *mut u8_0, mut val: u16_0) {
    *aBuf
        .offset(
            0 as libc::c_int as isize,
        ) = (val as libc::c_int & 0xff as libc::c_int) as u8_0;
    *aBuf
        .offset(
            1 as libc::c_int as isize,
        ) = (val as libc::c_int >> 8 as libc::c_int & 0xff as libc::c_int) as u8_0;
}
unsafe extern "C" fn zipfilePutU32(mut aBuf: *mut u8_0, mut val: u32_0) {
    *aBuf
        .offset(
            0 as libc::c_int as isize,
        ) = (val & 0xff as libc::c_int as libc::c_uint) as u8_0;
    *aBuf
        .offset(
            1 as libc::c_int as isize,
        ) = (val >> 8 as libc::c_int & 0xff as libc::c_int as libc::c_uint) as u8_0;
    *aBuf
        .offset(
            2 as libc::c_int as isize,
        ) = (val >> 16 as libc::c_int & 0xff as libc::c_int as libc::c_uint) as u8_0;
    *aBuf
        .offset(
            3 as libc::c_int as isize,
        ) = (val >> 24 as libc::c_int & 0xff as libc::c_int as libc::c_uint) as u8_0;
}
unsafe extern "C" fn zipfileReadCDS(
    mut aBuf: *mut u8_0,
    mut pCDS: *mut ZipfileCDS,
) -> libc::c_int {
    let mut aRead: *mut u8_0 = aBuf;
    aRead = aRead.offset(4 as libc::c_int as isize);
    let mut sig: u32_0 = zipfileGetU32(aRead.offset(-(4 as libc::c_int as isize)));
    let mut rc: libc::c_int = 0 as libc::c_int;
    if sig != 0x2014b50 as libc::c_int as libc::c_uint {
        rc = 1 as libc::c_int;
    } else {
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pCDS)
            .iVersionMadeBy = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pCDS)
            .iVersionExtract = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pCDS).flags = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pCDS).iCompression = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pCDS).mTime = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pCDS).mDate = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(4 as libc::c_int as isize);
        (*pCDS).crc32 = zipfileGetU32(aRead.offset(-(4 as libc::c_int as isize)));
        aRead = aRead.offset(4 as libc::c_int as isize);
        (*pCDS).szCompressed = zipfileGetU32(aRead.offset(-(4 as libc::c_int as isize)));
        aRead = aRead.offset(4 as libc::c_int as isize);
        (*pCDS)
            .szUncompressed = zipfileGetU32(aRead.offset(-(4 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pCDS).nFile = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pCDS).nExtra = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pCDS).nComment = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pCDS).iDiskStart = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pCDS)
            .iInternalAttr = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(4 as libc::c_int as isize);
        (*pCDS)
            .iExternalAttr = zipfileGetU32(aRead.offset(-(4 as libc::c_int as isize)));
        aRead = aRead.offset(4 as libc::c_int as isize);
        (*pCDS).iOffset = zipfileGetU32(aRead.offset(-(4 as libc::c_int as isize)));
    }
    return rc;
}
unsafe extern "C" fn zipfileReadLFH(
    mut aBuffer: *mut u8_0,
    mut pLFH: *mut ZipfileLFH,
) -> libc::c_int {
    let mut aRead: *mut u8_0 = aBuffer;
    let mut rc: libc::c_int = 0 as libc::c_int;
    aRead = aRead.offset(4 as libc::c_int as isize);
    let mut sig: u32_0 = zipfileGetU32(aRead.offset(-(4 as libc::c_int as isize)));
    if sig != 0x4034b50 as libc::c_int as libc::c_uint {
        rc = 1 as libc::c_int;
    } else {
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pLFH)
            .iVersionExtract = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pLFH).flags = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pLFH).iCompression = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pLFH).mTime = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pLFH).mDate = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(4 as libc::c_int as isize);
        (*pLFH).crc32 = zipfileGetU32(aRead.offset(-(4 as libc::c_int as isize)));
        aRead = aRead.offset(4 as libc::c_int as isize);
        (*pLFH).szCompressed = zipfileGetU32(aRead.offset(-(4 as libc::c_int as isize)));
        aRead = aRead.offset(4 as libc::c_int as isize);
        (*pLFH)
            .szUncompressed = zipfileGetU32(aRead.offset(-(4 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pLFH).nFile = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pLFH).nExtra = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
    }
    return rc;
}
unsafe extern "C" fn zipfileScanExtra(
    mut aExtra: *mut u8_0,
    mut nExtra: libc::c_int,
    mut pmTime: *mut u32_0,
) -> libc::c_int {
    let mut ret: libc::c_int = 0 as libc::c_int;
    let mut p: *mut u8_0 = aExtra;
    let mut pEnd: *mut u8_0 = &mut *aExtra.offset(nExtra as isize) as *mut u8_0;
    while p < pEnd {
        p = p.offset(2 as libc::c_int as isize);
        let mut id: u16_0 = zipfileGetU16(p.offset(-(2 as libc::c_int as isize)));
        p = p.offset(2 as libc::c_int as isize);
        let mut nByte: u16_0 = zipfileGetU16(p.offset(-(2 as libc::c_int as isize)));
        match id as libc::c_int {
            21589 => {
                let mut b: u8_0 = *p.offset(0 as libc::c_int as isize);
                if b as libc::c_int & 0x1 as libc::c_int != 0 {
                    *pmTime = zipfileGetU32(&mut *p.offset(1 as libc::c_int as isize));
                    ret = 1 as libc::c_int;
                }
            }
            _ => {}
        }
        p = p.offset(nByte as libc::c_int as isize);
    }
    return ret;
}
unsafe extern "C" fn zipfileMtime(mut pCDS: *mut ZipfileCDS) -> u32_0 {
    let mut Y: libc::c_int = 0;
    let mut M: libc::c_int = 0;
    let mut D: libc::c_int = 0;
    let mut X1: libc::c_int = 0;
    let mut X2: libc::c_int = 0;
    let mut A: libc::c_int = 0;
    let mut B: libc::c_int = 0;
    let mut sec: libc::c_int = 0;
    let mut min: libc::c_int = 0;
    let mut hr: libc::c_int = 0;
    let mut JDsec: i64_0 = 0;
    Y = 1980 as libc::c_int
        + ((*pCDS).mDate as libc::c_int >> 9 as libc::c_int & 0x7f as libc::c_int);
    M = (*pCDS).mDate as libc::c_int >> 5 as libc::c_int & 0xf as libc::c_int;
    D = (*pCDS).mDate as libc::c_int & 0x1f as libc::c_int;
    sec = ((*pCDS).mTime as libc::c_int & 0x1f as libc::c_int) * 2 as libc::c_int;
    min = (*pCDS).mTime as libc::c_int >> 5 as libc::c_int & 0x3f as libc::c_int;
    hr = (*pCDS).mTime as libc::c_int >> 11 as libc::c_int & 0x1f as libc::c_int;
    if M <= 2 as libc::c_int {
        Y -= 1;
        M += 12 as libc::c_int;
    }
    X1 = 36525 as libc::c_int * (Y + 4716 as libc::c_int) / 100 as libc::c_int;
    X2 = 306001 as libc::c_int * (M + 1 as libc::c_int) / 10000 as libc::c_int;
    A = Y / 100 as libc::c_int;
    B = 2 as libc::c_int - A + A / 4 as libc::c_int;
    JDsec = (((X1 + X2 + D + B) as libc::c_double - 1524.5f64)
        * 86400 as libc::c_int as libc::c_double) as i64_0
        + (hr * 3600 as libc::c_int) as libc::c_longlong
        + (min * 60 as libc::c_int) as libc::c_longlong + sec as libc::c_longlong;
    return (JDsec - 24405875 as libc::c_int as i64_0 * 8640 as libc::c_int as i64_0)
        as u32_0;
}
unsafe extern "C" fn zipfileMtimeToDos(mut pCds: *mut ZipfileCDS, mut mUnixTime: u32_0) {
    let mut JD: i64_0 = 2440588 as libc::c_int as i64_0
        + mUnixTime
            .wrapping_div(
                (24 as libc::c_int * 60 as libc::c_int * 60 as libc::c_int)
                    as libc::c_uint,
            ) as libc::c_longlong;
    let mut A: libc::c_int = 0;
    let mut B: libc::c_int = 0;
    let mut C: libc::c_int = 0;
    let mut D: libc::c_int = 0;
    let mut E: libc::c_int = 0;
    let mut yr: libc::c_int = 0;
    let mut mon: libc::c_int = 0;
    let mut day: libc::c_int = 0;
    let mut hr: libc::c_int = 0;
    let mut min: libc::c_int = 0;
    let mut sec: libc::c_int = 0;
    A = ((JD as libc::c_double - 1867216.25f64) / 36524.25f64) as libc::c_int;
    A = (JD + 1 as libc::c_int as libc::c_longlong + A as libc::c_longlong
        - (A / 4 as libc::c_int) as libc::c_longlong) as libc::c_int;
    B = A + 1524 as libc::c_int;
    C = ((B as libc::c_double - 122.1f64) / 365.25f64) as libc::c_int;
    D = 36525 as libc::c_int * (C & 32767 as libc::c_int) / 100 as libc::c_int;
    E = ((B - D) as libc::c_double / 30.6001f64) as libc::c_int;
    day = B - D - (30.6001f64 * E as libc::c_double) as libc::c_int;
    mon = if E < 14 as libc::c_int {
        E - 1 as libc::c_int
    } else {
        E - 13 as libc::c_int
    };
    yr = if mon > 2 as libc::c_int {
        C - 4716 as libc::c_int
    } else {
        C - 4715 as libc::c_int
    };
    hr = mUnixTime
        .wrapping_rem(
            (24 as libc::c_int * 60 as libc::c_int * 60 as libc::c_int) as libc::c_uint,
        )
        .wrapping_div((60 as libc::c_int * 60 as libc::c_int) as libc::c_uint)
        as libc::c_int;
    min = mUnixTime
        .wrapping_rem((60 as libc::c_int * 60 as libc::c_int) as libc::c_uint)
        .wrapping_div(60 as libc::c_int as libc::c_uint) as libc::c_int;
    sec = mUnixTime.wrapping_rem(60 as libc::c_int as libc::c_uint) as libc::c_int;
    if yr >= 1980 as libc::c_int {
        (*pCds)
            .mDate = (day + (mon << 5 as libc::c_int)
            + ((yr - 1980 as libc::c_int) << 9 as libc::c_int)) as u16_0;
        (*pCds)
            .mTime = (sec / 2 as libc::c_int + (min << 5 as libc::c_int)
            + (hr << 11 as libc::c_int)) as u16_0;
    } else {
        let ref mut fresh126 = (*pCds).mTime;
        *fresh126 = 0 as libc::c_int as u16_0;
        (*pCds).mDate = *fresh126;
    };
}
unsafe extern "C" fn zipfileGetEntry(
    mut pTab: *mut ZipfileTab,
    mut aBlob: *const u8_0,
    mut nBlob: libc::c_int,
    mut pFile: *mut FILE,
    mut iOff: i64_0,
    mut ppEntry: *mut *mut ZipfileEntry,
) -> libc::c_int {
    let mut aRead: *mut u8_0 = 0 as *mut u8_0;
    let mut pzErr: *mut *mut libc::c_char = &mut (*pTab).base.zErrMsg;
    let mut rc: libc::c_int = 0 as libc::c_int;
    if aBlob.is_null() {
        aRead = (*pTab).aBuffer;
        rc = zipfileReadData(pFile, aRead, 46 as libc::c_int, iOff, pzErr);
    } else {
        aRead = &*aBlob.offset(iOff as isize) as *const u8_0 as *mut u8_0;
    }
    if rc == 0 as libc::c_int {
        let mut nAlloc: sqlite3_int64 = 0;
        let mut pNew: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
        let mut nFile: libc::c_int = zipfileGetU16(
            &mut *aRead.offset(28 as libc::c_int as isize),
        ) as libc::c_int;
        let mut nExtra: libc::c_int = zipfileGetU16(
            &mut *aRead.offset((28 as libc::c_int + 2 as libc::c_int) as isize),
        ) as libc::c_int;
        nExtra
            += zipfileGetU16(
                &mut *aRead.offset((28 as libc::c_int + 4 as libc::c_int) as isize),
            ) as libc::c_int;
        nAlloc = (::std::mem::size_of::<ZipfileEntry>() as libc::c_ulong)
            .wrapping_add(nExtra as libc::c_ulong) as sqlite3_int64;
        if !aBlob.is_null() {
            nAlloc
                += zipfileGetU32(&mut *aRead.offset(20 as libc::c_int as isize))
                    as libc::c_longlong;
        }
        pNew = sqlite3_malloc64(nAlloc as sqlite3_uint64) as *mut ZipfileEntry;
        if pNew.is_null() {
            rc = 7 as libc::c_int;
        } else {
            memset(
                pNew as *mut libc::c_void,
                0 as libc::c_int,
                ::std::mem::size_of::<ZipfileEntry>() as libc::c_ulong,
            );
            rc = zipfileReadCDS(aRead, &mut (*pNew).cds);
            if rc != 0 as libc::c_int {
                *pzErr = sqlite3_mprintf(
                    b"failed to read CDS at offset %lld\0" as *const u8
                        as *const libc::c_char,
                    iOff,
                );
            } else if aBlob.is_null() {
                rc = zipfileReadData(
                    pFile,
                    aRead,
                    nExtra + nFile,
                    iOff + 46 as libc::c_int as libc::c_longlong,
                    pzErr,
                );
            } else {
                aRead = &*aBlob
                    .offset((iOff + 46 as libc::c_int as libc::c_longlong) as isize)
                    as *const u8_0 as *mut u8_0;
            }
        }
        if rc == 0 as libc::c_int {
            let mut pt: *mut u32_0 = &mut (*pNew).mUnixTime;
            let ref mut fresh127 = (*pNew).cds.zFile;
            *fresh127 = sqlite3_mprintf(
                b"%.*s\0" as *const u8 as *const libc::c_char,
                nFile,
                aRead,
            );
            let ref mut fresh128 = (*pNew).aExtra;
            *fresh128 = &mut *pNew.offset(1 as libc::c_int as isize) as *mut ZipfileEntry
                as *mut u8_0;
            memcpy(
                (*pNew).aExtra as *mut libc::c_void,
                &mut *aRead.offset(nFile as isize) as *mut u8_0 as *const libc::c_void,
                nExtra as libc::c_ulong,
            );
            if ((*pNew).cds.zFile).is_null() {
                rc = 7 as libc::c_int;
            } else if 0 as libc::c_int
                == zipfileScanExtra(
                    &mut *aRead.offset(nFile as isize),
                    (*pNew).cds.nExtra as libc::c_int,
                    pt,
                )
            {
                (*pNew).mUnixTime = zipfileMtime(&mut (*pNew).cds);
            }
        }
        if rc == 0 as libc::c_int {
            static mut szFix: libc::c_int = 30 as libc::c_int;
            let mut lfh: ZipfileLFH = ZipfileLFH {
                iVersionExtract: 0,
                flags: 0,
                iCompression: 0,
                mTime: 0,
                mDate: 0,
                crc32: 0,
                szCompressed: 0,
                szUncompressed: 0,
                nFile: 0,
                nExtra: 0,
            };
            if !pFile.is_null() {
                rc = zipfileReadData(
                    pFile,
                    aRead,
                    szFix,
                    (*pNew).cds.iOffset as i64_0,
                    pzErr,
                );
            } else {
                aRead = &*aBlob.offset((*pNew).cds.iOffset as isize) as *const u8_0
                    as *mut u8_0;
            }
            if rc == 0 as libc::c_int {
                rc = zipfileReadLFH(aRead, &mut lfh);
            }
            if rc == 0 as libc::c_int {
                (*pNew)
                    .iDataOff = ((*pNew).cds.iOffset)
                    .wrapping_add(30 as libc::c_int as libc::c_uint) as i64_0;
                let ref mut fresh129 = (*pNew).iDataOff;
                *fresh129
                    += (lfh.nFile as libc::c_int + lfh.nExtra as libc::c_int)
                        as libc::c_longlong;
                if !aBlob.is_null() && (*pNew).cds.szCompressed != 0 {
                    let ref mut fresh130 = (*pNew).aData;
                    *fresh130 = &mut *((*pNew).aExtra).offset(nExtra as isize)
                        as *mut u8_0;
                    memcpy(
                        (*pNew).aData as *mut libc::c_void,
                        &*aBlob.offset((*pNew).iDataOff as isize) as *const u8_0
                            as *const libc::c_void,
                        (*pNew).cds.szCompressed as libc::c_ulong,
                    );
                }
            } else {
                *pzErr = sqlite3_mprintf(
                    b"failed to read LFH at offset %d\0" as *const u8
                        as *const libc::c_char,
                    (*pNew).cds.iOffset as libc::c_int,
                );
            }
        }
        if rc != 0 as libc::c_int {
            zipfileEntryFree(pNew);
        } else {
            *ppEntry = pNew;
        }
    }
    return rc;
}
unsafe extern "C" fn zipfileNext(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCsr: *mut ZipfileCsr = cur as *mut ZipfileCsr;
    let mut rc: libc::c_int = 0 as libc::c_int;
    if !((*pCsr).pFile).is_null() {
        let mut iEof: i64_0 = ((*pCsr).eocd.iOffset).wrapping_add((*pCsr).eocd.nSize)
            as i64_0;
        zipfileEntryFree((*pCsr).pCurrent);
        let ref mut fresh131 = (*pCsr).pCurrent;
        *fresh131 = 0 as *mut ZipfileEntry;
        if (*pCsr).iNextOff >= iEof {
            (*pCsr).bEof = 1 as libc::c_int as u8_0;
        } else {
            let mut p: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
            let mut pTab: *mut ZipfileTab = (*cur).pVtab as *mut ZipfileTab;
            rc = zipfileGetEntry(
                pTab,
                0 as *const u8_0,
                0 as libc::c_int,
                (*pCsr).pFile,
                (*pCsr).iNextOff,
                &mut p,
            );
            if rc == 0 as libc::c_int {
                let ref mut fresh132 = (*pCsr).iNextOff;
                *fresh132 += 46 as libc::c_int as libc::c_longlong;
                let ref mut fresh133 = (*pCsr).iNextOff;
                *fresh133
                    += ((*p).cds.nExtra as libc::c_int + (*p).cds.nFile as libc::c_int
                        + (*p).cds.nComment as libc::c_int) as libc::c_longlong;
            }
            let ref mut fresh134 = (*pCsr).pCurrent;
            *fresh134 = p;
        }
    } else {
        if (*pCsr).bNoop == 0 {
            let ref mut fresh135 = (*pCsr).pCurrent;
            *fresh135 = (*(*pCsr).pCurrent).pNext;
        }
        if ((*pCsr).pCurrent).is_null() {
            (*pCsr).bEof = 1 as libc::c_int as u8_0;
        }
    }
    (*pCsr).bNoop = 0 as libc::c_int as u8_0;
    return rc;
}
unsafe extern "C" fn zipfileFree(mut p: *mut libc::c_void) {
    sqlite3_free(p);
}
unsafe extern "C" fn zipfileInflate(
    mut pCtx: *mut sqlite3_context,
    mut aIn: *const u8_0,
    mut nIn: libc::c_int,
    mut nOut: libc::c_int,
) {
    let mut aRes: *mut u8_0 = sqlite3_malloc(nOut) as *mut u8_0;
    if aRes.is_null() {
        sqlite3_result_error_nomem(pCtx);
    } else {
        let mut err: libc::c_int = 0;
        let mut str: z_stream = z_stream {
            next_in: 0 as *mut Bytef,
            avail_in: 0,
            total_in: 0,
            next_out: 0 as *mut Bytef,
            avail_out: 0,
            total_out: 0,
            msg: 0 as *mut libc::c_char,
            state: 0 as *mut internal_state,
            zalloc: None,
            zfree: None,
            opaque: 0 as *mut libc::c_void,
            data_type: 0,
            adler: 0,
            reserved: 0,
        };
        memset(
            &mut str as *mut z_stream as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<z_stream>() as libc::c_ulong,
        );
        str.next_in = aIn as *mut Byte;
        str.avail_in = nIn as uInt;
        str.next_out = aRes as *mut Byte;
        str.avail_out = nOut as uInt;
        err = inflateInit2_(
            &mut str,
            -(15 as libc::c_int),
            b"1.2.11\0" as *const u8 as *const libc::c_char,
            ::std::mem::size_of::<z_stream>() as libc::c_ulong as libc::c_int,
        );
        if err != 0 as libc::c_int {
            zipfileCtxErrorMsg(
                pCtx,
                b"inflateInit2() failed (%d)\0" as *const u8 as *const libc::c_char,
                err,
            );
        } else {
            err = inflate(&mut str, 0 as libc::c_int);
            if err != 1 as libc::c_int {
                zipfileCtxErrorMsg(
                    pCtx,
                    b"inflate() failed (%d)\0" as *const u8 as *const libc::c_char,
                    err,
                );
            } else {
                sqlite3_result_blob(
                    pCtx,
                    aRes as *const libc::c_void,
                    nOut,
                    Some(zipfileFree as unsafe extern "C" fn(*mut libc::c_void) -> ()),
                );
                aRes = 0 as *mut u8_0;
            }
        }
        sqlite3_free(aRes as *mut libc::c_void);
        inflateEnd(&mut str);
    };
}
unsafe extern "C" fn zipfileDeflate(
    mut aIn: *const u8_0,
    mut nIn: libc::c_int,
    mut ppOut: *mut *mut u8_0,
    mut pnOut: *mut libc::c_int,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut nAlloc: sqlite3_int64 = 0;
    let mut str: z_stream = z_stream {
        next_in: 0 as *mut Bytef,
        avail_in: 0,
        total_in: 0,
        next_out: 0 as *mut Bytef,
        avail_out: 0,
        total_out: 0,
        msg: 0 as *mut libc::c_char,
        state: 0 as *mut internal_state,
        zalloc: None,
        zfree: None,
        opaque: 0 as *mut libc::c_void,
        data_type: 0,
        adler: 0,
        reserved: 0,
    };
    let mut aOut: *mut u8_0 = 0 as *mut u8_0;
    memset(
        &mut str as *mut z_stream as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<z_stream>() as libc::c_ulong,
    );
    str.next_in = aIn as *mut Bytef;
    str.avail_in = nIn as uInt;
    deflateInit2_(
        &mut str,
        9 as libc::c_int,
        8 as libc::c_int,
        -(15 as libc::c_int),
        8 as libc::c_int,
        0 as libc::c_int,
        b"1.2.11\0" as *const u8 as *const libc::c_char,
        ::std::mem::size_of::<z_stream>() as libc::c_ulong as libc::c_int,
    );
    nAlloc = deflateBound(&mut str, nIn as uLong) as sqlite3_int64;
    aOut = sqlite3_malloc64(nAlloc as sqlite3_uint64) as *mut u8_0;
    if aOut.is_null() {
        rc = 7 as libc::c_int;
    } else {
        let mut res: libc::c_int = 0;
        str.next_out = aOut;
        str.avail_out = nAlloc as uInt;
        res = deflate(&mut str, 4 as libc::c_int);
        if res == 1 as libc::c_int {
            *ppOut = aOut;
            *pnOut = str.total_out as libc::c_int;
        } else {
            sqlite3_free(aOut as *mut libc::c_void);
            *pzErr = sqlite3_mprintf(
                b"zipfile: deflate() error\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
        deflateEnd(&mut str);
    }
    return rc;
}
unsafe extern "C" fn zipfileColumn(
    mut cur: *mut sqlite3_vtab_cursor,
    mut ctx: *mut sqlite3_context,
    mut i: libc::c_int,
) -> libc::c_int {
    let mut pCsr: *mut ZipfileCsr = cur as *mut ZipfileCsr;
    let mut pCDS: *mut ZipfileCDS = &mut (*(*pCsr).pCurrent).cds;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut current_block_37: u64;
    match i {
        0 => {
            sqlite3_result_text(
                ctx,
                (*pCDS).zFile,
                -(1 as libc::c_int),
                ::std::mem::transmute::<
                    libc::intptr_t,
                    sqlite3_destructor_type,
                >(-(1 as libc::c_int) as libc::intptr_t),
            );
            current_block_37 = 13619784596304402172;
        }
        1 => {
            sqlite3_result_int(
                ctx,
                ((*pCDS).iExternalAttr >> 16 as libc::c_int) as libc::c_int,
            );
            current_block_37 = 13619784596304402172;
        }
        2 => {
            sqlite3_result_int64(ctx, (*(*pCsr).pCurrent).mUnixTime as sqlite3_int64);
            current_block_37 = 13619784596304402172;
        }
        3 => {
            if sqlite3_vtab_nochange(ctx) == 0 as libc::c_int {
                sqlite3_result_int64(ctx, (*pCDS).szUncompressed as sqlite3_int64);
            }
            current_block_37 = 13619784596304402172;
        }
        4 => {
            if sqlite3_vtab_nochange(ctx) != 0 {
                current_block_37 = 13619784596304402172;
            } else {
                current_block_37 = 10599921512955367680;
            }
        }
        5 => {
            current_block_37 = 10599921512955367680;
        }
        6 => {
            sqlite3_result_int(ctx, (*pCDS).iCompression as libc::c_int);
            current_block_37 = 13619784596304402172;
        }
        _ => {
            sqlite3_result_int64(ctx, (*pCsr).iId);
            current_block_37 = 13619784596304402172;
        }
    }
    match current_block_37 {
        10599921512955367680 => {
            if i == 4 as libc::c_int
                || (*pCDS).iCompression as libc::c_int == 0 as libc::c_int
                || (*pCDS).iCompression as libc::c_int == 8 as libc::c_int
            {
                let mut sz: libc::c_int = (*pCDS).szCompressed as libc::c_int;
                let mut szFinal: libc::c_int = (*pCDS).szUncompressed as libc::c_int;
                if szFinal > 0 as libc::c_int {
                    let mut aBuf: *mut u8_0 = 0 as *mut u8_0;
                    let mut aFree: *mut u8_0 = 0 as *mut u8_0;
                    if !((*(*pCsr).pCurrent).aData).is_null() {
                        aBuf = (*(*pCsr).pCurrent).aData;
                    } else {
                        aFree = sqlite3_malloc64(sz as sqlite3_uint64) as *mut u8_0;
                        aBuf = aFree;
                        if aBuf.is_null() {
                            rc = 7 as libc::c_int;
                        } else {
                            let mut pFile: *mut FILE = (*pCsr).pFile;
                            if pFile.is_null() {
                                pFile = (*((*pCsr).base.pVtab as *mut ZipfileTab)).pWriteFd;
                            }
                            rc = zipfileReadData(
                                pFile,
                                aBuf,
                                sz,
                                (*(*pCsr).pCurrent).iDataOff,
                                &mut (*(*pCsr).base.pVtab).zErrMsg,
                            );
                        }
                    }
                    if rc == 0 as libc::c_int {
                        if i == 5 as libc::c_int
                            && (*pCDS).iCompression as libc::c_int != 0
                        {
                            zipfileInflate(ctx, aBuf, sz, szFinal);
                        } else {
                            sqlite3_result_blob(
                                ctx,
                                aBuf as *const libc::c_void,
                                sz,
                                ::std::mem::transmute::<
                                    libc::intptr_t,
                                    sqlite3_destructor_type,
                                >(-(1 as libc::c_int) as libc::intptr_t),
                            );
                        }
                    }
                    sqlite3_free(aFree as *mut libc::c_void);
                } else {
                    let mut mode: u32_0 = (*pCDS).iExternalAttr >> 16 as libc::c_int;
                    if mode & 0o40000 as libc::c_int as libc::c_uint == 0
                        && *((*pCDS).zFile)
                            .offset(
                                ((*pCDS).nFile as libc::c_int - 1 as libc::c_int) as isize,
                            ) as libc::c_int != '/' as i32
                    {
                        sqlite3_result_blob(
                            ctx,
                            b"\0" as *const u8 as *const libc::c_char
                                as *const libc::c_void,
                            0 as libc::c_int,
                            None,
                        );
                    }
                }
            }
        }
        _ => {}
    }
    return rc;
}
unsafe extern "C" fn zipfileEof(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCsr: *mut ZipfileCsr = cur as *mut ZipfileCsr;
    return (*pCsr).bEof as libc::c_int;
}
unsafe extern "C" fn zipfileReadEOCD(
    mut pTab: *mut ZipfileTab,
    mut aBlob: *const u8_0,
    mut nBlob: libc::c_int,
    mut pFile: *mut FILE,
    mut pEOCD: *mut ZipfileEOCD,
) -> libc::c_int {
    let mut aRead: *mut u8_0 = (*pTab).aBuffer;
    let mut nRead: libc::c_int = 0;
    let mut rc: libc::c_int = 0 as libc::c_int;
    memset(
        pEOCD as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<ZipfileEOCD>() as libc::c_ulong,
    );
    if aBlob.is_null() {
        let mut iOff: i64_0 = 0;
        let mut szFile: i64_0 = 0;
        fseek(pFile, 0 as libc::c_int as libc::c_long, 2 as libc::c_int);
        szFile = ftell(pFile) as i64_0;
        if szFile == 0 as libc::c_int as libc::c_longlong {
            return 0 as libc::c_int;
        }
        nRead = (if szFile
            < (64 as libc::c_int * 1024 as libc::c_int) as libc::c_longlong
        {
            szFile
        } else {
            (64 as libc::c_int * 1024 as libc::c_int) as libc::c_longlong
        }) as libc::c_int;
        iOff = szFile - nRead as libc::c_longlong;
        rc = zipfileReadData(pFile, aRead, nRead, iOff, &mut (*pTab).base.zErrMsg);
    } else {
        nRead = if nBlob < 64 as libc::c_int * 1024 as libc::c_int {
            nBlob
        } else {
            64 as libc::c_int * 1024 as libc::c_int
        };
        aRead = &*aBlob.offset((nBlob - nRead) as isize) as *const u8_0 as *mut u8_0;
    }
    if rc == 0 as libc::c_int {
        let mut i: libc::c_int = 0;
        i = nRead - 20 as libc::c_int;
        while i >= 0 as libc::c_int {
            if *aRead.offset(i as isize) as libc::c_int == 0x50 as libc::c_int
                && *aRead.offset((i + 1 as libc::c_int) as isize) as libc::c_int
                    == 0x4b as libc::c_int
                && *aRead.offset((i + 2 as libc::c_int) as isize) as libc::c_int
                    == 0x5 as libc::c_int
                && *aRead.offset((i + 3 as libc::c_int) as isize) as libc::c_int
                    == 0x6 as libc::c_int
            {
                break;
            }
            i -= 1;
        }
        if i < 0 as libc::c_int {
            let ref mut fresh136 = (*pTab).base.zErrMsg;
            *fresh136 = sqlite3_mprintf(
                b"cannot find end of central directory record\0" as *const u8
                    as *const libc::c_char,
            );
            return 1 as libc::c_int;
        }
        aRead = aRead.offset((i + 4 as libc::c_int) as isize);
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pEOCD).iDisk = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pEOCD).iFirstDisk = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pEOCD).nEntry = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pEOCD).nEntryTotal = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(4 as libc::c_int as isize);
        (*pEOCD).nSize = zipfileGetU32(aRead.offset(-(4 as libc::c_int as isize)));
        aRead = aRead.offset(4 as libc::c_int as isize);
        (*pEOCD).iOffset = zipfileGetU32(aRead.offset(-(4 as libc::c_int as isize)));
    }
    return rc;
}
unsafe extern "C" fn zipfileAddEntry(
    mut pTab: *mut ZipfileTab,
    mut pBefore: *mut ZipfileEntry,
    mut pNew: *mut ZipfileEntry,
) {
    if pBefore.is_null() {
        if ((*pTab).pFirstEntry).is_null() {
            let ref mut fresh137 = (*pTab).pLastEntry;
            *fresh137 = pNew;
            let ref mut fresh138 = (*pTab).pFirstEntry;
            *fresh138 = *fresh137;
        } else {
            let ref mut fresh139 = (*(*pTab).pLastEntry).pNext;
            *fresh139 = pNew;
            let ref mut fresh140 = (*pTab).pLastEntry;
            *fresh140 = pNew;
        }
    } else {
        let mut pp: *mut *mut ZipfileEntry = 0 as *mut *mut ZipfileEntry;
        pp = &mut (*pTab).pFirstEntry;
        while *pp != pBefore {
            pp = &mut (**pp).pNext;
        }
        let ref mut fresh141 = (*pNew).pNext;
        *fresh141 = pBefore;
        *pp = pNew;
    };
}
unsafe extern "C" fn zipfileLoadDirectory(
    mut pTab: *mut ZipfileTab,
    mut aBlob: *const u8_0,
    mut nBlob: libc::c_int,
) -> libc::c_int {
    let mut eocd: ZipfileEOCD = ZipfileEOCD {
        iDisk: 0,
        iFirstDisk: 0,
        nEntry: 0,
        nEntryTotal: 0,
        nSize: 0,
        iOffset: 0,
    };
    let mut rc: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut iOff: i64_0 = 0;
    rc = zipfileReadEOCD(pTab, aBlob, nBlob, (*pTab).pWriteFd, &mut eocd);
    iOff = eocd.iOffset as i64_0;
    i = 0 as libc::c_int;
    while rc == 0 as libc::c_int && i < eocd.nEntry as libc::c_int {
        let mut pNew: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
        rc = zipfileGetEntry(pTab, aBlob, nBlob, (*pTab).pWriteFd, iOff, &mut pNew);
        if rc == 0 as libc::c_int {
            zipfileAddEntry(pTab, 0 as *mut ZipfileEntry, pNew);
            iOff += 46 as libc::c_int as libc::c_longlong;
            iOff
                += ((*pNew).cds.nExtra as libc::c_int + (*pNew).cds.nFile as libc::c_int
                    + (*pNew).cds.nComment as libc::c_int) as libc::c_longlong;
        }
        i += 1;
    }
    return rc;
}
unsafe extern "C" fn zipfileFilter(
    mut cur: *mut sqlite3_vtab_cursor,
    mut idxNum: libc::c_int,
    mut idxStr: *const libc::c_char,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) -> libc::c_int {
    let mut pTab: *mut ZipfileTab = (*cur).pVtab as *mut ZipfileTab;
    let mut pCsr: *mut ZipfileCsr = cur as *mut ZipfileCsr;
    let mut zFile: *const libc::c_char = 0 as *const libc::c_char;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut bInMemory: libc::c_int = 0 as libc::c_int;
    zipfileResetCursor(pCsr);
    if !((*pTab).zFile).is_null() {
        zFile = (*pTab).zFile;
    } else if idxNum == 0 as libc::c_int {
        zipfileCursorErr(
            pCsr,
            b"zipfile() function requires an argument\0" as *const u8
                as *const libc::c_char,
        );
        return 1 as libc::c_int;
    } else {
        if sqlite3_value_type(*argv.offset(0 as libc::c_int as isize))
            == 4 as libc::c_int
        {
            static mut aEmptyBlob: u8_0 = 0 as libc::c_int as u8_0;
            let mut aBlob: *const u8_0 = sqlite3_value_blob(
                *argv.offset(0 as libc::c_int as isize),
            ) as *const u8_0;
            let mut nBlob: libc::c_int = sqlite3_value_bytes(
                *argv.offset(0 as libc::c_int as isize),
            );
            if aBlob.is_null() {
                aBlob = &aEmptyBlob;
                nBlob = 0 as libc::c_int;
            }
            rc = zipfileLoadDirectory(pTab, aBlob, nBlob);
            let ref mut fresh142 = (*pCsr).pFreeEntry;
            *fresh142 = (*pTab).pFirstEntry;
            let ref mut fresh143 = (*pTab).pLastEntry;
            *fresh143 = 0 as *mut ZipfileEntry;
            let ref mut fresh144 = (*pTab).pFirstEntry;
            *fresh144 = *fresh143;
            if rc != 0 as libc::c_int {
                return rc;
            }
            bInMemory = 1 as libc::c_int;
        } else {
            zFile = sqlite3_value_text(*argv.offset(0 as libc::c_int as isize))
                as *const libc::c_char;
        }
    }
    if ((*pTab).pWriteFd).is_null() && 0 as libc::c_int == bInMemory {
        let ref mut fresh145 = (*pCsr).pFile;
        *fresh145 = fopen(zFile, b"rb\0" as *const u8 as *const libc::c_char);
        if ((*pCsr).pFile).is_null() {
            zipfileCursorErr(
                pCsr,
                b"cannot open file: %s\0" as *const u8 as *const libc::c_char,
                zFile,
            );
            rc = 1 as libc::c_int;
        } else {
            rc = zipfileReadEOCD(
                pTab,
                0 as *const u8_0,
                0 as libc::c_int,
                (*pCsr).pFile,
                &mut (*pCsr).eocd,
            );
            if rc == 0 as libc::c_int {
                if (*pCsr).eocd.nEntry as libc::c_int == 0 as libc::c_int {
                    (*pCsr).bEof = 1 as libc::c_int as u8_0;
                } else {
                    (*pCsr).iNextOff = (*pCsr).eocd.iOffset as i64_0;
                    rc = zipfileNext(cur);
                }
            }
        }
    } else {
        (*pCsr).bNoop = 1 as libc::c_int as u8_0;
        let ref mut fresh146 = (*pCsr).pCurrent;
        *fresh146 = if !((*pCsr).pFreeEntry).is_null() {
            (*pCsr).pFreeEntry
        } else {
            (*pTab).pFirstEntry
        };
        rc = zipfileNext(cur);
    }
    return rc;
}
unsafe extern "C" fn zipfileBestIndex(
    mut tab: *mut sqlite3_vtab,
    mut pIdxInfo: *mut sqlite3_index_info,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut idx: libc::c_int = -(1 as libc::c_int);
    let mut unusable: libc::c_int = 0 as libc::c_int;
    i = 0 as libc::c_int;
    while i < (*pIdxInfo).nConstraint {
        let mut pCons: *const sqlite3_index_constraint = &mut *((*pIdxInfo).aConstraint)
            .offset(i as isize) as *mut sqlite3_index_constraint;
        if !((*pCons).iColumn != 7 as libc::c_int) {
            if (*pCons).usable as libc::c_int == 0 as libc::c_int {
                unusable = 1 as libc::c_int;
            } else if (*pCons).op as libc::c_int == 2 as libc::c_int {
                idx = i;
            }
        }
        i += 1;
    }
    (*pIdxInfo).estimatedCost = 1000.0f64;
    if idx >= 0 as libc::c_int {
        (*((*pIdxInfo).aConstraintUsage).offset(idx as isize))
            .argvIndex = 1 as libc::c_int;
        (*((*pIdxInfo).aConstraintUsage).offset(idx as isize))
            .omit = 1 as libc::c_int as libc::c_uchar;
        (*pIdxInfo).idxNum = 1 as libc::c_int;
    } else if unusable != 0 {
        return 19 as libc::c_int
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn zipfileNewEntry(
    mut zPath: *const libc::c_char,
) -> *mut ZipfileEntry {
    let mut pNew: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
    pNew = sqlite3_malloc(
        ::std::mem::size_of::<ZipfileEntry>() as libc::c_ulong as libc::c_int,
    ) as *mut ZipfileEntry;
    if !pNew.is_null() {
        memset(
            pNew as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<ZipfileEntry>() as libc::c_ulong,
        );
        let ref mut fresh147 = (*pNew).cds.zFile;
        *fresh147 = sqlite3_mprintf(b"%s\0" as *const u8 as *const libc::c_char, zPath);
        if ((*pNew).cds.zFile).is_null() {
            sqlite3_free(pNew as *mut libc::c_void);
            pNew = 0 as *mut ZipfileEntry;
        }
    }
    return pNew;
}
unsafe extern "C" fn zipfileSerializeLFH(
    mut pEntry: *mut ZipfileEntry,
    mut aBuf: *mut u8_0,
) -> libc::c_int {
    let mut pCds: *mut ZipfileCDS = &mut (*pEntry).cds;
    let mut a: *mut u8_0 = aBuf;
    (*pCds).nExtra = 9 as libc::c_int as u16_0;
    zipfilePutU32(a, 0x4034b50 as libc::c_int as u32_0);
    a = a.offset(4 as libc::c_int as isize);
    zipfilePutU16(a, (*pCds).iVersionExtract);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCds).flags);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCds).iCompression);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCds).mTime);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCds).mDate);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU32(a, (*pCds).crc32);
    a = a.offset(4 as libc::c_int as isize);
    zipfilePutU32(a, (*pCds).szCompressed);
    a = a.offset(4 as libc::c_int as isize);
    zipfilePutU32(a, (*pCds).szUncompressed);
    a = a.offset(4 as libc::c_int as isize);
    zipfilePutU16(a, (*pCds).nFile);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCds).nExtra);
    a = a.offset(2 as libc::c_int as isize);
    memcpy(
        a as *mut libc::c_void,
        (*pCds).zFile as *const libc::c_void,
        (*pCds).nFile as libc::c_int as libc::c_ulong,
    );
    a = a.offset((*pCds).nFile as libc::c_int as isize);
    zipfilePutU16(a, 0x5455 as libc::c_int as u16_0);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, 5 as libc::c_int as u16_0);
    a = a.offset(2 as libc::c_int as isize);
    let fresh148 = a;
    a = a.offset(1);
    *fresh148 = 0x1 as libc::c_int as u8_0;
    zipfilePutU32(a, (*pEntry).mUnixTime);
    a = a.offset(4 as libc::c_int as isize);
    return a.offset_from(aBuf) as libc::c_long as libc::c_int;
}
unsafe extern "C" fn zipfileAppendEntry(
    mut pTab: *mut ZipfileTab,
    mut pEntry: *mut ZipfileEntry,
    mut pData: *const u8_0,
    mut nData: libc::c_int,
) -> libc::c_int {
    let mut aBuf: *mut u8_0 = (*pTab).aBuffer;
    let mut nBuf: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    nBuf = zipfileSerializeLFH(pEntry, aBuf);
    rc = zipfileAppendData(pTab, aBuf, nBuf);
    if rc == 0 as libc::c_int {
        (*pEntry).iDataOff = (*pTab).szCurrent;
        rc = zipfileAppendData(pTab, pData, nData);
    }
    return rc;
}
unsafe extern "C" fn zipfileGetMode(
    mut pVal: *mut sqlite3_value,
    mut bIsDir: libc::c_int,
    mut pMode: *mut u32_0,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut current_block: u64;
    let mut z: *const libc::c_char = sqlite3_value_text(pVal) as *const libc::c_char;
    let mut mode: u32_0 = 0 as libc::c_int as u32_0;
    if z.is_null() {
        mode = (if bIsDir != 0 {
            0o40000 as libc::c_int + 0o755 as libc::c_int
        } else {
            0o100000 as libc::c_int + 0o644 as libc::c_int
        }) as u32_0;
    } else if *z.offset(0 as libc::c_int as isize) as libc::c_int >= '0' as i32
        && *z.offset(0 as libc::c_int as isize) as libc::c_int <= '9' as i32
    {
        mode = sqlite3_value_int(pVal) as libc::c_uint;
    } else {
        let zTemplate: [libc::c_char; 11] = *::std::mem::transmute::<
            &[u8; 11],
            &[libc::c_char; 11],
        >(b"-rwxrwxrwx\0");
        let mut i: libc::c_int = 0;
        if strlen(z) != 10 as libc::c_int as libc::c_ulong {
            current_block = 5406048715124581347;
        } else {
            match *z.offset(0 as libc::c_int as isize) as libc::c_int {
                45 => {
                    current_block = 287369926737692127;
                    match current_block {
                        14112141588159825932 => {
                            mode |= 0o120000 as libc::c_int as libc::c_uint;
                        }
                        5124549999860713426 => {
                            mode |= 0o40000 as libc::c_int as libc::c_uint;
                        }
                        _ => {
                            mode |= 0o100000 as libc::c_int as libc::c_uint;
                        }
                    }
                    i = 1 as libc::c_int;
                    loop {
                        if !(i < 10 as libc::c_int) {
                            current_block = 5783071609795492627;
                            break;
                        }
                        if *z.offset(i as isize) as libc::c_int
                            == zTemplate[i as usize] as libc::c_int
                        {
                            mode
                                |= ((1 as libc::c_int) << 9 as libc::c_int - i)
                                    as libc::c_uint;
                        } else if *z.offset(i as isize) as libc::c_int != '-' as i32 {
                            current_block = 5406048715124581347;
                            break;
                        }
                        i += 1;
                    }
                }
                100 => {
                    current_block = 5124549999860713426;
                    match current_block {
                        14112141588159825932 => {
                            mode |= 0o120000 as libc::c_int as libc::c_uint;
                        }
                        5124549999860713426 => {
                            mode |= 0o40000 as libc::c_int as libc::c_uint;
                        }
                        _ => {
                            mode |= 0o100000 as libc::c_int as libc::c_uint;
                        }
                    }
                    i = 1 as libc::c_int;
                    loop {
                        if !(i < 10 as libc::c_int) {
                            current_block = 5783071609795492627;
                            break;
                        }
                        if *z.offset(i as isize) as libc::c_int
                            == zTemplate[i as usize] as libc::c_int
                        {
                            mode
                                |= ((1 as libc::c_int) << 9 as libc::c_int - i)
                                    as libc::c_uint;
                        } else if *z.offset(i as isize) as libc::c_int != '-' as i32 {
                            current_block = 5406048715124581347;
                            break;
                        }
                        i += 1;
                    }
                }
                108 => {
                    current_block = 14112141588159825932;
                    match current_block {
                        14112141588159825932 => {
                            mode |= 0o120000 as libc::c_int as libc::c_uint;
                        }
                        5124549999860713426 => {
                            mode |= 0o40000 as libc::c_int as libc::c_uint;
                        }
                        _ => {
                            mode |= 0o100000 as libc::c_int as libc::c_uint;
                        }
                    }
                    i = 1 as libc::c_int;
                    loop {
                        if !(i < 10 as libc::c_int) {
                            current_block = 5783071609795492627;
                            break;
                        }
                        if *z.offset(i as isize) as libc::c_int
                            == zTemplate[i as usize] as libc::c_int
                        {
                            mode
                                |= ((1 as libc::c_int) << 9 as libc::c_int - i)
                                    as libc::c_uint;
                        } else if *z.offset(i as isize) as libc::c_int != '-' as i32 {
                            current_block = 5406048715124581347;
                            break;
                        }
                        i += 1;
                    }
                }
                _ => {
                    current_block = 5406048715124581347;
                }
            }
        }
        match current_block {
            5783071609795492627 => {}
            _ => {
                *pzErr = sqlite3_mprintf(
                    b"zipfile: parse error in mode: %s\0" as *const u8
                        as *const libc::c_char,
                    z,
                );
                return 1 as libc::c_int;
            }
        }
    }
    if (mode & 0o40000 as libc::c_int as libc::c_uint
        == 0 as libc::c_int as libc::c_uint) as libc::c_int == bIsDir
    {
        *pzErr = sqlite3_mprintf(
            b"zipfile: mode does not match data\0" as *const u8 as *const libc::c_char,
        );
        return 19 as libc::c_int;
    }
    *pMode = mode;
    return 0 as libc::c_int;
}
unsafe extern "C" fn zipfileComparePath(
    mut zA: *const libc::c_char,
    mut zB: *const libc::c_char,
    mut nB: libc::c_int,
) -> libc::c_int {
    let mut nA: libc::c_int = strlen(zA) as libc::c_int;
    if nA > 0 as libc::c_int
        && *zA.offset((nA - 1 as libc::c_int) as isize) as libc::c_int == '/' as i32
    {
        nA -= 1;
    }
    if nB > 0 as libc::c_int
        && *zB.offset((nB - 1 as libc::c_int) as isize) as libc::c_int == '/' as i32
    {
        nB -= 1;
    }
    if nA == nB
        && memcmp(
            zA as *const libc::c_void,
            zB as *const libc::c_void,
            nA as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn zipfileBegin(mut pVtab: *mut sqlite3_vtab) -> libc::c_int {
    let mut pTab: *mut ZipfileTab = pVtab as *mut ZipfileTab;
    let mut rc: libc::c_int = 0 as libc::c_int;
    if ((*pTab).zFile).is_null()
        || *((*pTab).zFile).offset(0 as libc::c_int as isize) as libc::c_int
            == 0 as libc::c_int
    {
        let ref mut fresh149 = (*pTab).base.zErrMsg;
        *fresh149 = sqlite3_mprintf(
            b"zipfile: missing filename\0" as *const u8 as *const libc::c_char,
        );
        return 1 as libc::c_int;
    }
    let ref mut fresh150 = (*pTab).pWriteFd;
    *fresh150 = fopen((*pTab).zFile, b"ab+\0" as *const u8 as *const libc::c_char);
    if ((*pTab).pWriteFd).is_null() {
        let ref mut fresh151 = (*pTab).base.zErrMsg;
        *fresh151 = sqlite3_mprintf(
            b"zipfile: failed to open file %s for writing\0" as *const u8
                as *const libc::c_char,
            (*pTab).zFile,
        );
        rc = 1 as libc::c_int;
    } else {
        fseek((*pTab).pWriteFd, 0 as libc::c_int as libc::c_long, 2 as libc::c_int);
        let ref mut fresh152 = (*pTab).szOrig;
        *fresh152 = ftell((*pTab).pWriteFd) as i64_0;
        (*pTab).szCurrent = *fresh152;
        rc = zipfileLoadDirectory(pTab, 0 as *const u8_0, 0 as libc::c_int);
    }
    if rc != 0 as libc::c_int {
        zipfileCleanupTransaction(pTab);
    }
    return rc;
}
unsafe extern "C" fn zipfileTime() -> u32_0 {
    let mut pVfs: *mut sqlite3_vfs = sqlite3_vfs_find(0 as *const libc::c_char);
    let mut ret: u32_0 = 0;
    if pVfs.is_null() {
        return 0 as libc::c_int as u32_0;
    }
    if (*pVfs).iVersion >= 2 as libc::c_int && ((*pVfs).xCurrentTimeInt64).is_some() {
        let mut ms: i64_0 = 0;
        ((*pVfs).xCurrentTimeInt64).expect("non-null function pointer")(pVfs, &mut ms);
        ret = (ms / 1000 as libc::c_int as libc::c_longlong
            - 24405875 as libc::c_int as i64_0 * 8640 as libc::c_int as libc::c_longlong)
            as u32_0;
    } else {
        let mut day: libc::c_double = 0.;
        ((*pVfs).xCurrentTime).expect("non-null function pointer")(pVfs, &mut day);
        ret = ((day - 2440587.5f64) * 86400 as libc::c_int as libc::c_double) as u32_0;
    }
    return ret;
}
unsafe extern "C" fn zipfileGetTime(mut pVal: *mut sqlite3_value) -> u32_0 {
    if pVal.is_null() || sqlite3_value_type(pVal) == 5 as libc::c_int {
        return zipfileTime();
    }
    return sqlite3_value_int64(pVal) as u32_0;
}
unsafe extern "C" fn zipfileRemoveEntryFromList(
    mut pTab: *mut ZipfileTab,
    mut pOld: *mut ZipfileEntry,
) {
    if !pOld.is_null() {
        let mut pp: *mut *mut ZipfileEntry = 0 as *mut *mut ZipfileEntry;
        pp = &mut (*pTab).pFirstEntry;
        while *pp != pOld {
            pp = &mut (**pp).pNext;
        }
        *pp = (**pp).pNext;
        zipfileEntryFree(pOld);
    }
}
unsafe extern "C" fn zipfileUpdate(
    mut pVtab: *mut sqlite3_vtab,
    mut nVal: libc::c_int,
    mut apVal: *mut *mut sqlite3_value,
    mut pRowid: *mut sqlite_int64,
) -> libc::c_int {
    let mut current_block: u64;
    let mut pTab: *mut ZipfileTab = pVtab as *mut ZipfileTab;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut pNew: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
    let mut mode: u32_0 = 0 as libc::c_int as u32_0;
    let mut mTime: u32_0 = 0 as libc::c_int as u32_0;
    let mut sz: i64_0 = 0 as libc::c_int as i64_0;
    let mut zPath: *const libc::c_char = 0 as *const libc::c_char;
    let mut nPath: libc::c_int = 0 as libc::c_int;
    let mut pData: *const u8_0 = 0 as *const u8_0;
    let mut nData: libc::c_int = 0 as libc::c_int;
    let mut iMethod: libc::c_int = 0 as libc::c_int;
    let mut pFree: *mut u8_0 = 0 as *mut u8_0;
    let mut zFree: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut pOld: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
    let mut pOld2: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
    let mut bUpdate: libc::c_int = 0 as libc::c_int;
    let mut bIsDir: libc::c_int = 0 as libc::c_int;
    let mut iCrc32: u32_0 = 0 as libc::c_int as u32_0;
    if ((*pTab).pWriteFd).is_null() {
        rc = zipfileBegin(pVtab);
        if rc != 0 as libc::c_int {
            return rc;
        }
    }
    if sqlite3_value_type(*apVal.offset(0 as libc::c_int as isize)) != 5 as libc::c_int {
        let mut zDelete: *const libc::c_char = sqlite3_value_text(
            *apVal.offset(0 as libc::c_int as isize),
        ) as *const libc::c_char;
        let mut nDelete: libc::c_int = strlen(zDelete) as libc::c_int;
        if nVal > 1 as libc::c_int {
            let mut zUpdate: *const libc::c_char = sqlite3_value_text(
                *apVal.offset(1 as libc::c_int as isize),
            ) as *const libc::c_char;
            if !zUpdate.is_null()
                && zipfileComparePath(zUpdate, zDelete, nDelete) != 0 as libc::c_int
            {
                bUpdate = 1 as libc::c_int;
            }
        }
        pOld = (*pTab).pFirstEntry;
        while !(zipfileComparePath((*pOld).cds.zFile, zDelete, nDelete)
            == 0 as libc::c_int)
        {
            pOld = (*pOld).pNext;
        }
    }
    if nVal > 1 as libc::c_int {
        if sqlite3_value_type(*apVal.offset(5 as libc::c_int as isize))
            != 5 as libc::c_int
        {
            zipfileTableErr(
                pTab,
                b"sz must be NULL\0" as *const u8 as *const libc::c_char,
            );
            rc = 19 as libc::c_int;
        }
        if sqlite3_value_type(*apVal.offset(6 as libc::c_int as isize))
            != 5 as libc::c_int
        {
            zipfileTableErr(
                pTab,
                b"rawdata must be NULL\0" as *const u8 as *const libc::c_char,
            );
            rc = 19 as libc::c_int;
        }
        if rc == 0 as libc::c_int {
            if sqlite3_value_type(*apVal.offset(7 as libc::c_int as isize))
                == 5 as libc::c_int
            {
                bIsDir = 1 as libc::c_int;
            } else {
                let mut aIn: *const u8_0 = sqlite3_value_blob(
                    *apVal.offset(7 as libc::c_int as isize),
                ) as *const u8_0;
                let mut nIn: libc::c_int = sqlite3_value_bytes(
                    *apVal.offset(7 as libc::c_int as isize),
                );
                let mut bAuto: libc::c_int = (sqlite3_value_type(
                    *apVal.offset(8 as libc::c_int as isize),
                ) == 5 as libc::c_int) as libc::c_int;
                iMethod = sqlite3_value_int(*apVal.offset(8 as libc::c_int as isize));
                sz = nIn as i64_0;
                pData = aIn;
                nData = nIn;
                if iMethod != 0 as libc::c_int && iMethod != 8 as libc::c_int {
                    zipfileTableErr(
                        pTab,
                        b"unknown compression method: %d\0" as *const u8
                            as *const libc::c_char,
                        iMethod,
                    );
                    rc = 19 as libc::c_int;
                } else {
                    if bAuto != 0 || iMethod != 0 {
                        let mut nCmp: libc::c_int = 0;
                        rc = zipfileDeflate(
                            aIn,
                            nIn,
                            &mut pFree,
                            &mut nCmp,
                            &mut (*pTab).base.zErrMsg,
                        );
                        if rc == 0 as libc::c_int {
                            if iMethod != 0 || nCmp < nIn {
                                iMethod = 8 as libc::c_int;
                                pData = pFree;
                                nData = nCmp;
                            }
                        }
                    }
                    iCrc32 = crc32(0 as libc::c_int as uLong, aIn, nIn as uInt) as u32_0;
                }
            }
        }
        if rc == 0 as libc::c_int {
            rc = zipfileGetMode(
                *apVal.offset(3 as libc::c_int as isize),
                bIsDir,
                &mut mode,
                &mut (*pTab).base.zErrMsg,
            );
        }
        if rc == 0 as libc::c_int {
            zPath = sqlite3_value_text(*apVal.offset(2 as libc::c_int as isize))
                as *const libc::c_char;
            if zPath.is_null() {
                zPath = b"\0" as *const u8 as *const libc::c_char;
            }
            nPath = strlen(zPath) as libc::c_int;
            mTime = zipfileGetTime(*apVal.offset(4 as libc::c_int as isize));
        }
        if rc == 0 as libc::c_int && bIsDir != 0 {
            if nPath <= 0 as libc::c_int
                || *zPath.offset((nPath - 1 as libc::c_int) as isize) as libc::c_int
                    != '/' as i32
            {
                zFree = sqlite3_mprintf(
                    b"%s/\0" as *const u8 as *const libc::c_char,
                    zPath,
                );
                zPath = zFree as *const libc::c_char;
                if zFree.is_null() {
                    rc = 7 as libc::c_int;
                    nPath = 0 as libc::c_int;
                } else {
                    nPath = strlen(zPath) as libc::c_int;
                }
            }
        }
        if (pOld.is_null() || bUpdate != 0) && rc == 0 as libc::c_int {
            let mut p: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
            p = (*pTab).pFirstEntry;
            loop {
                if p.is_null() {
                    current_block = 9500030526577190060;
                    break;
                }
                if zipfileComparePath((*p).cds.zFile, zPath, nPath) == 0 as libc::c_int {
                    match sqlite3_vtab_on_conflict((*pTab).db) {
                        2 => {
                            current_block = 8654417045044070309;
                            break;
                        }
                        5 => {
                            pOld2 = p;
                            current_block = 9500030526577190060;
                            break;
                        }
                        _ => {
                            zipfileTableErr(
                                pTab,
                                b"duplicate name: \"%s\"\0" as *const u8
                                    as *const libc::c_char,
                                zPath,
                            );
                            rc = 19 as libc::c_int;
                            current_block = 9500030526577190060;
                            break;
                        }
                    }
                } else {
                    p = (*p).pNext;
                }
            }
        } else {
            current_block = 9500030526577190060;
        }
        match current_block {
            8654417045044070309 => {}
            _ => {
                if rc == 0 as libc::c_int {
                    pNew = zipfileNewEntry(zPath);
                    if pNew.is_null() {
                        rc = 7 as libc::c_int;
                    } else {
                        (*pNew)
                            .cds
                            .iVersionMadeBy = (((3 as libc::c_int) << 8 as libc::c_int)
                            + 30 as libc::c_int) as u16_0;
                        (*pNew).cds.iVersionExtract = 20 as libc::c_int as u16_0;
                        (*pNew).cds.flags = 0x800 as libc::c_int as u16_0;
                        (*pNew).cds.iCompression = iMethod as u16_0;
                        zipfileMtimeToDos(&mut (*pNew).cds, mTime);
                        (*pNew).cds.crc32 = iCrc32;
                        (*pNew).cds.szCompressed = nData as u32_0;
                        (*pNew).cds.szUncompressed = sz as u32_0;
                        (*pNew).cds.iExternalAttr = mode << 16 as libc::c_int;
                        (*pNew).cds.iOffset = (*pTab).szCurrent as u32_0;
                        (*pNew).cds.nFile = nPath as u16_0;
                        (*pNew).mUnixTime = mTime;
                        rc = zipfileAppendEntry(pTab, pNew, pData, nData);
                        zipfileAddEntry(pTab, pOld, pNew);
                    }
                }
                current_block = 18002345992382212654;
            }
        }
    } else {
        current_block = 18002345992382212654;
    }
    match current_block {
        18002345992382212654 => {
            if rc == 0 as libc::c_int && (!pOld.is_null() || !pOld2.is_null()) {
                let mut pCsr: *mut ZipfileCsr = 0 as *mut ZipfileCsr;
                pCsr = (*pTab).pCsrList;
                while !pCsr.is_null() {
                    if !((*pCsr).pCurrent).is_null()
                        && ((*pCsr).pCurrent == pOld || (*pCsr).pCurrent == pOld2)
                    {
                        let ref mut fresh153 = (*pCsr).pCurrent;
                        *fresh153 = (*(*pCsr).pCurrent).pNext;
                        (*pCsr).bNoop = 1 as libc::c_int as u8_0;
                    }
                    pCsr = (*pCsr).pCsrNext;
                }
                zipfileRemoveEntryFromList(pTab, pOld);
                zipfileRemoveEntryFromList(pTab, pOld2);
            }
        }
        _ => {}
    }
    sqlite3_free(pFree as *mut libc::c_void);
    sqlite3_free(zFree as *mut libc::c_void);
    return rc;
}
unsafe extern "C" fn zipfileSerializeEOCD(
    mut p: *mut ZipfileEOCD,
    mut aBuf: *mut u8_0,
) -> libc::c_int {
    let mut a: *mut u8_0 = aBuf;
    zipfilePutU32(a, 0x6054b50 as libc::c_int as u32_0);
    a = a.offset(4 as libc::c_int as isize);
    zipfilePutU16(a, (*p).iDisk);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*p).iFirstDisk);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*p).nEntry);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*p).nEntryTotal);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU32(a, (*p).nSize);
    a = a.offset(4 as libc::c_int as isize);
    zipfilePutU32(a, (*p).iOffset);
    a = a.offset(4 as libc::c_int as isize);
    zipfilePutU16(a, 0 as libc::c_int as u16_0);
    a = a.offset(2 as libc::c_int as isize);
    return a.offset_from(aBuf) as libc::c_long as libc::c_int;
}
unsafe extern "C" fn zipfileAppendEOCD(
    mut pTab: *mut ZipfileTab,
    mut p: *mut ZipfileEOCD,
) -> libc::c_int {
    let mut nBuf: libc::c_int = zipfileSerializeEOCD(p, (*pTab).aBuffer);
    return zipfileAppendData(pTab, (*pTab).aBuffer, nBuf);
}
unsafe extern "C" fn zipfileSerializeCDS(
    mut pEntry: *mut ZipfileEntry,
    mut aBuf: *mut u8_0,
) -> libc::c_int {
    let mut a: *mut u8_0 = aBuf;
    let mut pCDS: *mut ZipfileCDS = &mut (*pEntry).cds;
    if ((*pEntry).aExtra).is_null() {
        (*pCDS).nExtra = 9 as libc::c_int as u16_0;
    }
    zipfilePutU32(a, 0x2014b50 as libc::c_int as u32_0);
    a = a.offset(4 as libc::c_int as isize);
    zipfilePutU16(a, (*pCDS).iVersionMadeBy);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCDS).iVersionExtract);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCDS).flags);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCDS).iCompression);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCDS).mTime);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCDS).mDate);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU32(a, (*pCDS).crc32);
    a = a.offset(4 as libc::c_int as isize);
    zipfilePutU32(a, (*pCDS).szCompressed);
    a = a.offset(4 as libc::c_int as isize);
    zipfilePutU32(a, (*pCDS).szUncompressed);
    a = a.offset(4 as libc::c_int as isize);
    zipfilePutU16(a, (*pCDS).nFile);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCDS).nExtra);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCDS).nComment);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCDS).iDiskStart);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCDS).iInternalAttr);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU32(a, (*pCDS).iExternalAttr);
    a = a.offset(4 as libc::c_int as isize);
    zipfilePutU32(a, (*pCDS).iOffset);
    a = a.offset(4 as libc::c_int as isize);
    memcpy(
        a as *mut libc::c_void,
        (*pCDS).zFile as *const libc::c_void,
        (*pCDS).nFile as libc::c_ulong,
    );
    a = a.offset((*pCDS).nFile as libc::c_int as isize);
    if !((*pEntry).aExtra).is_null() {
        let mut n: libc::c_int = (*pCDS).nExtra as libc::c_int
            + (*pCDS).nComment as libc::c_int;
        memcpy(
            a as *mut libc::c_void,
            (*pEntry).aExtra as *const libc::c_void,
            n as libc::c_ulong,
        );
        a = a.offset(n as isize);
    } else {
        zipfilePutU16(a, 0x5455 as libc::c_int as u16_0);
        a = a.offset(2 as libc::c_int as isize);
        zipfilePutU16(a, 5 as libc::c_int as u16_0);
        a = a.offset(2 as libc::c_int as isize);
        let fresh154 = a;
        a = a.offset(1);
        *fresh154 = 0x1 as libc::c_int as u8_0;
        zipfilePutU32(a, (*pEntry).mUnixTime);
        a = a.offset(4 as libc::c_int as isize);
    }
    return a.offset_from(aBuf) as libc::c_long as libc::c_int;
}
unsafe extern "C" fn zipfileCommit(mut pVtab: *mut sqlite3_vtab) -> libc::c_int {
    let mut pTab: *mut ZipfileTab = pVtab as *mut ZipfileTab;
    let mut rc: libc::c_int = 0 as libc::c_int;
    if !((*pTab).pWriteFd).is_null() {
        let mut iOffset: i64_0 = (*pTab).szCurrent;
        let mut p: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
        let mut eocd: ZipfileEOCD = ZipfileEOCD {
            iDisk: 0,
            iFirstDisk: 0,
            nEntry: 0,
            nEntryTotal: 0,
            nSize: 0,
            iOffset: 0,
        };
        let mut nEntry: libc::c_int = 0 as libc::c_int;
        p = (*pTab).pFirstEntry;
        while rc == 0 as libc::c_int && !p.is_null() {
            let mut n: libc::c_int = zipfileSerializeCDS(p, (*pTab).aBuffer);
            rc = zipfileAppendData(pTab, (*pTab).aBuffer, n);
            nEntry += 1;
            p = (*p).pNext;
        }
        eocd.iDisk = 0 as libc::c_int as u16_0;
        eocd.iFirstDisk = 0 as libc::c_int as u16_0;
        eocd.nEntry = nEntry as u16_0;
        eocd.nEntryTotal = nEntry as u16_0;
        eocd.nSize = ((*pTab).szCurrent - iOffset) as u32_0;
        eocd.iOffset = iOffset as u32_0;
        rc = zipfileAppendEOCD(pTab, &mut eocd);
        zipfileCleanupTransaction(pTab);
    }
    return rc;
}
unsafe extern "C" fn zipfileRollback(mut pVtab: *mut sqlite3_vtab) -> libc::c_int {
    return zipfileCommit(pVtab);
}
unsafe extern "C" fn zipfileFindCursor(
    mut pTab: *mut ZipfileTab,
    mut iId: i64_0,
) -> *mut ZipfileCsr {
    let mut pCsr: *mut ZipfileCsr = 0 as *mut ZipfileCsr;
    pCsr = (*pTab).pCsrList;
    while !pCsr.is_null() {
        if iId == (*pCsr).iId {
            break;
        }
        pCsr = (*pCsr).pCsrNext;
    }
    return pCsr;
}
unsafe extern "C" fn zipfileFunctionCds(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut pCsr: *mut ZipfileCsr = 0 as *mut ZipfileCsr;
    let mut pTab: *mut ZipfileTab = sqlite3_user_data(context) as *mut ZipfileTab;
    pCsr = zipfileFindCursor(
        pTab,
        sqlite3_value_int64(*argv.offset(0 as libc::c_int as isize)),
    );
    if !pCsr.is_null() {
        let mut p: *mut ZipfileCDS = &mut (*(*pCsr).pCurrent).cds;
        let mut zRes: *mut libc::c_char = sqlite3_mprintf(
            b"{\"version-made-by\" : %u, \"version-to-extract\" : %u, \"flags\" : %u, \"compression\" : %u, \"time\" : %u, \"date\" : %u, \"crc32\" : %u, \"compressed-size\" : %u, \"uncompressed-size\" : %u, \"file-name-length\" : %u, \"extra-field-length\" : %u, \"file-comment-length\" : %u, \"disk-number-start\" : %u, \"internal-attr\" : %u, \"external-attr\" : %u, \"offset\" : %u }\0"
                as *const u8 as *const libc::c_char,
            (*p).iVersionMadeBy as u32_0,
            (*p).iVersionExtract as u32_0,
            (*p).flags as u32_0,
            (*p).iCompression as u32_0,
            (*p).mTime as u32_0,
            (*p).mDate as u32_0,
            (*p).crc32,
            (*p).szCompressed,
            (*p).szUncompressed,
            (*p).nFile as u32_0,
            (*p).nExtra as u32_0,
            (*p).nComment as u32_0,
            (*p).iDiskStart as u32_0,
            (*p).iInternalAttr as u32_0,
            (*p).iExternalAttr,
            (*p).iOffset,
        );
        if zRes.is_null() {
            sqlite3_result_error_nomem(context);
        } else {
            sqlite3_result_text(
                context,
                zRes,
                -(1 as libc::c_int),
                ::std::mem::transmute::<
                    libc::intptr_t,
                    sqlite3_destructor_type,
                >(-(1 as libc::c_int) as libc::intptr_t),
            );
            sqlite3_free(zRes as *mut libc::c_void);
        }
    }
}
unsafe extern "C" fn zipfileFindFunction(
    mut pVtab: *mut sqlite3_vtab,
    mut nArg: libc::c_int,
    mut zName: *const libc::c_char,
    mut pxFunc: *mut Option::<
        unsafe extern "C" fn(
            *mut sqlite3_context,
            libc::c_int,
            *mut *mut sqlite3_value,
        ) -> (),
    >,
    mut ppArg: *mut *mut libc::c_void,
) -> libc::c_int {
    if sqlite3_stricmp(b"zipfile_cds\0" as *const u8 as *const libc::c_char, zName)
        == 0 as libc::c_int
    {
        *pxFunc = Some(
            zipfileFunctionCds
                as unsafe extern "C" fn(
                    *mut sqlite3_context,
                    libc::c_int,
                    *mut *mut sqlite3_value,
                ) -> (),
        );
        *ppArg = pVtab as *mut libc::c_void;
        return 1 as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn zipfileBufferGrow(
    mut pBuf: *mut ZipfileBuffer,
    mut nByte: libc::c_int,
) -> libc::c_int {
    if (*pBuf).n + nByte > (*pBuf).nAlloc {
        let mut aNew: *mut u8_0 = 0 as *mut u8_0;
        let mut nNew: sqlite3_int64 = (if (*pBuf).n != 0 {
            (*pBuf).n * 2 as libc::c_int
        } else {
            512 as libc::c_int
        }) as sqlite3_int64;
        let mut nReq: libc::c_int = (*pBuf).n + nByte;
        while nNew < nReq as libc::c_longlong {
            nNew = nNew * 2 as libc::c_int as libc::c_longlong;
        }
        aNew = sqlite3_realloc64((*pBuf).a as *mut libc::c_void, nNew as sqlite3_uint64)
            as *mut u8_0;
        if aNew.is_null() {
            return 7 as libc::c_int;
        }
        let ref mut fresh155 = (*pBuf).a;
        *fresh155 = aNew;
        (*pBuf).nAlloc = nNew as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn zipfileStep(
    mut pCtx: *mut sqlite3_context,
    mut nVal: libc::c_int,
    mut apVal: *mut *mut sqlite3_value,
) {
    let mut current_block: u64;
    let mut p: *mut ZipfileCtx = 0 as *mut ZipfileCtx;
    let mut e: ZipfileEntry = ZipfileEntry {
        cds: ZipfileCDS {
            iVersionMadeBy: 0,
            iVersionExtract: 0,
            flags: 0,
            iCompression: 0,
            mTime: 0,
            mDate: 0,
            crc32: 0,
            szCompressed: 0,
            szUncompressed: 0,
            nFile: 0,
            nExtra: 0,
            nComment: 0,
            iDiskStart: 0,
            iInternalAttr: 0,
            iExternalAttr: 0,
            iOffset: 0,
            zFile: 0 as *mut libc::c_char,
        },
        mUnixTime: 0,
        aExtra: 0 as *mut u8_0,
        iDataOff: 0,
        aData: 0 as *mut u8_0,
        pNext: 0 as *mut ZipfileEntry,
    };
    let mut pName: *mut sqlite3_value = 0 as *mut sqlite3_value;
    let mut pMode: *mut sqlite3_value = 0 as *mut sqlite3_value;
    let mut pMtime: *mut sqlite3_value = 0 as *mut sqlite3_value;
    let mut pData: *mut sqlite3_value = 0 as *mut sqlite3_value;
    let mut pMethod: *mut sqlite3_value = 0 as *mut sqlite3_value;
    let mut bIsDir: libc::c_int = 0 as libc::c_int;
    let mut mode: u32_0 = 0;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut zErr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut iMethod: libc::c_int = -(1 as libc::c_int);
    let mut aData: *const u8_0 = 0 as *const u8_0;
    let mut nData: libc::c_int = 0 as libc::c_int;
    let mut szUncompressed: libc::c_int = 0 as libc::c_int;
    let mut aFree: *mut u8_0 = 0 as *mut u8_0;
    let mut iCrc32: u32_0 = 0 as libc::c_int as u32_0;
    let mut zName: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut nName: libc::c_int = 0 as libc::c_int;
    let mut zFree: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut nByte: libc::c_int = 0;
    memset(
        &mut e as *mut ZipfileEntry as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<ZipfileEntry>() as libc::c_ulong,
    );
    p = sqlite3_aggregate_context(
        pCtx,
        ::std::mem::size_of::<ZipfileCtx>() as libc::c_ulong as libc::c_int,
    ) as *mut ZipfileCtx;
    if p.is_null() {
        return;
    }
    if nVal != 2 as libc::c_int && nVal != 4 as libc::c_int && nVal != 5 as libc::c_int {
        zErr = sqlite3_mprintf(
            b"wrong number of arguments to function zipfile()\0" as *const u8
                as *const libc::c_char,
        );
        rc = 1 as libc::c_int;
    } else {
        pName = *apVal.offset(0 as libc::c_int as isize);
        if nVal == 2 as libc::c_int {
            pData = *apVal.offset(1 as libc::c_int as isize);
        } else {
            pMode = *apVal.offset(1 as libc::c_int as isize);
            pMtime = *apVal.offset(2 as libc::c_int as isize);
            pData = *apVal.offset(3 as libc::c_int as isize);
            if nVal == 5 as libc::c_int {
                pMethod = *apVal.offset(4 as libc::c_int as isize);
            }
        }
        zName = sqlite3_value_text(pName) as *mut libc::c_char;
        nName = sqlite3_value_bytes(pName);
        if zName.is_null() {
            zErr = sqlite3_mprintf(
                b"first argument to zipfile() must be non-NULL\0" as *const u8
                    as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        } else {
            if !pMethod.is_null() && 5 as libc::c_int != sqlite3_value_type(pMethod) {
                iMethod = sqlite3_value_int64(pMethod) as libc::c_int;
                if iMethod != 0 as libc::c_int && iMethod != 8 as libc::c_int {
                    zErr = sqlite3_mprintf(
                        b"illegal method value: %d\0" as *const u8
                            as *const libc::c_char,
                        iMethod,
                    );
                    rc = 1 as libc::c_int;
                    current_block = 9489959456664111627;
                } else {
                    current_block = 9007357115414505193;
                }
            } else {
                current_block = 9007357115414505193;
            }
            match current_block {
                9489959456664111627 => {}
                _ => {
                    if sqlite3_value_type(pData) == 5 as libc::c_int {
                        bIsDir = 1 as libc::c_int;
                        iMethod = 0 as libc::c_int;
                        current_block = 6072622540298447352;
                    } else {
                        aData = sqlite3_value_blob(pData) as *const u8_0;
                        nData = sqlite3_value_bytes(pData);
                        szUncompressed = nData;
                        iCrc32 = crc32(0 as libc::c_int as uLong, aData, nData as uInt)
                            as u32_0;
                        if iMethod < 0 as libc::c_int || iMethod == 8 as libc::c_int {
                            let mut nOut: libc::c_int = 0 as libc::c_int;
                            rc = zipfileDeflate(
                                aData,
                                nData,
                                &mut aFree,
                                &mut nOut,
                                &mut zErr,
                            );
                            if rc != 0 as libc::c_int {
                                current_block = 9489959456664111627;
                            } else {
                                if iMethod == 8 as libc::c_int || nOut < nData {
                                    aData = aFree;
                                    nData = nOut;
                                    iMethod = 8 as libc::c_int;
                                } else {
                                    iMethod = 0 as libc::c_int;
                                }
                                current_block = 6072622540298447352;
                            }
                        } else {
                            current_block = 6072622540298447352;
                        }
                    }
                    match current_block {
                        9489959456664111627 => {}
                        _ => {
                            rc = zipfileGetMode(pMode, bIsDir, &mut mode, &mut zErr);
                            if !(rc != 0) {
                                e.mUnixTime = zipfileGetTime(pMtime);
                                if bIsDir == 0 as libc::c_int {
                                    if nName > 0 as libc::c_int
                                        && *zName.offset((nName - 1 as libc::c_int) as isize)
                                            as libc::c_int == '/' as i32
                                    {
                                        zErr = sqlite3_mprintf(
                                            b"non-directory name must not end with /\0" as *const u8
                                                as *const libc::c_char,
                                        );
                                        rc = 1 as libc::c_int;
                                        current_block = 9489959456664111627;
                                    } else {
                                        current_block = 5873035170358615968;
                                    }
                                } else if nName == 0 as libc::c_int
                                    || *zName.offset((nName - 1 as libc::c_int) as isize)
                                        as libc::c_int != '/' as i32
                                {
                                    zFree = sqlite3_mprintf(
                                        b"%s/\0" as *const u8 as *const libc::c_char,
                                        zName,
                                    );
                                    zName = zFree;
                                    if zName.is_null() {
                                        rc = 7 as libc::c_int;
                                        current_block = 9489959456664111627;
                                    } else {
                                        nName = strlen(zName) as libc::c_int;
                                        current_block = 5873035170358615968;
                                    }
                                } else {
                                    while nName > 1 as libc::c_int
                                        && *zName.offset((nName - 2 as libc::c_int) as isize)
                                            as libc::c_int == '/' as i32
                                    {
                                        nName -= 1;
                                    }
                                    current_block = 5873035170358615968;
                                }
                                match current_block {
                                    9489959456664111627 => {}
                                    _ => {
                                        e
                                            .cds
                                            .iVersionMadeBy = (((3 as libc::c_int) << 8 as libc::c_int)
                                            + 30 as libc::c_int) as u16_0;
                                        e.cds.iVersionExtract = 20 as libc::c_int as u16_0;
                                        e.cds.flags = 0x800 as libc::c_int as u16_0;
                                        e.cds.iCompression = iMethod as u16_0;
                                        zipfileMtimeToDos(&mut e.cds, e.mUnixTime);
                                        e.cds.crc32 = iCrc32;
                                        e.cds.szCompressed = nData as u32_0;
                                        e.cds.szUncompressed = szUncompressed as u32_0;
                                        e.cds.iExternalAttr = mode << 16 as libc::c_int;
                                        e.cds.iOffset = (*p).body.n as u32_0;
                                        e.cds.nFile = nName as u16_0;
                                        e.cds.zFile = zName;
                                        nByte = 30 as libc::c_int + e.cds.nFile as libc::c_int
                                            + 9 as libc::c_int;
                                        rc = zipfileBufferGrow(&mut (*p).body, nByte);
                                        if !(rc != 0) {
                                            (*p).body.n
                                                += zipfileSerializeLFH(
                                                    &mut e,
                                                    &mut *((*p).body.a).offset((*p).body.n as isize),
                                                );
                                            if nData > 0 as libc::c_int {
                                                rc = zipfileBufferGrow(&mut (*p).body, nData);
                                                if rc != 0 {
                                                    current_block = 9489959456664111627;
                                                } else {
                                                    memcpy(
                                                        &mut *((*p).body.a).offset((*p).body.n as isize)
                                                            as *mut u8_0 as *mut libc::c_void,
                                                        aData as *const libc::c_void,
                                                        nData as libc::c_ulong,
                                                    );
                                                    (*p).body.n += nData;
                                                    current_block = 10887629115603254199;
                                                }
                                            } else {
                                                current_block = 10887629115603254199;
                                            }
                                            match current_block {
                                                9489959456664111627 => {}
                                                _ => {
                                                    nByte = 46 as libc::c_int + e.cds.nFile as libc::c_int
                                                        + 9 as libc::c_int;
                                                    rc = zipfileBufferGrow(&mut (*p).cds, nByte);
                                                    if !(rc != 0) {
                                                        (*p).cds.n
                                                            += zipfileSerializeCDS(
                                                                &mut e,
                                                                &mut *((*p).cds.a).offset((*p).cds.n as isize),
                                                            );
                                                        let ref mut fresh156 = (*p).nEntry;
                                                        *fresh156 += 1;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    sqlite3_free(aFree as *mut libc::c_void);
    sqlite3_free(zFree as *mut libc::c_void);
    if rc != 0 {
        if !zErr.is_null() {
            sqlite3_result_error(pCtx, zErr, -(1 as libc::c_int));
        } else {
            sqlite3_result_error_code(pCtx, rc);
        }
    }
    sqlite3_free(zErr as *mut libc::c_void);
}
unsafe extern "C" fn zipfileFinal(mut pCtx: *mut sqlite3_context) {
    let mut p: *mut ZipfileCtx = 0 as *mut ZipfileCtx;
    let mut eocd: ZipfileEOCD = ZipfileEOCD {
        iDisk: 0,
        iFirstDisk: 0,
        nEntry: 0,
        nEntryTotal: 0,
        nSize: 0,
        iOffset: 0,
    };
    let mut nZip: sqlite3_int64 = 0;
    let mut aZip: *mut u8_0 = 0 as *mut u8_0;
    p = sqlite3_aggregate_context(
        pCtx,
        ::std::mem::size_of::<ZipfileCtx>() as libc::c_ulong as libc::c_int,
    ) as *mut ZipfileCtx;
    if p.is_null() {
        return;
    }
    if (*p).nEntry > 0 as libc::c_int {
        memset(
            &mut eocd as *mut ZipfileEOCD as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<ZipfileEOCD>() as libc::c_ulong,
        );
        eocd.nEntry = (*p).nEntry as u16_0;
        eocd.nEntryTotal = (*p).nEntry as u16_0;
        eocd.nSize = (*p).cds.n as u32_0;
        eocd.iOffset = (*p).body.n as u32_0;
        nZip = ((*p).body.n + (*p).cds.n + 22 as libc::c_int) as sqlite3_int64;
        aZip = sqlite3_malloc64(nZip as sqlite3_uint64) as *mut u8_0;
        if aZip.is_null() {
            sqlite3_result_error_nomem(pCtx);
        } else {
            memcpy(
                aZip as *mut libc::c_void,
                (*p).body.a as *const libc::c_void,
                (*p).body.n as libc::c_ulong,
            );
            memcpy(
                &mut *aZip.offset((*p).body.n as isize) as *mut u8_0
                    as *mut libc::c_void,
                (*p).cds.a as *const libc::c_void,
                (*p).cds.n as libc::c_ulong,
            );
            zipfileSerializeEOCD(
                &mut eocd,
                &mut *aZip.offset(((*p).body.n + (*p).cds.n) as isize),
            );
            sqlite3_result_blob(
                pCtx,
                aZip as *const libc::c_void,
                nZip as libc::c_int,
                Some(zipfileFree as unsafe extern "C" fn(*mut libc::c_void) -> ()),
            );
        }
    }
    sqlite3_free((*p).body.a as *mut libc::c_void);
    sqlite3_free((*p).cds.a as *mut libc::c_void);
}
unsafe extern "C" fn zipfileRegister(mut db: *mut sqlite3) -> libc::c_int {
    static mut zipfileModule: sqlite3_module = unsafe {
        {
            let mut init = sqlite3_module {
                iVersion: 1 as libc::c_int,
                xCreate: Some(
                    zipfileConnect
                        as unsafe extern "C" fn(
                            *mut sqlite3,
                            *mut libc::c_void,
                            libc::c_int,
                            *const *const libc::c_char,
                            *mut *mut sqlite3_vtab,
                            *mut *mut libc::c_char,
                        ) -> libc::c_int,
                ),
                xConnect: Some(
                    zipfileConnect
                        as unsafe extern "C" fn(
                            *mut sqlite3,
                            *mut libc::c_void,
                            libc::c_int,
                            *const *const libc::c_char,
                            *mut *mut sqlite3_vtab,
                            *mut *mut libc::c_char,
                        ) -> libc::c_int,
                ),
                xBestIndex: Some(
                    zipfileBestIndex
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab,
                            *mut sqlite3_index_info,
                        ) -> libc::c_int,
                ),
                xDisconnect: Some(
                    zipfileDisconnect
                        as unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int,
                ),
                xDestroy: Some(
                    zipfileDisconnect
                        as unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int,
                ),
                xOpen: Some(
                    zipfileOpen
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab,
                            *mut *mut sqlite3_vtab_cursor,
                        ) -> libc::c_int,
                ),
                xClose: Some(
                    zipfileClose
                        as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xFilter: Some(
                    zipfileFilter
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab_cursor,
                            libc::c_int,
                            *const libc::c_char,
                            libc::c_int,
                            *mut *mut sqlite3_value,
                        ) -> libc::c_int,
                ),
                xNext: Some(
                    zipfileNext
                        as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xEof: Some(
                    zipfileEof
                        as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xColumn: Some(
                    zipfileColumn
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab_cursor,
                            *mut sqlite3_context,
                            libc::c_int,
                        ) -> libc::c_int,
                ),
                xRowid: None,
                xUpdate: Some(
                    zipfileUpdate
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab,
                            libc::c_int,
                            *mut *mut sqlite3_value,
                            *mut sqlite_int64,
                        ) -> libc::c_int,
                ),
                xBegin: Some(
                    zipfileBegin
                        as unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int,
                ),
                xSync: None,
                xCommit: Some(
                    zipfileCommit
                        as unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int,
                ),
                xRollback: Some(
                    zipfileRollback
                        as unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int,
                ),
                xFindFunction: Some(
                    zipfileFindFunction
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab,
                            libc::c_int,
                            *const libc::c_char,
                            *mut Option::<
                                unsafe extern "C" fn(
                                    *mut sqlite3_context,
                                    libc::c_int,
                                    *mut *mut sqlite3_value,
                                ) -> (),
                            >,
                            *mut *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                xRename: None,
                xSavepoint: None,
                xRelease: None,
                xRollbackTo: None,
                xShadowName: None,
            };
            init
        }
    };
    let mut rc: libc::c_int = sqlite3_create_module(
        db,
        b"zipfile\0" as *const u8 as *const libc::c_char,
        &mut zipfileModule,
        0 as *mut libc::c_void,
    );
    if rc == 0 as libc::c_int {
        rc = sqlite3_overload_function(
            db,
            b"zipfile_cds\0" as *const u8 as *const libc::c_char,
            -(1 as libc::c_int),
        );
    }
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_function(
            db,
            b"zipfile\0" as *const u8 as *const libc::c_char,
            -(1 as libc::c_int),
            1 as libc::c_int,
            0 as *mut libc::c_void,
            None,
            Some(
                zipfileStep
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            Some(zipfileFinal as unsafe extern "C" fn(*mut sqlite3_context) -> ()),
        );
    }
    return rc;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_zipfile_init(
    mut db: *mut sqlite3,
    mut pzErrMsg: *mut *mut libc::c_char,
    mut pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    return zipfileRegister(db);
}
unsafe extern "C" fn sqlarCompressFunc(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    if sqlite3_value_type(*argv.offset(0 as libc::c_int as isize)) == 4 as libc::c_int {
        let mut pData: *const Bytef = sqlite3_value_blob(
            *argv.offset(0 as libc::c_int as isize),
        ) as *const Bytef;
        let mut nData: uLong = sqlite3_value_bytes(
            *argv.offset(0 as libc::c_int as isize),
        ) as uLong;
        let mut nOut: uLongf = compressBound(nData);
        let mut pOut: *mut Bytef = 0 as *mut Bytef;
        pOut = sqlite3_malloc(nOut as libc::c_int) as *mut Bytef;
        if pOut.is_null() {
            sqlite3_result_error_nomem(context);
            return;
        } else {
            if 0 as libc::c_int != compress(pOut, &mut nOut, pData, nData) {
                sqlite3_result_error(
                    context,
                    b"error in compress()\0" as *const u8 as *const libc::c_char,
                    -(1 as libc::c_int),
                );
            } else if nOut < nData {
                sqlite3_result_blob(
                    context,
                    pOut as *const libc::c_void,
                    nOut as libc::c_int,
                    ::std::mem::transmute::<
                        libc::intptr_t,
                        sqlite3_destructor_type,
                    >(-(1 as libc::c_int) as libc::intptr_t),
                );
            } else {
                sqlite3_result_value(context, *argv.offset(0 as libc::c_int as isize));
            }
            sqlite3_free(pOut as *mut libc::c_void);
        }
    } else {
        sqlite3_result_value(context, *argv.offset(0 as libc::c_int as isize));
    };
}
unsafe extern "C" fn sqlarUncompressFunc(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut nData: uLong = 0;
    let mut sz: uLongf = 0;
    sz = sqlite3_value_int(*argv.offset(1 as libc::c_int as isize)) as uLongf;
    if sz <= 0 as libc::c_int as libc::c_ulong
        || {
            nData = sqlite3_value_bytes(*argv.offset(0 as libc::c_int as isize))
                as uLong;
            sz == nData
        }
    {
        sqlite3_result_value(context, *argv.offset(0 as libc::c_int as isize));
    } else {
        let mut pData: *const Bytef = sqlite3_value_blob(
            *argv.offset(0 as libc::c_int as isize),
        ) as *const Bytef;
        let mut pOut: *mut Bytef = sqlite3_malloc(sz as libc::c_int) as *mut Bytef;
        if 0 as libc::c_int != uncompress(pOut, &mut sz, pData, nData) {
            sqlite3_result_error(
                context,
                b"error in uncompress()\0" as *const u8 as *const libc::c_char,
                -(1 as libc::c_int),
            );
        } else {
            sqlite3_result_blob(
                context,
                pOut as *const libc::c_void,
                sz as libc::c_int,
                ::std::mem::transmute::<
                    libc::intptr_t,
                    sqlite3_destructor_type,
                >(-(1 as libc::c_int) as libc::intptr_t),
            );
        }
        sqlite3_free(pOut as *mut libc::c_void);
    };
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_sqlar_init(
    mut db: *mut sqlite3,
    mut pzErrMsg: *mut *mut libc::c_char,
    mut pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    rc = sqlite3_create_function(
        db,
        b"sqlar_compress\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
        1 as libc::c_int | 0x200000 as libc::c_int,
        0 as *mut libc::c_void,
        Some(
            sqlarCompressFunc
                as unsafe extern "C" fn(
                    *mut sqlite3_context,
                    libc::c_int,
                    *mut *mut sqlite3_value,
                ) -> (),
        ),
        None,
        None,
    );
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_function(
            db,
            b"sqlar_uncompress\0" as *const u8 as *const libc::c_char,
            2 as libc::c_int,
            1 as libc::c_int | 0x200000 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                sqlarUncompressFunc
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
    }
    return rc;
}
unsafe extern "C" fn idxMalloc(
    mut pRc: *mut libc::c_int,
    mut nByte: libc::c_int,
) -> *mut libc::c_void {
    let mut pRet: *mut libc::c_void = 0 as *mut libc::c_void;
    pRet = sqlite3_malloc(nByte);
    if !pRet.is_null() {
        memset(pRet, 0 as libc::c_int, nByte as libc::c_ulong);
    } else {
        *pRc = 7 as libc::c_int;
    }
    return pRet;
}
unsafe extern "C" fn idxHashInit(mut pHash: *mut IdxHash) {
    memset(
        pHash as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<IdxHash>() as libc::c_ulong,
    );
}
unsafe extern "C" fn idxHashClear(mut pHash: *mut IdxHash) {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < 1023 as libc::c_int {
        let mut pEntry: *mut IdxHashEntry = 0 as *mut IdxHashEntry;
        let mut pNext: *mut IdxHashEntry = 0 as *mut IdxHashEntry;
        pEntry = (*pHash).aHash[i as usize];
        while !pEntry.is_null() {
            pNext = (*pEntry).pHashNext;
            sqlite3_free((*pEntry).zVal2 as *mut libc::c_void);
            sqlite3_free(pEntry as *mut libc::c_void);
            pEntry = pNext;
        }
        i += 1;
    }
    memset(
        pHash as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<IdxHash>() as libc::c_ulong,
    );
}
unsafe extern "C" fn idxHashString(
    mut z: *const libc::c_char,
    mut n: libc::c_int,
) -> libc::c_int {
    let mut ret: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < n {
        ret = ret
            .wrapping_add(
                (ret << 3 as libc::c_int)
                    .wrapping_add(*z.offset(i as isize) as libc::c_uchar as libc::c_uint),
            );
        i += 1;
    }
    return ret.wrapping_rem(1023 as libc::c_int as libc::c_uint) as libc::c_int;
}
unsafe extern "C" fn idxHashAdd(
    mut pRc: *mut libc::c_int,
    mut pHash: *mut IdxHash,
    mut zKey: *const libc::c_char,
    mut zVal: *const libc::c_char,
) -> libc::c_int {
    let mut nKey: libc::c_int = strlen(zKey) as libc::c_int;
    let mut iHash: libc::c_int = idxHashString(zKey, nKey);
    let mut nVal: libc::c_int = if !zVal.is_null() {
        strlen(zVal) as libc::c_int
    } else {
        0 as libc::c_int
    };
    let mut pEntry: *mut IdxHashEntry = 0 as *mut IdxHashEntry;
    pEntry = (*pHash).aHash[iHash as usize];
    while !pEntry.is_null() {
        if strlen((*pEntry).zKey) as libc::c_int == nKey
            && 0 as libc::c_int
                == memcmp(
                    (*pEntry).zKey as *const libc::c_void,
                    zKey as *const libc::c_void,
                    nKey as libc::c_ulong,
                )
        {
            return 1 as libc::c_int;
        }
        pEntry = (*pEntry).pHashNext;
    }
    pEntry = idxMalloc(
        pRc,
        (::std::mem::size_of::<IdxHashEntry>() as libc::c_ulong)
            .wrapping_add(nKey as libc::c_ulong)
            .wrapping_add(1 as libc::c_int as libc::c_ulong)
            .wrapping_add(nVal as libc::c_ulong)
            .wrapping_add(1 as libc::c_int as libc::c_ulong) as libc::c_int,
    ) as *mut IdxHashEntry;
    if !pEntry.is_null() {
        let ref mut fresh157 = (*pEntry).zKey;
        *fresh157 = &mut *pEntry.offset(1 as libc::c_int as isize) as *mut IdxHashEntry
            as *mut libc::c_char;
        memcpy(
            (*pEntry).zKey as *mut libc::c_void,
            zKey as *const libc::c_void,
            nKey as libc::c_ulong,
        );
        if !zVal.is_null() {
            let ref mut fresh158 = (*pEntry).zVal;
            *fresh158 = &mut *((*pEntry).zKey).offset((nKey + 1 as libc::c_int) as isize)
                as *mut libc::c_char;
            memcpy(
                (*pEntry).zVal as *mut libc::c_void,
                zVal as *const libc::c_void,
                nVal as libc::c_ulong,
            );
        }
        let ref mut fresh159 = (*pEntry).pHashNext;
        *fresh159 = (*pHash).aHash[iHash as usize];
        let ref mut fresh160 = (*pHash).aHash[iHash as usize];
        *fresh160 = pEntry;
        let ref mut fresh161 = (*pEntry).pNext;
        *fresh161 = (*pHash).pFirst;
        let ref mut fresh162 = (*pHash).pFirst;
        *fresh162 = pEntry;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn idxHashFind(
    mut pHash: *mut IdxHash,
    mut zKey: *const libc::c_char,
    mut nKey: libc::c_int,
) -> *mut IdxHashEntry {
    let mut iHash: libc::c_int = 0;
    let mut pEntry: *mut IdxHashEntry = 0 as *mut IdxHashEntry;
    if nKey < 0 as libc::c_int {
        nKey = strlen(zKey) as libc::c_int;
    }
    iHash = idxHashString(zKey, nKey);
    pEntry = (*pHash).aHash[iHash as usize];
    while !pEntry.is_null() {
        if strlen((*pEntry).zKey) as libc::c_int == nKey
            && 0 as libc::c_int
                == memcmp(
                    (*pEntry).zKey as *const libc::c_void,
                    zKey as *const libc::c_void,
                    nKey as libc::c_ulong,
                )
        {
            return pEntry;
        }
        pEntry = (*pEntry).pHashNext;
    }
    return 0 as *mut IdxHashEntry;
}
unsafe extern "C" fn idxHashSearch(
    mut pHash: *mut IdxHash,
    mut zKey: *const libc::c_char,
    mut nKey: libc::c_int,
) -> *const libc::c_char {
    let mut pEntry: *mut IdxHashEntry = idxHashFind(pHash, zKey, nKey);
    if !pEntry.is_null() {
        return (*pEntry).zVal;
    }
    return 0 as *const libc::c_char;
}
unsafe extern "C" fn idxNewConstraint(
    mut pRc: *mut libc::c_int,
    mut zColl: *const libc::c_char,
) -> *mut IdxConstraint {
    let mut pNew: *mut IdxConstraint = 0 as *mut IdxConstraint;
    let mut nColl: libc::c_int = strlen(zColl) as libc::c_int;
    pNew = idxMalloc(
        pRc,
        (::std::mem::size_of::<IdxConstraint>() as libc::c_ulong)
            .wrapping_mul(nColl as libc::c_ulong)
            .wrapping_add(1 as libc::c_int as libc::c_ulong) as libc::c_int,
    ) as *mut IdxConstraint;
    if !pNew.is_null() {
        let ref mut fresh163 = (*pNew).zColl;
        *fresh163 = &mut *pNew.offset(1 as libc::c_int as isize) as *mut IdxConstraint
            as *mut libc::c_char;
        memcpy(
            (*pNew).zColl as *mut libc::c_void,
            zColl as *const libc::c_void,
            (nColl + 1 as libc::c_int) as libc::c_ulong,
        );
    }
    return pNew;
}
unsafe extern "C" fn idxDatabaseError(
    mut db: *mut sqlite3,
    mut pzErrmsg: *mut *mut libc::c_char,
) {
    *pzErrmsg = sqlite3_mprintf(
        b"%s\0" as *const u8 as *const libc::c_char,
        sqlite3_errmsg(db),
    );
}
unsafe extern "C" fn idxPrepareStmt(
    mut db: *mut sqlite3,
    mut ppStmt: *mut *mut sqlite3_stmt,
    mut pzErrmsg: *mut *mut libc::c_char,
    mut zSql: *const libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = sqlite3_prepare_v2(
        db,
        zSql,
        -(1 as libc::c_int),
        ppStmt,
        0 as *mut *const libc::c_char,
    );
    if rc != 0 as libc::c_int {
        *ppStmt = 0 as *mut sqlite3_stmt;
        idxDatabaseError(db, pzErrmsg);
    }
    return rc;
}
unsafe extern "C" fn idxPrintfPrepareStmt(
    mut db: *mut sqlite3,
    mut ppStmt: *mut *mut sqlite3_stmt,
    mut pzErrmsg: *mut *mut libc::c_char,
    mut zFmt: *const libc::c_char,
    mut args: ...
) -> libc::c_int {
    let mut ap: ::std::ffi::VaListImpl;
    let mut rc: libc::c_int = 0;
    let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
    ap = args.clone();
    zSql = sqlite3_vmprintf(zFmt, ap.as_va_list());
    if zSql.is_null() {
        rc = 7 as libc::c_int;
    } else {
        rc = idxPrepareStmt(db, ppStmt, pzErrmsg, zSql);
        sqlite3_free(zSql as *mut libc::c_void);
    }
    return rc;
}
unsafe extern "C" fn expertDequote(mut zIn: *const libc::c_char) -> *mut libc::c_char {
    let mut n: libc::c_int = strlen(zIn) as libc::c_int;
    let mut zRet: *mut libc::c_char = sqlite3_malloc(n) as *mut libc::c_char;
    if !zRet.is_null() {
        let mut iOut: libc::c_int = 0 as libc::c_int;
        let mut iIn: libc::c_int = 0 as libc::c_int;
        iIn = 1 as libc::c_int;
        while iIn < n - 1 as libc::c_int {
            if *zIn.offset(iIn as isize) as libc::c_int == '\'' as i32 {
                iIn += 1;
            }
            let fresh164 = iOut;
            iOut = iOut + 1;
            *zRet.offset(fresh164 as isize) = *zIn.offset(iIn as isize);
            iIn += 1;
        }
        *zRet.offset(iOut as isize) = '\0' as i32 as libc::c_char;
    }
    return zRet;
}
unsafe extern "C" fn expertConnect(
    mut db: *mut sqlite3,
    mut pAux: *mut libc::c_void,
    mut argc: libc::c_int,
    mut argv: *const *const libc::c_char,
    mut ppVtab: *mut *mut sqlite3_vtab,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut pExpert: *mut sqlite3expert = pAux as *mut sqlite3expert;
    let mut p: *mut ExpertVtab = 0 as *mut ExpertVtab;
    let mut rc: libc::c_int = 0;
    if argc != 4 as libc::c_int {
        *pzErr = sqlite3_mprintf(
            b"internal error!\0" as *const u8 as *const libc::c_char,
        );
        rc = 1 as libc::c_int;
    } else {
        let mut zCreateTable: *mut libc::c_char = expertDequote(
            *argv.offset(3 as libc::c_int as isize),
        );
        if !zCreateTable.is_null() {
            rc = sqlite3_declare_vtab(db, zCreateTable);
            if rc == 0 as libc::c_int {
                p = idxMalloc(
                    &mut rc,
                    ::std::mem::size_of::<ExpertVtab>() as libc::c_ulong as libc::c_int,
                ) as *mut ExpertVtab;
            }
            if rc == 0 as libc::c_int {
                let ref mut fresh165 = (*p).pExpert;
                *fresh165 = pExpert;
                let ref mut fresh166 = (*p).pTab;
                *fresh166 = (*pExpert).pTable;
            }
            sqlite3_free(zCreateTable as *mut libc::c_void);
        } else {
            rc = 7 as libc::c_int;
        }
    }
    *ppVtab = p as *mut sqlite3_vtab;
    return rc;
}
unsafe extern "C" fn expertDisconnect(mut pVtab: *mut sqlite3_vtab) -> libc::c_int {
    let mut p: *mut ExpertVtab = pVtab as *mut ExpertVtab;
    sqlite3_free(p as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn expertBestIndex(
    mut pVtab: *mut sqlite3_vtab,
    mut pIdxInfo: *mut sqlite3_index_info,
) -> libc::c_int {
    let mut p: *mut ExpertVtab = pVtab as *mut ExpertVtab;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut n: libc::c_int = 0 as libc::c_int;
    let mut pScan: *mut IdxScan = 0 as *mut IdxScan;
    let opmask: libc::c_int = 2 as libc::c_int | 4 as libc::c_int | 16 as libc::c_int
        | 32 as libc::c_int | 8 as libc::c_int;
    pScan = idxMalloc(
        &mut rc,
        ::std::mem::size_of::<IdxScan>() as libc::c_ulong as libc::c_int,
    ) as *mut IdxScan;
    if !pScan.is_null() {
        let mut i: libc::c_int = 0;
        let ref mut fresh167 = (*pScan).pTab;
        *fresh167 = (*p).pTab;
        let ref mut fresh168 = (*pScan).pNextScan;
        *fresh168 = (*(*p).pExpert).pScan;
        let ref mut fresh169 = (*(*p).pExpert).pScan;
        *fresh169 = pScan;
        i = 0 as libc::c_int;
        while i < (*pIdxInfo).nConstraint {
            let mut pCons: *mut sqlite3_index_constraint = &mut *((*pIdxInfo)
                .aConstraint)
                .offset(i as isize) as *mut sqlite3_index_constraint;
            if (*pCons).usable as libc::c_int != 0
                && (*pCons).iColumn >= 0 as libc::c_int
                && (*((*(*p).pTab).aCol).offset((*pCons).iColumn as isize)).iPk
                    == 0 as libc::c_int && (*pCons).op as libc::c_int & opmask != 0
            {
                let mut pNew: *mut IdxConstraint = 0 as *mut IdxConstraint;
                let mut zColl: *const libc::c_char = sqlite3_vtab_collation(pIdxInfo, i);
                pNew = idxNewConstraint(&mut rc, zColl);
                if !pNew.is_null() {
                    (*pNew).iCol = (*pCons).iColumn;
                    if (*pCons).op as libc::c_int == 2 as libc::c_int {
                        let ref mut fresh170 = (*pNew).pNext;
                        *fresh170 = (*pScan).pEq;
                        let ref mut fresh171 = (*pScan).pEq;
                        *fresh171 = pNew;
                    } else {
                        (*pNew).bRange = 1 as libc::c_int;
                        let ref mut fresh172 = (*pNew).pNext;
                        *fresh172 = (*pScan).pRange;
                        let ref mut fresh173 = (*pScan).pRange;
                        *fresh173 = pNew;
                    }
                }
                n += 1;
                (*((*pIdxInfo).aConstraintUsage).offset(i as isize)).argvIndex = n;
            }
            i += 1;
        }
        i = (*pIdxInfo).nOrderBy - 1 as libc::c_int;
        while i >= 0 as libc::c_int {
            let mut iCol: libc::c_int = (*((*pIdxInfo).aOrderBy).offset(i as isize))
                .iColumn;
            if iCol >= 0 as libc::c_int {
                let mut pNew_0: *mut IdxConstraint = idxNewConstraint(
                    &mut rc,
                    (*((*(*p).pTab).aCol).offset(iCol as isize)).zColl,
                );
                if !pNew_0.is_null() {
                    (*pNew_0).iCol = iCol;
                    (*pNew_0)
                        .bDesc = (*((*pIdxInfo).aOrderBy).offset(i as isize)).desc
                        as libc::c_int;
                    let ref mut fresh174 = (*pNew_0).pNext;
                    *fresh174 = (*pScan).pOrder;
                    let ref mut fresh175 = (*pNew_0).pLink;
                    *fresh175 = (*pScan).pOrder;
                    let ref mut fresh176 = (*pScan).pOrder;
                    *fresh176 = pNew_0;
                    n += 1;
                }
            }
            i -= 1;
        }
    }
    (*pIdxInfo).estimatedCost = 1000000.0f64 / (n + 1 as libc::c_int) as libc::c_double;
    return rc;
}
unsafe extern "C" fn expertUpdate(
    mut pVtab: *mut sqlite3_vtab,
    mut nData: libc::c_int,
    mut azData: *mut *mut sqlite3_value,
    mut pRowid: *mut sqlite_int64,
) -> libc::c_int {
    return 0 as libc::c_int;
}
unsafe extern "C" fn expertOpen(
    mut pVTab: *mut sqlite3_vtab,
    mut ppCursor: *mut *mut sqlite3_vtab_cursor,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut pCsr: *mut ExpertCsr = 0 as *mut ExpertCsr;
    pCsr = idxMalloc(
        &mut rc,
        ::std::mem::size_of::<ExpertCsr>() as libc::c_ulong as libc::c_int,
    ) as *mut ExpertCsr;
    *ppCursor = pCsr as *mut sqlite3_vtab_cursor;
    return rc;
}
unsafe extern "C" fn expertClose(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCsr: *mut ExpertCsr = cur as *mut ExpertCsr;
    sqlite3_finalize((*pCsr).pData);
    sqlite3_free(pCsr as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn expertEof(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCsr: *mut ExpertCsr = cur as *mut ExpertCsr;
    return ((*pCsr).pData == 0 as *mut sqlite3_stmt) as libc::c_int;
}
unsafe extern "C" fn expertNext(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCsr: *mut ExpertCsr = cur as *mut ExpertCsr;
    let mut rc: libc::c_int = 0 as libc::c_int;
    rc = sqlite3_step((*pCsr).pData);
    if rc != 100 as libc::c_int {
        rc = sqlite3_finalize((*pCsr).pData);
        let ref mut fresh177 = (*pCsr).pData;
        *fresh177 = 0 as *mut sqlite3_stmt;
    } else {
        rc = 0 as libc::c_int;
    }
    return rc;
}
unsafe extern "C" fn expertRowid(
    mut cur: *mut sqlite3_vtab_cursor,
    mut pRowid: *mut sqlite_int64,
) -> libc::c_int {
    *pRowid = 0 as libc::c_int as sqlite_int64;
    return 0 as libc::c_int;
}
unsafe extern "C" fn expertColumn(
    mut cur: *mut sqlite3_vtab_cursor,
    mut ctx: *mut sqlite3_context,
    mut i: libc::c_int,
) -> libc::c_int {
    let mut pCsr: *mut ExpertCsr = cur as *mut ExpertCsr;
    let mut pVal: *mut sqlite3_value = 0 as *mut sqlite3_value;
    pVal = sqlite3_column_value((*pCsr).pData, i);
    if !pVal.is_null() {
        sqlite3_result_value(ctx, pVal);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn expertFilter(
    mut cur: *mut sqlite3_vtab_cursor,
    mut idxNum: libc::c_int,
    mut idxStr: *const libc::c_char,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) -> libc::c_int {
    let mut pCsr: *mut ExpertCsr = cur as *mut ExpertCsr;
    let mut pVtab: *mut ExpertVtab = (*cur).pVtab as *mut ExpertVtab;
    let mut pExpert: *mut sqlite3expert = (*pVtab).pExpert;
    let mut rc: libc::c_int = 0;
    rc = sqlite3_finalize((*pCsr).pData);
    let ref mut fresh178 = (*pCsr).pData;
    *fresh178 = 0 as *mut sqlite3_stmt;
    if rc == 0 as libc::c_int {
        rc = idxPrintfPrepareStmt(
            (*pExpert).db,
            &mut (*pCsr).pData as *mut *mut sqlite3_stmt,
            &mut (*pVtab).base.zErrMsg as *mut *mut libc::c_char,
            b"SELECT * FROM main.%Q WHERE sample()\0" as *const u8
                as *const libc::c_char,
            (*(*pVtab).pTab).zName,
        );
    }
    if rc == 0 as libc::c_int {
        rc = expertNext(cur);
    }
    return rc;
}
unsafe extern "C" fn idxRegisterVtab(mut p: *mut sqlite3expert) -> libc::c_int {
    static mut expertModule: sqlite3_module = unsafe {
        {
            let mut init = sqlite3_module {
                iVersion: 2 as libc::c_int,
                xCreate: Some(
                    expertConnect
                        as unsafe extern "C" fn(
                            *mut sqlite3,
                            *mut libc::c_void,
                            libc::c_int,
                            *const *const libc::c_char,
                            *mut *mut sqlite3_vtab,
                            *mut *mut libc::c_char,
                        ) -> libc::c_int,
                ),
                xConnect: Some(
                    expertConnect
                        as unsafe extern "C" fn(
                            *mut sqlite3,
                            *mut libc::c_void,
                            libc::c_int,
                            *const *const libc::c_char,
                            *mut *mut sqlite3_vtab,
                            *mut *mut libc::c_char,
                        ) -> libc::c_int,
                ),
                xBestIndex: Some(
                    expertBestIndex
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab,
                            *mut sqlite3_index_info,
                        ) -> libc::c_int,
                ),
                xDisconnect: Some(
                    expertDisconnect
                        as unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int,
                ),
                xDestroy: Some(
                    expertDisconnect
                        as unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int,
                ),
                xOpen: Some(
                    expertOpen
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab,
                            *mut *mut sqlite3_vtab_cursor,
                        ) -> libc::c_int,
                ),
                xClose: Some(
                    expertClose
                        as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xFilter: Some(
                    expertFilter
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab_cursor,
                            libc::c_int,
                            *const libc::c_char,
                            libc::c_int,
                            *mut *mut sqlite3_value,
                        ) -> libc::c_int,
                ),
                xNext: Some(
                    expertNext
                        as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xEof: Some(
                    expertEof
                        as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xColumn: Some(
                    expertColumn
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab_cursor,
                            *mut sqlite3_context,
                            libc::c_int,
                        ) -> libc::c_int,
                ),
                xRowid: Some(
                    expertRowid
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab_cursor,
                            *mut sqlite_int64,
                        ) -> libc::c_int,
                ),
                xUpdate: Some(
                    expertUpdate
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab,
                            libc::c_int,
                            *mut *mut sqlite3_value,
                            *mut sqlite_int64,
                        ) -> libc::c_int,
                ),
                xBegin: None,
                xSync: None,
                xCommit: None,
                xRollback: None,
                xFindFunction: None,
                xRename: None,
                xSavepoint: None,
                xRelease: None,
                xRollbackTo: None,
                xShadowName: None,
            };
            init
        }
    };
    return sqlite3_create_module(
        (*p).dbv,
        b"expert\0" as *const u8 as *const libc::c_char,
        &mut expertModule,
        p as *mut libc::c_void,
    );
}
unsafe extern "C" fn idxFinalize(
    mut pRc: *mut libc::c_int,
    mut pStmt: *mut sqlite3_stmt,
) {
    let mut rc: libc::c_int = sqlite3_finalize(pStmt);
    if *pRc == 0 as libc::c_int {
        *pRc = rc;
    }
}
unsafe extern "C" fn idxGetTableInfo(
    mut db: *mut sqlite3,
    mut zTab: *const libc::c_char,
    mut ppOut: *mut *mut IdxTable,
    mut pzErrmsg: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut p1: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut nCol: libc::c_int = 0 as libc::c_int;
    let mut nTab: libc::c_int = 0;
    let mut nByte: libc::c_int = 0;
    let mut pNew: *mut IdxTable = 0 as *mut IdxTable;
    let mut rc: libc::c_int = 0;
    let mut rc2: libc::c_int = 0;
    let mut pCsr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut nPk: libc::c_int = 0 as libc::c_int;
    *ppOut = 0 as *mut IdxTable;
    if zTab.is_null() {
        return 1 as libc::c_int;
    }
    nTab = strlen(zTab) as libc::c_int;
    nByte = (::std::mem::size_of::<IdxTable>() as libc::c_ulong)
        .wrapping_add(nTab as libc::c_ulong)
        .wrapping_add(1 as libc::c_int as libc::c_ulong) as libc::c_int;
    rc = idxPrintfPrepareStmt(
        db,
        &mut p1 as *mut *mut sqlite3_stmt,
        pzErrmsg,
        b"PRAGMA table_xinfo=%Q\0" as *const u8 as *const libc::c_char,
        zTab,
    );
    while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(p1) {
        let mut zCol: *const libc::c_char = sqlite3_column_text(p1, 1 as libc::c_int)
            as *const libc::c_char;
        let mut zColSeq: *const libc::c_char = 0 as *const libc::c_char;
        if zCol.is_null() {
            rc = 1 as libc::c_int;
            break;
        } else {
            nByte += 1 as libc::c_int + strlen(zCol) as libc::c_int;
            rc = sqlite3_table_column_metadata(
                db,
                b"main\0" as *const u8 as *const libc::c_char,
                zTab,
                zCol,
                0 as *mut *const libc::c_char,
                &mut zColSeq,
                0 as *mut libc::c_int,
                0 as *mut libc::c_int,
                0 as *mut libc::c_int,
            );
            if zColSeq.is_null() {
                zColSeq = b"binary\0" as *const u8 as *const libc::c_char;
            }
            nByte += 1 as libc::c_int + strlen(zColSeq) as libc::c_int;
            nCol += 1;
            nPk
                += (sqlite3_column_int(p1, 5 as libc::c_int) > 0 as libc::c_int)
                    as libc::c_int;
        }
    }
    rc2 = sqlite3_reset(p1);
    if rc == 0 as libc::c_int {
        rc = rc2;
    }
    nByte = (nByte as libc::c_ulong)
        .wrapping_add(
            (::std::mem::size_of::<IdxColumn>() as libc::c_ulong)
                .wrapping_mul(nCol as libc::c_ulong),
        ) as libc::c_int as libc::c_int;
    if rc == 0 as libc::c_int {
        pNew = idxMalloc(&mut rc, nByte) as *mut IdxTable;
    }
    if rc == 0 as libc::c_int {
        let ref mut fresh179 = (*pNew).aCol;
        *fresh179 = &mut *pNew.offset(1 as libc::c_int as isize) as *mut IdxTable
            as *mut IdxColumn;
        (*pNew).nCol = nCol;
        pCsr = &mut *((*pNew).aCol).offset(nCol as isize) as *mut IdxColumn
            as *mut libc::c_char;
    }
    nCol = 0 as libc::c_int;
    while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(p1) {
        let mut zCol_0: *const libc::c_char = sqlite3_column_text(p1, 1 as libc::c_int)
            as *const libc::c_char;
        let mut zColSeq_0: *const libc::c_char = 0 as *const libc::c_char;
        let mut nCopy: libc::c_int = 0;
        if zCol_0.is_null() {
            continue;
        }
        nCopy = strlen(zCol_0) as libc::c_int + 1 as libc::c_int;
        let ref mut fresh180 = (*((*pNew).aCol).offset(nCol as isize)).zName;
        *fresh180 = pCsr;
        (*((*pNew).aCol).offset(nCol as isize))
            .iPk = (sqlite3_column_int(p1, 5 as libc::c_int) == 1 as libc::c_int
            && nPk == 1 as libc::c_int) as libc::c_int;
        memcpy(
            pCsr as *mut libc::c_void,
            zCol_0 as *const libc::c_void,
            nCopy as libc::c_ulong,
        );
        pCsr = pCsr.offset(nCopy as isize);
        rc = sqlite3_table_column_metadata(
            db,
            b"main\0" as *const u8 as *const libc::c_char,
            zTab,
            zCol_0,
            0 as *mut *const libc::c_char,
            &mut zColSeq_0,
            0 as *mut libc::c_int,
            0 as *mut libc::c_int,
            0 as *mut libc::c_int,
        );
        if rc == 0 as libc::c_int {
            if zColSeq_0.is_null() {
                zColSeq_0 = b"binary\0" as *const u8 as *const libc::c_char;
            }
            nCopy = strlen(zColSeq_0) as libc::c_int + 1 as libc::c_int;
            let ref mut fresh181 = (*((*pNew).aCol).offset(nCol as isize)).zColl;
            *fresh181 = pCsr;
            memcpy(
                pCsr as *mut libc::c_void,
                zColSeq_0 as *const libc::c_void,
                nCopy as libc::c_ulong,
            );
            pCsr = pCsr.offset(nCopy as isize);
        }
        nCol += 1;
    }
    idxFinalize(&mut rc, p1);
    if rc != 0 as libc::c_int {
        sqlite3_free(pNew as *mut libc::c_void);
        pNew = 0 as *mut IdxTable;
    } else if !pNew.is_null() {
        let ref mut fresh182 = (*pNew).zName;
        *fresh182 = pCsr;
        if !((*pNew).zName).is_null() {
            memcpy(
                (*pNew).zName as *mut libc::c_void,
                zTab as *const libc::c_void,
                (nTab + 1 as libc::c_int) as libc::c_ulong,
            );
        }
    }
    *ppOut = pNew;
    return rc;
}
unsafe extern "C" fn idxAppendText(
    mut pRc: *mut libc::c_int,
    mut zIn: *mut libc::c_char,
    mut zFmt: *const libc::c_char,
    mut args: ...
) -> *mut libc::c_char {
    let mut ap: ::std::ffi::VaListImpl;
    let mut zAppend: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zRet: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut nIn: libc::c_int = if !zIn.is_null() {
        strlen(zIn) as libc::c_int
    } else {
        0 as libc::c_int
    };
    let mut nAppend: libc::c_int = 0 as libc::c_int;
    ap = args.clone();
    if *pRc == 0 as libc::c_int {
        zAppend = sqlite3_vmprintf(zFmt, ap.as_va_list());
        if !zAppend.is_null() {
            nAppend = strlen(zAppend) as libc::c_int;
            zRet = sqlite3_malloc(nIn + nAppend + 1 as libc::c_int) as *mut libc::c_char;
        }
        if !zAppend.is_null() && !zRet.is_null() {
            if nIn != 0 {
                memcpy(
                    zRet as *mut libc::c_void,
                    zIn as *const libc::c_void,
                    nIn as libc::c_ulong,
                );
            }
            memcpy(
                &mut *zRet.offset(nIn as isize) as *mut libc::c_char
                    as *mut libc::c_void,
                zAppend as *const libc::c_void,
                (nAppend + 1 as libc::c_int) as libc::c_ulong,
            );
        } else {
            sqlite3_free(zRet as *mut libc::c_void);
            zRet = 0 as *mut libc::c_char;
            *pRc = 7 as libc::c_int;
        }
        sqlite3_free(zAppend as *mut libc::c_void);
        sqlite3_free(zIn as *mut libc::c_void);
    }
    return zRet;
}
unsafe extern "C" fn idxIdentifierRequiresQuotes(
    mut zId: *const libc::c_char,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut nId: libc::c_int = strlen(zId) as libc::c_int;
    if sqlite3_keyword_check(zId, nId) != 0 {
        return 1 as libc::c_int;
    }
    i = 0 as libc::c_int;
    while *zId.offset(i as isize) != 0 {
        if !(*zId.offset(i as isize) as libc::c_int == '_' as i32)
            && !(*zId.offset(i as isize) as libc::c_int >= '0' as i32
                && *zId.offset(i as isize) as libc::c_int <= '9' as i32)
            && !(*zId.offset(i as isize) as libc::c_int >= 'a' as i32
                && *zId.offset(i as isize) as libc::c_int <= 'z' as i32)
            && !(*zId.offset(i as isize) as libc::c_int >= 'A' as i32
                && *zId.offset(i as isize) as libc::c_int <= 'Z' as i32)
        {
            return 1 as libc::c_int;
        }
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn idxAppendColDefn(
    mut pRc: *mut libc::c_int,
    mut zIn: *mut libc::c_char,
    mut pTab: *mut IdxTable,
    mut pCons: *mut IdxConstraint,
) -> *mut libc::c_char {
    let mut zRet: *mut libc::c_char = zIn;
    let mut p: *mut IdxColumn = &mut *((*pTab).aCol).offset((*pCons).iCol as isize)
        as *mut IdxColumn;
    if !zRet.is_null() {
        zRet = idxAppendText(pRc, zRet, b", \0" as *const u8 as *const libc::c_char);
    }
    if idxIdentifierRequiresQuotes((*p).zName) != 0 {
        zRet = idxAppendText(
            pRc,
            zRet,
            b"%Q\0" as *const u8 as *const libc::c_char,
            (*p).zName,
        );
    } else {
        zRet = idxAppendText(
            pRc,
            zRet,
            b"%s\0" as *const u8 as *const libc::c_char,
            (*p).zName,
        );
    }
    if sqlite3_stricmp((*p).zColl, (*pCons).zColl) != 0 {
        if idxIdentifierRequiresQuotes((*pCons).zColl) != 0 {
            zRet = idxAppendText(
                pRc,
                zRet,
                b" COLLATE %Q\0" as *const u8 as *const libc::c_char,
                (*pCons).zColl,
            );
        } else {
            zRet = idxAppendText(
                pRc,
                zRet,
                b" COLLATE %s\0" as *const u8 as *const libc::c_char,
                (*pCons).zColl,
            );
        }
    }
    if (*pCons).bDesc != 0 {
        zRet = idxAppendText(pRc, zRet, b" DESC\0" as *const u8 as *const libc::c_char);
    }
    return zRet;
}
unsafe extern "C" fn idxFindCompatible(
    mut pRc: *mut libc::c_int,
    mut dbm: *mut sqlite3,
    mut pScan: *mut IdxScan,
    mut pEq: *mut IdxConstraint,
    mut pTail: *mut IdxConstraint,
) -> libc::c_int {
    let mut zTbl: *const libc::c_char = (*(*pScan).pTab).zName;
    let mut pIdxList: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut pIter: *mut IdxConstraint = 0 as *mut IdxConstraint;
    let mut nEq: libc::c_int = 0 as libc::c_int;
    let mut rc: libc::c_int = 0;
    pIter = pEq;
    while !pIter.is_null() {
        nEq += 1;
        pIter = (*pIter).pLink;
    }
    rc = idxPrintfPrepareStmt(
        dbm,
        &mut pIdxList as *mut *mut sqlite3_stmt,
        0 as *mut *mut libc::c_char,
        b"PRAGMA index_list=%Q\0" as *const u8 as *const libc::c_char,
        zTbl,
    );
    while rc == 0 as libc::c_int && sqlite3_step(pIdxList) == 100 as libc::c_int {
        let mut bMatch: libc::c_int = 1 as libc::c_int;
        let mut pT: *mut IdxConstraint = pTail;
        let mut pInfo: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        let mut zIdx: *const libc::c_char = sqlite3_column_text(
            pIdxList,
            1 as libc::c_int,
        ) as *const libc::c_char;
        if zIdx.is_null() {
            continue;
        }
        pIter = pEq;
        while !pIter.is_null() {
            (*pIter).bFlag = 0 as libc::c_int;
            pIter = (*pIter).pLink;
        }
        rc = idxPrintfPrepareStmt(
            dbm,
            &mut pInfo as *mut *mut sqlite3_stmt,
            0 as *mut *mut libc::c_char,
            b"PRAGMA index_xInfo=%Q\0" as *const u8 as *const libc::c_char,
            zIdx,
        );
        while rc == 0 as libc::c_int && sqlite3_step(pInfo) == 100 as libc::c_int {
            let mut iIdx: libc::c_int = sqlite3_column_int(pInfo, 0 as libc::c_int);
            let mut iCol: libc::c_int = sqlite3_column_int(pInfo, 1 as libc::c_int);
            let mut zColl: *const libc::c_char = sqlite3_column_text(
                pInfo,
                4 as libc::c_int,
            ) as *const libc::c_char;
            if iIdx < nEq {
                pIter = pEq;
                while !pIter.is_null() {
                    if !((*pIter).bFlag != 0) {
                        if !((*pIter).iCol != iCol) {
                            if !(sqlite3_stricmp((*pIter).zColl, zColl) != 0) {
                                (*pIter).bFlag = 1 as libc::c_int;
                                break;
                            }
                        }
                    }
                    pIter = (*pIter).pLink;
                }
                if !pIter.is_null() {
                    continue;
                }
                bMatch = 0 as libc::c_int;
                break;
            } else {
                if pT.is_null() {
                    continue;
                }
                if (*pT).iCol != iCol || sqlite3_stricmp((*pT).zColl, zColl) != 0 {
                    bMatch = 0 as libc::c_int;
                    break;
                } else {
                    pT = (*pT).pLink;
                }
            }
        }
        idxFinalize(&mut rc, pInfo);
        if rc == 0 as libc::c_int && bMatch != 0 {
            sqlite3_finalize(pIdxList);
            return 1 as libc::c_int;
        }
    }
    idxFinalize(&mut rc, pIdxList);
    *pRc = rc;
    return 0 as libc::c_int;
}
unsafe extern "C" fn countNonzeros(
    mut pCount: *mut libc::c_void,
    mut nc: libc::c_int,
    mut azResults: *mut *mut libc::c_char,
    mut azColumns: *mut *mut libc::c_char,
) -> libc::c_int {
    if nc > 0 as libc::c_int
        && (*(*azResults.offset(0 as libc::c_int as isize))
            .offset(0 as libc::c_int as isize) as libc::c_int != '0' as i32
            || *(*azResults.offset(0 as libc::c_int as isize))
                .offset(1 as libc::c_int as isize) as libc::c_int != 0 as libc::c_int)
    {
        *(pCount as *mut libc::c_int) += 1 as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn idxCreateFromCons(
    mut p: *mut sqlite3expert,
    mut pScan: *mut IdxScan,
    mut pEq: *mut IdxConstraint,
    mut pTail: *mut IdxConstraint,
) -> libc::c_int {
    let mut dbm: *mut sqlite3 = (*p).dbm;
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (!pEq.is_null() || !pTail.is_null())
        && 0 as libc::c_int == idxFindCompatible(&mut rc, dbm, pScan, pEq, pTail)
    {
        let mut pTab: *mut IdxTable = (*pScan).pTab;
        let mut zCols: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut zIdx: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut pCons: *mut IdxConstraint = 0 as *mut IdxConstraint;
        let mut h: libc::c_uint = 0 as libc::c_int as libc::c_uint;
        let mut zFmt: *const libc::c_char = 0 as *const libc::c_char;
        pCons = pEq;
        while !pCons.is_null() {
            zCols = idxAppendColDefn(&mut rc, zCols, pTab, pCons);
            pCons = (*pCons).pLink;
        }
        pCons = pTail;
        while !pCons.is_null() {
            zCols = idxAppendColDefn(&mut rc, zCols, pTab, pCons);
            pCons = (*pCons).pLink;
        }
        if rc == 0 as libc::c_int {
            let mut zTable: *const libc::c_char = (*(*pScan).pTab).zName;
            let mut quoteTable: libc::c_int = idxIdentifierRequiresQuotes(zTable);
            let mut zName: *mut libc::c_char = 0 as *mut libc::c_char;
            let mut collisions: libc::c_int = 0 as libc::c_int;
            loop {
                let mut i: libc::c_int = 0;
                let mut zFind: *mut libc::c_char = 0 as *mut libc::c_char;
                i = 0 as libc::c_int;
                while *zCols.offset(i as isize) != 0 {
                    h = h
                        .wrapping_add(
                            (h << 3 as libc::c_int)
                                .wrapping_add(*zCols.offset(i as isize) as libc::c_uint),
                        );
                    i += 1;
                }
                sqlite3_free(zName as *mut libc::c_void);
                zName = sqlite3_mprintf(
                    b"%s_idx_%08x\0" as *const u8 as *const libc::c_char,
                    zTable,
                    h,
                );
                if zName.is_null() {
                    break;
                }
                zFmt = b"SELECT count(*) FROM sqlite_schema WHERE name=%Q AND type in ('index','table','view')\0"
                    as *const u8 as *const libc::c_char;
                zFind = sqlite3_mprintf(zFmt, zName);
                i = 0 as libc::c_int;
                rc = sqlite3_exec(
                    dbm,
                    zFind,
                    Some(
                        countNonzeros
                            as unsafe extern "C" fn(
                                *mut libc::c_void,
                                libc::c_int,
                                *mut *mut libc::c_char,
                                *mut *mut libc::c_char,
                            ) -> libc::c_int,
                    ),
                    &mut i as *mut libc::c_int as *mut libc::c_void,
                    0 as *mut *mut libc::c_char,
                );
                sqlite3_free(zFind as *mut libc::c_void);
                if i == 0 as libc::c_int {
                    collisions = 0 as libc::c_int;
                    break;
                } else {
                    collisions += 1;
                    if !(collisions < 50 as libc::c_int && !zName.is_null()) {
                        break;
                    }
                }
            }
            if collisions != 0 {
                rc = 5 as libc::c_int | (3 as libc::c_int) << 8 as libc::c_int;
            } else if zName.is_null() {
                rc = 7 as libc::c_int;
            } else {
                if quoteTable != 0 {
                    zFmt = b"CREATE INDEX \"%w\" ON \"%w\"(%s)\0" as *const u8
                        as *const libc::c_char;
                } else {
                    zFmt = b"CREATE INDEX %s ON %s(%s)\0" as *const u8
                        as *const libc::c_char;
                }
                zIdx = sqlite3_mprintf(zFmt, zName, zTable, zCols);
                if zIdx.is_null() {
                    rc = 7 as libc::c_int;
                } else {
                    rc = sqlite3_exec(
                        dbm,
                        zIdx,
                        None,
                        0 as *mut libc::c_void,
                        (*p).pzErrmsg,
                    );
                    if rc != 0 as libc::c_int {
                        rc = 5 as libc::c_int | (3 as libc::c_int) << 8 as libc::c_int;
                    } else {
                        idxHashAdd(&mut rc, &mut (*p).hIdx, zName, zIdx);
                    }
                }
                sqlite3_free(zName as *mut libc::c_void);
                sqlite3_free(zIdx as *mut libc::c_void);
            }
        }
        sqlite3_free(zCols as *mut libc::c_void);
    }
    return rc;
}
unsafe extern "C" fn idxFindConstraint(
    mut pList: *mut IdxConstraint,
    mut p: *mut IdxConstraint,
) -> libc::c_int {
    let mut pCmp: *mut IdxConstraint = 0 as *mut IdxConstraint;
    pCmp = pList;
    while !pCmp.is_null() {
        if (*p).iCol == (*pCmp).iCol {
            return 1 as libc::c_int;
        }
        pCmp = (*pCmp).pLink;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn idxCreateFromWhere(
    mut p: *mut sqlite3expert,
    mut pScan: *mut IdxScan,
    mut pTail: *mut IdxConstraint,
) -> libc::c_int {
    let mut p1: *mut IdxConstraint = 0 as *mut IdxConstraint;
    let mut pCon: *mut IdxConstraint = 0 as *mut IdxConstraint;
    let mut rc: libc::c_int = 0;
    pCon = (*pScan).pEq;
    while !pCon.is_null() {
        if idxFindConstraint(p1, pCon) == 0 && idxFindConstraint(pTail, pCon) == 0 {
            let ref mut fresh183 = (*pCon).pLink;
            *fresh183 = p1;
            p1 = pCon;
        }
        pCon = (*pCon).pNext;
    }
    rc = idxCreateFromCons(p, pScan, p1, pTail);
    if pTail.is_null() {
        pCon = (*pScan).pRange;
        while rc == 0 as libc::c_int && !pCon.is_null() {
            if idxFindConstraint(p1, pCon) == 0 && idxFindConstraint(pTail, pCon) == 0 {
                rc = idxCreateFromCons(p, pScan, p1, pCon);
            }
            pCon = (*pCon).pNext;
        }
    }
    return rc;
}
unsafe extern "C" fn idxCreateCandidates(mut p: *mut sqlite3expert) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut pIter: *mut IdxScan = 0 as *mut IdxScan;
    pIter = (*p).pScan;
    while !pIter.is_null() && rc == 0 as libc::c_int {
        rc = idxCreateFromWhere(p, pIter, 0 as *mut IdxConstraint);
        if rc == 0 as libc::c_int && !((*pIter).pOrder).is_null() {
            rc = idxCreateFromWhere(p, pIter, (*pIter).pOrder);
        }
        pIter = (*pIter).pNextScan;
    }
    return rc;
}
unsafe extern "C" fn idxConstraintFree(mut pConstraint: *mut IdxConstraint) {
    let mut pNext: *mut IdxConstraint = 0 as *mut IdxConstraint;
    let mut p: *mut IdxConstraint = 0 as *mut IdxConstraint;
    p = pConstraint;
    while !p.is_null() {
        pNext = (*p).pNext;
        sqlite3_free(p as *mut libc::c_void);
        p = pNext;
    }
}
unsafe extern "C" fn idxScanFree(mut pScan: *mut IdxScan, mut pLast: *mut IdxScan) {
    let mut p: *mut IdxScan = 0 as *mut IdxScan;
    let mut pNext: *mut IdxScan = 0 as *mut IdxScan;
    p = pScan;
    while p != pLast {
        pNext = (*p).pNextScan;
        idxConstraintFree((*p).pOrder);
        idxConstraintFree((*p).pEq);
        idxConstraintFree((*p).pRange);
        sqlite3_free(p as *mut libc::c_void);
        p = pNext;
    }
}
unsafe extern "C" fn idxStatementFree(
    mut pStatement: *mut IdxStatement,
    mut pLast: *mut IdxStatement,
) {
    let mut p: *mut IdxStatement = 0 as *mut IdxStatement;
    let mut pNext: *mut IdxStatement = 0 as *mut IdxStatement;
    p = pStatement;
    while p != pLast {
        pNext = (*p).pNext;
        sqlite3_free((*p).zEQP as *mut libc::c_void);
        sqlite3_free((*p).zIdx as *mut libc::c_void);
        sqlite3_free(p as *mut libc::c_void);
        p = pNext;
    }
}
unsafe extern "C" fn idxTableFree(mut pTab: *mut IdxTable) {
    let mut pIter: *mut IdxTable = 0 as *mut IdxTable;
    let mut pNext: *mut IdxTable = 0 as *mut IdxTable;
    pIter = pTab;
    while !pIter.is_null() {
        pNext = (*pIter).pNext;
        sqlite3_free(pIter as *mut libc::c_void);
        pIter = pNext;
    }
}
unsafe extern "C" fn idxWriteFree(mut pTab: *mut IdxWrite) {
    let mut pIter: *mut IdxWrite = 0 as *mut IdxWrite;
    let mut pNext: *mut IdxWrite = 0 as *mut IdxWrite;
    pIter = pTab;
    while !pIter.is_null() {
        pNext = (*pIter).pNext;
        sqlite3_free(pIter as *mut libc::c_void);
        pIter = pNext;
    }
}
unsafe extern "C" fn idxFindIndexes(
    mut p: *mut sqlite3expert,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut pStmt: *mut IdxStatement = 0 as *mut IdxStatement;
    let mut dbm: *mut sqlite3 = (*p).dbm;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut hIdx: IdxHash = IdxHash {
        pFirst: 0 as *mut IdxHashEntry,
        aHash: [0 as *mut IdxHashEntry; 1023],
    };
    idxHashInit(&mut hIdx);
    pStmt = (*p).pStatement;
    's_19: while rc == 0 as libc::c_int && !pStmt.is_null() {
        let mut pEntry: *mut IdxHashEntry = 0 as *mut IdxHashEntry;
        let mut pExplain: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        idxHashClear(&mut hIdx);
        rc = idxPrintfPrepareStmt(
            dbm,
            &mut pExplain as *mut *mut sqlite3_stmt,
            pzErr,
            b"EXPLAIN QUERY PLAN %s\0" as *const u8 as *const libc::c_char,
            (*pStmt).zSql,
        );
        while rc == 0 as libc::c_int && sqlite3_step(pExplain) == 100 as libc::c_int {
            let mut zDetail: *const libc::c_char = sqlite3_column_text(
                pExplain,
                3 as libc::c_int,
            ) as *const libc::c_char;
            let mut nDetail: libc::c_int = 0;
            let mut i: libc::c_int = 0;
            if zDetail.is_null() {
                continue;
            }
            nDetail = strlen(zDetail) as libc::c_int;
            i = 0 as libc::c_int;
            while i < nDetail {
                let mut zIdx: *const libc::c_char = 0 as *const libc::c_char;
                if (i + 13 as libc::c_int) < nDetail
                    && memcmp(
                        &*zDetail.offset(i as isize) as *const libc::c_char
                            as *const libc::c_void,
                        b" USING INDEX \0" as *const u8 as *const libc::c_char
                            as *const libc::c_void,
                        13 as libc::c_int as libc::c_ulong,
                    ) == 0 as libc::c_int
                {
                    zIdx = &*zDetail.offset((i + 13 as libc::c_int) as isize)
                        as *const libc::c_char;
                } else if (i + 22 as libc::c_int) < nDetail
                    && memcmp(
                        &*zDetail.offset(i as isize) as *const libc::c_char
                            as *const libc::c_void,
                        b" USING COVERING INDEX \0" as *const u8 as *const libc::c_char
                            as *const libc::c_void,
                        22 as libc::c_int as libc::c_ulong,
                    ) == 0 as libc::c_int
                {
                    zIdx = &*zDetail.offset((i + 22 as libc::c_int) as isize)
                        as *const libc::c_char;
                }
                if !zIdx.is_null() {
                    let mut zSql: *const libc::c_char = 0 as *const libc::c_char;
                    let mut nIdx: libc::c_int = 0 as libc::c_int;
                    while *zIdx.offset(nIdx as isize) as libc::c_int != '\0' as i32
                        && (*zIdx.offset(nIdx as isize) as libc::c_int != ' ' as i32
                            || *zIdx.offset((nIdx + 1 as libc::c_int) as isize)
                                as libc::c_int != '(' as i32)
                    {
                        nIdx += 1;
                    }
                    zSql = idxHashSearch(&mut (*p).hIdx, zIdx, nIdx);
                    if zSql.is_null() {
                        break;
                    }
                    idxHashAdd(&mut rc, &mut hIdx, zSql, 0 as *const libc::c_char);
                    if rc != 0 {
                        break 's_19;
                    } else {
                        break;
                    }
                } else {
                    i += 1;
                }
            }
            if *zDetail.offset(0 as libc::c_int as isize) as libc::c_int != '-' as i32 {
                let ref mut fresh184 = (*pStmt).zEQP;
                *fresh184 = idxAppendText(
                    &mut rc as *mut libc::c_int,
                    (*pStmt).zEQP,
                    b"%s\n\0" as *const u8 as *const libc::c_char,
                    zDetail,
                );
            }
        }
        pEntry = hIdx.pFirst;
        while !pEntry.is_null() {
            let ref mut fresh185 = (*pStmt).zIdx;
            *fresh185 = idxAppendText(
                &mut rc as *mut libc::c_int,
                (*pStmt).zIdx,
                b"%s;\n\0" as *const u8 as *const libc::c_char,
                (*pEntry).zKey,
            );
            pEntry = (*pEntry).pNext;
        }
        idxFinalize(&mut rc, pExplain);
        pStmt = (*pStmt).pNext;
    }
    idxHashClear(&mut hIdx);
    return rc;
}
unsafe extern "C" fn idxAuthCallback(
    mut pCtx: *mut libc::c_void,
    mut eOp: libc::c_int,
    mut z3: *const libc::c_char,
    mut z4: *const libc::c_char,
    mut zDb: *const libc::c_char,
    mut zTrigger: *const libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if eOp == 18 as libc::c_int || eOp == 23 as libc::c_int || eOp == 9 as libc::c_int {
        if sqlite3_stricmp(zDb, b"main\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            let mut p: *mut sqlite3expert = pCtx as *mut sqlite3expert;
            let mut pTab: *mut IdxTable = 0 as *mut IdxTable;
            pTab = (*p).pTable;
            while !pTab.is_null() {
                if 0 as libc::c_int == sqlite3_stricmp(z3, (*pTab).zName) {
                    break;
                }
                pTab = (*pTab).pNext;
            }
            if !pTab.is_null() {
                let mut pWrite: *mut IdxWrite = 0 as *mut IdxWrite;
                pWrite = (*p).pWrite;
                while !pWrite.is_null() {
                    if (*pWrite).pTab == pTab && (*pWrite).eOp == eOp {
                        break;
                    }
                    pWrite = (*pWrite).pNext;
                }
                if pWrite.is_null() {
                    pWrite = idxMalloc(
                        &mut rc,
                        ::std::mem::size_of::<IdxWrite>() as libc::c_ulong as libc::c_int,
                    ) as *mut IdxWrite;
                    if rc == 0 as libc::c_int {
                        let ref mut fresh186 = (*pWrite).pTab;
                        *fresh186 = pTab;
                        (*pWrite).eOp = eOp;
                        let ref mut fresh187 = (*pWrite).pNext;
                        *fresh187 = (*p).pWrite;
                        let ref mut fresh188 = (*p).pWrite;
                        *fresh188 = pWrite;
                    }
                }
            }
        }
    }
    return rc;
}
unsafe extern "C" fn idxProcessOneTrigger(
    mut p: *mut sqlite3expert,
    mut pWrite: *mut IdxWrite,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    static mut zInt: *const libc::c_char = b"t592690916721053953805701627921227776\0"
        as *const u8 as *const libc::c_char;
    static mut zDrop: *const libc::c_char = b"DROP TABLE t592690916721053953805701627921227776\0"
        as *const u8 as *const libc::c_char;
    let mut pTab: *mut IdxTable = (*pWrite).pTab;
    let mut zTab: *const libc::c_char = (*pTab).zName;
    let mut zSql: *const libc::c_char = b"SELECT 'CREATE TEMP' || substr(sql, 7) FROM sqlite_schema WHERE tbl_name = %Q AND type IN ('table', 'trigger') ORDER BY type;\0"
        as *const u8 as *const libc::c_char;
    let mut pSelect: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut zWrite: *mut libc::c_char = 0 as *mut libc::c_char;
    rc = idxPrintfPrepareStmt(
        (*p).db,
        &mut pSelect as *mut *mut sqlite3_stmt,
        pzErr,
        zSql,
        zTab,
        zTab,
    );
    while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pSelect) {
        let mut zCreate: *const libc::c_char = sqlite3_column_text(
            pSelect,
            0 as libc::c_int,
        ) as *const libc::c_char;
        if zCreate.is_null() {
            continue;
        }
        rc = sqlite3_exec((*p).dbv, zCreate, None, 0 as *mut libc::c_void, pzErr);
    }
    idxFinalize(&mut rc, pSelect);
    if rc == 0 as libc::c_int {
        let mut z: *mut libc::c_char = sqlite3_mprintf(
            b"ALTER TABLE temp.%Q RENAME TO %Q\0" as *const u8 as *const libc::c_char,
            zTab,
            zInt,
        );
        if z.is_null() {
            rc = 7 as libc::c_int;
        } else {
            rc = sqlite3_exec((*p).dbv, z, None, 0 as *mut libc::c_void, pzErr);
            sqlite3_free(z as *mut libc::c_void);
        }
    }
    match (*pWrite).eOp {
        18 => {
            let mut i: libc::c_int = 0;
            zWrite = idxAppendText(
                &mut rc as *mut libc::c_int,
                zWrite,
                b"INSERT INTO %Q VALUES(\0" as *const u8 as *const libc::c_char,
                zInt,
            );
            i = 0 as libc::c_int;
            while i < (*pTab).nCol {
                zWrite = idxAppendText(
                    &mut rc as *mut libc::c_int,
                    zWrite,
                    b"%s?\0" as *const u8 as *const libc::c_char,
                    if i == 0 as libc::c_int {
                        b"\0" as *const u8 as *const libc::c_char
                    } else {
                        b", \0" as *const u8 as *const libc::c_char
                    },
                );
                i += 1;
            }
            zWrite = idxAppendText(
                &mut rc as *mut libc::c_int,
                zWrite,
                b")\0" as *const u8 as *const libc::c_char,
            );
        }
        23 => {
            let mut i_0: libc::c_int = 0;
            zWrite = idxAppendText(
                &mut rc as *mut libc::c_int,
                zWrite,
                b"UPDATE %Q SET \0" as *const u8 as *const libc::c_char,
                zInt,
            );
            i_0 = 0 as libc::c_int;
            while i_0 < (*pTab).nCol {
                zWrite = idxAppendText(
                    &mut rc as *mut libc::c_int,
                    zWrite,
                    b"%s%Q=?\0" as *const u8 as *const libc::c_char,
                    if i_0 == 0 as libc::c_int {
                        b"\0" as *const u8 as *const libc::c_char
                    } else {
                        b", \0" as *const u8 as *const libc::c_char
                    },
                    (*((*pTab).aCol).offset(i_0 as isize)).zName,
                );
                i_0 += 1;
            }
        }
        _ => {
            if rc == 0 as libc::c_int {
                zWrite = sqlite3_mprintf(
                    b"DELETE FROM %Q\0" as *const u8 as *const libc::c_char,
                    zInt,
                );
                if zWrite.is_null() {
                    rc = 7 as libc::c_int;
                }
            }
        }
    }
    if rc == 0 as libc::c_int {
        let mut pX: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        rc = sqlite3_prepare_v2(
            (*p).dbv,
            zWrite,
            -(1 as libc::c_int),
            &mut pX,
            0 as *mut *const libc::c_char,
        );
        idxFinalize(&mut rc, pX);
        if rc != 0 as libc::c_int {
            idxDatabaseError((*p).dbv, pzErr);
        }
    }
    sqlite3_free(zWrite as *mut libc::c_void);
    if rc == 0 as libc::c_int {
        rc = sqlite3_exec((*p).dbv, zDrop, None, 0 as *mut libc::c_void, pzErr);
    }
    return rc;
}
unsafe extern "C" fn idxProcessTriggers(
    mut p: *mut sqlite3expert,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut pEnd: *mut IdxWrite = 0 as *mut IdxWrite;
    let mut pFirst: *mut IdxWrite = (*p).pWrite;
    while rc == 0 as libc::c_int && pFirst != pEnd {
        let mut pIter: *mut IdxWrite = 0 as *mut IdxWrite;
        pIter = pFirst;
        while rc == 0 as libc::c_int && pIter != pEnd {
            rc = idxProcessOneTrigger(p, pIter, pzErr);
            pIter = (*pIter).pNext;
        }
        pEnd = pFirst;
        pFirst = (*p).pWrite;
    }
    return rc;
}
unsafe extern "C" fn idxCreateVtabSchema(
    mut p: *mut sqlite3expert,
    mut pzErrmsg: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = idxRegisterVtab(p);
    let mut pSchema: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    rc = idxPrepareStmt(
        (*p).db,
        &mut pSchema,
        pzErrmsg,
        b"SELECT type, name, sql, 1 FROM sqlite_schema WHERE type IN ('table','view') AND name NOT LIKE 'sqlite_%%'  UNION ALL SELECT type, name, sql, 2 FROM sqlite_schema WHERE type = 'trigger'  AND tbl_name IN(SELECT name FROM sqlite_schema WHERE type = 'view') ORDER BY 4, 1\0"
            as *const u8 as *const libc::c_char,
    );
    while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pSchema) {
        let mut zType: *const libc::c_char = sqlite3_column_text(
            pSchema,
            0 as libc::c_int,
        ) as *const libc::c_char;
        let mut zName: *const libc::c_char = sqlite3_column_text(
            pSchema,
            1 as libc::c_int,
        ) as *const libc::c_char;
        let mut zSql: *const libc::c_char = sqlite3_column_text(
            pSchema,
            2 as libc::c_int,
        ) as *const libc::c_char;
        if zType.is_null() || zName.is_null() {
            continue;
        }
        if *zType.offset(0 as libc::c_int as isize) as libc::c_int == 'v' as i32
            || *zType.offset(1 as libc::c_int as isize) as libc::c_int == 'r' as i32
        {
            if !zSql.is_null() {
                rc = sqlite3_exec(
                    (*p).dbv,
                    zSql,
                    None,
                    0 as *mut libc::c_void,
                    pzErrmsg,
                );
            }
        } else {
            let mut pTab: *mut IdxTable = 0 as *mut IdxTable;
            rc = idxGetTableInfo((*p).db, zName, &mut pTab, pzErrmsg);
            if rc == 0 as libc::c_int {
                let mut i: libc::c_int = 0;
                let mut zInner: *mut libc::c_char = 0 as *mut libc::c_char;
                let mut zOuter: *mut libc::c_char = 0 as *mut libc::c_char;
                let ref mut fresh189 = (*pTab).pNext;
                *fresh189 = (*p).pTable;
                let ref mut fresh190 = (*p).pTable;
                *fresh190 = pTab;
                zInner = idxAppendText(
                    &mut rc as *mut libc::c_int,
                    0 as *mut libc::c_char,
                    b"CREATE TABLE x(\0" as *const u8 as *const libc::c_char,
                );
                i = 0 as libc::c_int;
                while i < (*pTab).nCol {
                    zInner = idxAppendText(
                        &mut rc as *mut libc::c_int,
                        zInner,
                        b"%s%Q COLLATE %s\0" as *const u8 as *const libc::c_char,
                        if i == 0 as libc::c_int {
                            b"\0" as *const u8 as *const libc::c_char
                        } else {
                            b", \0" as *const u8 as *const libc::c_char
                        },
                        (*((*pTab).aCol).offset(i as isize)).zName,
                        (*((*pTab).aCol).offset(i as isize)).zColl,
                    );
                    i += 1;
                }
                zInner = idxAppendText(
                    &mut rc as *mut libc::c_int,
                    zInner,
                    b")\0" as *const u8 as *const libc::c_char,
                );
                zOuter = idxAppendText(
                    &mut rc as *mut libc::c_int,
                    0 as *mut libc::c_char,
                    b"CREATE VIRTUAL TABLE %Q USING expert(%Q)\0" as *const u8
                        as *const libc::c_char,
                    zName,
                    zInner,
                );
                if rc == 0 as libc::c_int {
                    rc = sqlite3_exec(
                        (*p).dbv,
                        zOuter,
                        None,
                        0 as *mut libc::c_void,
                        pzErrmsg,
                    );
                }
                sqlite3_free(zInner as *mut libc::c_void);
                sqlite3_free(zOuter as *mut libc::c_void);
            }
        }
    }
    idxFinalize(&mut rc, pSchema);
    return rc;
}
unsafe extern "C" fn idxSampleFunc(
    mut pCtx: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut p: *mut IdxSampleCtx = sqlite3_user_data(pCtx) as *mut IdxSampleCtx;
    let mut bRet: libc::c_int = 0;
    if (*p).nRow == 0.0f64 {
        bRet = 1 as libc::c_int;
    } else {
        bRet = ((*p).nRet / (*p).nRow <= (*p).target) as libc::c_int;
        if bRet == 0 as libc::c_int {
            let mut rnd: libc::c_ushort = 0;
            sqlite3_randomness(
                2 as libc::c_int,
                &mut rnd as *mut libc::c_ushort as *mut libc::c_void,
            );
            bRet = (rnd as libc::c_int % 100 as libc::c_int <= (*p).iTarget)
                as libc::c_int;
        }
    }
    sqlite3_result_int(pCtx, bRet);
    (*p).nRow += 1.0f64;
    (*p).nRet += bRet as libc::c_double;
}
unsafe extern "C" fn idxRemFunc(
    mut pCtx: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut p: *mut IdxRemCtx = sqlite3_user_data(pCtx) as *mut IdxRemCtx;
    let mut pSlot: *mut IdxRemSlot = 0 as *mut IdxRemSlot;
    let mut iSlot: libc::c_int = 0;
    iSlot = sqlite3_value_int(*argv.offset(0 as libc::c_int as isize));
    pSlot = &mut *((*p).aSlot).as_mut_ptr().offset(iSlot as isize) as *mut IdxRemSlot;
    match (*pSlot).eType {
        1 => {
            sqlite3_result_int64(pCtx, (*pSlot).iVal);
        }
        2 => {
            sqlite3_result_double(pCtx, (*pSlot).rVal);
        }
        4 => {
            sqlite3_result_blob(
                pCtx,
                (*pSlot).z as *const libc::c_void,
                (*pSlot).n,
                ::std::mem::transmute::<
                    libc::intptr_t,
                    sqlite3_destructor_type,
                >(-(1 as libc::c_int) as libc::intptr_t),
            );
        }
        3 => {
            sqlite3_result_text(
                pCtx,
                (*pSlot).z,
                (*pSlot).n,
                ::std::mem::transmute::<
                    libc::intptr_t,
                    sqlite3_destructor_type,
                >(-(1 as libc::c_int) as libc::intptr_t),
            );
        }
        5 | _ => {}
    }
    (*pSlot).eType = sqlite3_value_type(*argv.offset(1 as libc::c_int as isize));
    match (*pSlot).eType {
        1 => {
            (*pSlot).iVal = sqlite3_value_int64(*argv.offset(1 as libc::c_int as isize));
        }
        2 => {
            (*pSlot)
                .rVal = sqlite3_value_double(*argv.offset(1 as libc::c_int as isize));
        }
        4 | 3 => {
            let mut nByte: libc::c_int = sqlite3_value_bytes(
                *argv.offset(1 as libc::c_int as isize),
            );
            let mut pData: *const libc::c_void = 0 as *const libc::c_void;
            if nByte > (*pSlot).nByte {
                let mut zNew: *mut libc::c_char = sqlite3_realloc(
                    (*pSlot).z as *mut libc::c_void,
                    nByte * 2 as libc::c_int,
                ) as *mut libc::c_char;
                if zNew.is_null() {
                    sqlite3_result_error_nomem(pCtx);
                    return;
                }
                (*pSlot).nByte = nByte * 2 as libc::c_int;
                let ref mut fresh191 = (*pSlot).z;
                *fresh191 = zNew;
            }
            (*pSlot).n = nByte;
            if (*pSlot).eType == 4 as libc::c_int {
                pData = sqlite3_value_blob(*argv.offset(1 as libc::c_int as isize));
                if !pData.is_null() {
                    memcpy(
                        (*pSlot).z as *mut libc::c_void,
                        pData,
                        nByte as libc::c_ulong,
                    );
                }
            } else {
                pData = sqlite3_value_text(*argv.offset(1 as libc::c_int as isize))
                    as *const libc::c_void;
                memcpy((*pSlot).z as *mut libc::c_void, pData, nByte as libc::c_ulong);
            }
        }
        5 | _ => {}
    };
}
unsafe extern "C" fn idxLargestIndex(
    mut db: *mut sqlite3,
    mut pnMax: *mut libc::c_int,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut zMax: *const libc::c_char = b"SELECT max(i.seqno) FROM   sqlite_schema AS s,   pragma_index_list(s.name) AS l,   pragma_index_info(l.name) AS i WHERE s.type = 'table'\0"
        as *const u8 as *const libc::c_char;
    let mut pMax: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    *pnMax = 0 as libc::c_int;
    rc = idxPrepareStmt(db, &mut pMax, pzErr, zMax);
    if rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pMax) {
        *pnMax = sqlite3_column_int(pMax, 0 as libc::c_int) + 1 as libc::c_int;
    }
    idxFinalize(&mut rc, pMax);
    return rc;
}
unsafe extern "C" fn idxPopulateOneStat1(
    mut p: *mut sqlite3expert,
    mut pIndexXInfo: *mut sqlite3_stmt,
    mut pWriteStat: *mut sqlite3_stmt,
    mut zTab: *const libc::c_char,
    mut zIdx: *const libc::c_char,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut zCols: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zOrder: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zQuery: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut nCol: libc::c_int = 0 as libc::c_int;
    let mut i: libc::c_int = 0;
    let mut pQuery: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut aStat: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut rc: libc::c_int = 0 as libc::c_int;
    sqlite3_bind_text(pIndexXInfo, 1 as libc::c_int, zIdx, -(1 as libc::c_int), None);
    while 0 as libc::c_int == rc && 100 as libc::c_int == sqlite3_step(pIndexXInfo) {
        let mut zComma: *const libc::c_char = if zCols.is_null() {
            b"\0" as *const u8 as *const libc::c_char
        } else {
            b", \0" as *const u8 as *const libc::c_char
        };
        let mut zName: *const libc::c_char = sqlite3_column_text(
            pIndexXInfo,
            0 as libc::c_int,
        ) as *const libc::c_char;
        let mut zColl: *const libc::c_char = sqlite3_column_text(
            pIndexXInfo,
            1 as libc::c_int,
        ) as *const libc::c_char;
        zCols = idxAppendText(
            &mut rc as *mut libc::c_int,
            zCols,
            b"%sx.%Q IS rem(%d, x.%Q) COLLATE %s\0" as *const u8 as *const libc::c_char,
            zComma,
            zName,
            nCol,
            zName,
            zColl,
        );
        nCol += 1;
        zOrder = idxAppendText(
            &mut rc as *mut libc::c_int,
            zOrder,
            b"%s%d\0" as *const u8 as *const libc::c_char,
            zComma,
            nCol,
        );
    }
    sqlite3_reset(pIndexXInfo);
    if rc == 0 as libc::c_int {
        if (*p).iSample == 100 as libc::c_int {
            zQuery = sqlite3_mprintf(
                b"SELECT %s FROM %Q x ORDER BY %s\0" as *const u8 as *const libc::c_char,
                zCols,
                zTab,
                zOrder,
            );
        } else {
            zQuery = sqlite3_mprintf(
                b"SELECT %s FROM temp.t592690916721053953805701627921227776 x ORDER BY %s\0"
                    as *const u8 as *const libc::c_char,
                zCols,
                zOrder,
            );
        }
    }
    sqlite3_free(zCols as *mut libc::c_void);
    sqlite3_free(zOrder as *mut libc::c_void);
    if rc == 0 as libc::c_int {
        let mut dbrem: *mut sqlite3 = if (*p).iSample == 100 as libc::c_int {
            (*p).db
        } else {
            (*p).dbv
        };
        rc = idxPrepareStmt(dbrem, &mut pQuery, pzErr, zQuery);
    }
    sqlite3_free(zQuery as *mut libc::c_void);
    if rc == 0 as libc::c_int {
        aStat = idxMalloc(
            &mut rc,
            (::std::mem::size_of::<libc::c_int>() as libc::c_ulong)
                .wrapping_mul((nCol + 1 as libc::c_int) as libc::c_ulong) as libc::c_int,
        ) as *mut libc::c_int;
    }
    if rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pQuery) {
        let mut pEntry: *mut IdxHashEntry = 0 as *mut IdxHashEntry;
        let mut zStat: *mut libc::c_char = 0 as *mut libc::c_char;
        i = 0 as libc::c_int;
        while i <= nCol {
            *aStat.offset(i as isize) = 1 as libc::c_int;
            i += 1;
        }
        while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pQuery) {
            let ref mut fresh192 = *aStat.offset(0 as libc::c_int as isize);
            *fresh192 += 1;
            i = 0 as libc::c_int;
            while i < nCol {
                if sqlite3_column_int(pQuery, i) == 0 as libc::c_int {
                    break;
                }
                i += 1;
            }
            while i < nCol {
                let ref mut fresh193 = *aStat.offset((i + 1 as libc::c_int) as isize);
                *fresh193 += 1;
                i += 1;
            }
        }
        if rc == 0 as libc::c_int {
            let mut s0: libc::c_int = *aStat.offset(0 as libc::c_int as isize);
            zStat = sqlite3_mprintf(b"%d\0" as *const u8 as *const libc::c_char, s0);
            if zStat.is_null() {
                rc = 7 as libc::c_int;
            }
            i = 1 as libc::c_int;
            while rc == 0 as libc::c_int && i <= nCol {
                zStat = idxAppendText(
                    &mut rc as *mut libc::c_int,
                    zStat,
                    b" %d\0" as *const u8 as *const libc::c_char,
                    (s0 + *aStat.offset(i as isize) / 2 as libc::c_int)
                        / *aStat.offset(i as isize),
                );
                i += 1;
            }
        }
        if rc == 0 as libc::c_int {
            sqlite3_bind_text(
                pWriteStat,
                1 as libc::c_int,
                zTab,
                -(1 as libc::c_int),
                None,
            );
            sqlite3_bind_text(
                pWriteStat,
                2 as libc::c_int,
                zIdx,
                -(1 as libc::c_int),
                None,
            );
            sqlite3_bind_text(
                pWriteStat,
                3 as libc::c_int,
                zStat,
                -(1 as libc::c_int),
                None,
            );
            sqlite3_step(pWriteStat);
            rc = sqlite3_reset(pWriteStat);
        }
        pEntry = idxHashFind(&mut (*p).hIdx, zIdx, strlen(zIdx) as libc::c_int);
        if !pEntry.is_null() {
            let ref mut fresh194 = (*pEntry).zVal2;
            *fresh194 = zStat;
        } else {
            sqlite3_free(zStat as *mut libc::c_void);
        }
    }
    sqlite3_free(aStat as *mut libc::c_void);
    idxFinalize(&mut rc, pQuery);
    return rc;
}
unsafe extern "C" fn idxBuildSampleTable(
    mut p: *mut sqlite3expert,
    mut zTab: *const libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
    rc = sqlite3_exec(
        (*p).dbv,
        b"DROP TABLE IF EXISTS temp.t592690916721053953805701627921227776\0" as *const u8
            as *const libc::c_char,
        None,
        0 as *mut libc::c_void,
        0 as *mut *mut libc::c_char,
    );
    if rc != 0 as libc::c_int {
        return rc;
    }
    zSql = sqlite3_mprintf(
        b"CREATE TABLE temp.t592690916721053953805701627921227776 AS SELECT * FROM %Q\0"
            as *const u8 as *const libc::c_char,
        zTab,
    );
    if zSql.is_null() {
        return 7 as libc::c_int;
    }
    rc = sqlite3_exec(
        (*p).dbv,
        zSql,
        None,
        0 as *mut libc::c_void,
        0 as *mut *mut libc::c_char,
    );
    sqlite3_free(zSql as *mut libc::c_void);
    return rc;
}
unsafe extern "C" fn idxPopulateStat1(
    mut p: *mut sqlite3expert,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut nMax: libc::c_int = 0 as libc::c_int;
    let mut pCtx: *mut IdxRemCtx = 0 as *mut IdxRemCtx;
    let mut samplectx: IdxSampleCtx = IdxSampleCtx {
        iTarget: 0,
        target: 0.,
        nRow: 0.,
        nRet: 0.,
    };
    let mut i: libc::c_int = 0;
    let mut iPrev: i64_0 = -(100000 as libc::c_int) as i64_0;
    let mut pAllIndex: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut pIndexXInfo: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut pWrite: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut zAllIndex: *const libc::c_char = b"SELECT s.rowid, s.name, l.name FROM   sqlite_schema AS s,   pragma_index_list(s.name) AS l WHERE s.type = 'table'\0"
        as *const u8 as *const libc::c_char;
    let mut zIndexXInfo: *const libc::c_char = b"SELECT name, coll FROM pragma_index_xinfo(?) WHERE key\0"
        as *const u8 as *const libc::c_char;
    let mut zWrite: *const libc::c_char = b"INSERT INTO sqlite_stat1 VALUES(?, ?, ?)\0"
        as *const u8 as *const libc::c_char;
    if (*p).iSample == 0 as libc::c_int {
        return 0 as libc::c_int;
    }
    rc = idxLargestIndex((*p).dbm, &mut nMax, pzErr);
    if nMax <= 0 as libc::c_int || rc != 0 as libc::c_int {
        return rc;
    }
    rc = sqlite3_exec(
        (*p).dbm,
        b"ANALYZE; PRAGMA writable_schema=1\0" as *const u8 as *const libc::c_char,
        None,
        0 as *mut libc::c_void,
        0 as *mut *mut libc::c_char,
    );
    if rc == 0 as libc::c_int {
        let mut nByte: libc::c_int = (::std::mem::size_of::<IdxRemCtx>()
            as libc::c_ulong)
            .wrapping_add(
                (::std::mem::size_of::<IdxRemSlot>() as libc::c_ulong)
                    .wrapping_mul(nMax as libc::c_ulong),
            ) as libc::c_int;
        pCtx = idxMalloc(&mut rc, nByte) as *mut IdxRemCtx;
    }
    if rc == 0 as libc::c_int {
        let mut dbrem: *mut sqlite3 = if (*p).iSample == 100 as libc::c_int {
            (*p).db
        } else {
            (*p).dbv
        };
        rc = sqlite3_create_function(
            dbrem,
            b"rem\0" as *const u8 as *const libc::c_char,
            2 as libc::c_int,
            1 as libc::c_int,
            pCtx as *mut libc::c_void,
            Some(
                idxRemFunc
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
    }
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_function(
            (*p).db,
            b"sample\0" as *const u8 as *const libc::c_char,
            0 as libc::c_int,
            1 as libc::c_int,
            &mut samplectx as *mut IdxSampleCtx as *mut libc::c_void,
            Some(
                idxSampleFunc
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
    }
    if rc == 0 as libc::c_int {
        (*pCtx).nSlot = nMax + 1 as libc::c_int;
        rc = idxPrepareStmt((*p).dbm, &mut pAllIndex, pzErr, zAllIndex);
    }
    if rc == 0 as libc::c_int {
        rc = idxPrepareStmt((*p).dbm, &mut pIndexXInfo, pzErr, zIndexXInfo);
    }
    if rc == 0 as libc::c_int {
        rc = idxPrepareStmt((*p).dbm, &mut pWrite, pzErr, zWrite);
    }
    while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pAllIndex) {
        let mut iRowid: i64_0 = sqlite3_column_int64(pAllIndex, 0 as libc::c_int);
        let mut zTab: *const libc::c_char = sqlite3_column_text(
            pAllIndex,
            1 as libc::c_int,
        ) as *const libc::c_char;
        let mut zIdx: *const libc::c_char = sqlite3_column_text(
            pAllIndex,
            2 as libc::c_int,
        ) as *const libc::c_char;
        if zTab.is_null() || zIdx.is_null() {
            continue;
        }
        if (*p).iSample < 100 as libc::c_int && iPrev != iRowid {
            samplectx.target = (*p).iSample as libc::c_double / 100.0f64;
            samplectx.iTarget = (*p).iSample;
            samplectx.nRow = 0.0f64;
            samplectx.nRet = 0.0f64;
            rc = idxBuildSampleTable(p, zTab);
            if rc != 0 as libc::c_int {
                break;
            }
        }
        rc = idxPopulateOneStat1(p, pIndexXInfo, pWrite, zTab, zIdx, pzErr);
        iPrev = iRowid;
    }
    if rc == 0 as libc::c_int && (*p).iSample < 100 as libc::c_int {
        rc = sqlite3_exec(
            (*p).dbv,
            b"DROP TABLE IF EXISTS temp.t592690916721053953805701627921227776\0"
                as *const u8 as *const libc::c_char,
            None,
            0 as *mut libc::c_void,
            0 as *mut *mut libc::c_char,
        );
    }
    idxFinalize(&mut rc, pAllIndex);
    idxFinalize(&mut rc, pIndexXInfo);
    idxFinalize(&mut rc, pWrite);
    if !pCtx.is_null() {
        i = 0 as libc::c_int;
        while i < (*pCtx).nSlot {
            sqlite3_free(
                (*((*pCtx).aSlot).as_mut_ptr().offset(i as isize)).z as *mut libc::c_void,
            );
            i += 1;
        }
        sqlite3_free(pCtx as *mut libc::c_void);
    }
    if rc == 0 as libc::c_int {
        rc = sqlite3_exec(
            (*p).dbm,
            b"ANALYZE sqlite_schema\0" as *const u8 as *const libc::c_char,
            None,
            0 as *mut libc::c_void,
            0 as *mut *mut libc::c_char,
        );
    }
    sqlite3_exec(
        (*p).db,
        b"DROP TABLE IF EXISTS temp.t592690916721053953805701627921227776\0" as *const u8
            as *const libc::c_char,
        None,
        0 as *mut libc::c_void,
        0 as *mut *mut libc::c_char,
    );
    return rc;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_expert_new(
    mut db: *mut sqlite3,
    mut pzErrmsg: *mut *mut libc::c_char,
) -> *mut sqlite3expert {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut pNew: *mut sqlite3expert = 0 as *mut sqlite3expert;
    pNew = idxMalloc(
        &mut rc,
        ::std::mem::size_of::<sqlite3expert>() as libc::c_ulong as libc::c_int,
    ) as *mut sqlite3expert;
    if rc == 0 as libc::c_int {
        let ref mut fresh195 = (*pNew).db;
        *fresh195 = db;
        (*pNew).iSample = 100 as libc::c_int;
        rc = sqlite3_open(
            b":memory:\0" as *const u8 as *const libc::c_char,
            &mut (*pNew).dbv,
        );
    }
    if rc == 0 as libc::c_int {
        rc = sqlite3_open(
            b":memory:\0" as *const u8 as *const libc::c_char,
            &mut (*pNew).dbm,
        );
        if rc == 0 as libc::c_int {
            sqlite3_db_config(
                (*pNew).dbm,
                1008 as libc::c_int,
                1 as libc::c_int,
                0 as *mut libc::c_int,
            );
        }
    }
    if rc == 0 as libc::c_int {
        let mut pSql: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        rc = idxPrintfPrepareStmt(
            (*pNew).db,
            &mut pSql as *mut *mut sqlite3_stmt,
            pzErrmsg,
            b"SELECT sql FROM sqlite_schema WHERE name NOT LIKE 'sqlite_%%' AND sql NOT LIKE 'CREATE VIRTUAL %%'\0"
                as *const u8 as *const libc::c_char,
        );
        while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pSql) {
            let mut zSql: *const libc::c_char = sqlite3_column_text(
                pSql,
                0 as libc::c_int,
            ) as *const libc::c_char;
            if !zSql.is_null() {
                rc = sqlite3_exec(
                    (*pNew).dbm,
                    zSql,
                    None,
                    0 as *mut libc::c_void,
                    pzErrmsg,
                );
            }
        }
        idxFinalize(&mut rc, pSql);
    }
    if rc == 0 as libc::c_int {
        rc = idxCreateVtabSchema(pNew, pzErrmsg);
    }
    if rc == 0 as libc::c_int {
        sqlite3_set_authorizer(
            (*pNew).dbv,
            Some(
                idxAuthCallback
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        libc::c_int,
                        *const libc::c_char,
                        *const libc::c_char,
                        *const libc::c_char,
                        *const libc::c_char,
                    ) -> libc::c_int,
            ),
            pNew as *mut libc::c_void,
        );
    }
    if rc != 0 as libc::c_int {
        sqlite3_expert_destroy(pNew);
        pNew = 0 as *mut sqlite3expert;
    }
    return pNew;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_expert_config(
    mut p: *mut sqlite3expert,
    mut op: libc::c_int,
    mut args: ...
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut ap: ::std::ffi::VaListImpl;
    ap = args.clone();
    match op {
        1 => {
            let mut iVal: libc::c_int = ap.arg::<libc::c_int>();
            if iVal < 0 as libc::c_int {
                iVal = 0 as libc::c_int;
            }
            if iVal > 100 as libc::c_int {
                iVal = 100 as libc::c_int;
            }
            (*p).iSample = iVal;
        }
        _ => {
            rc = 12 as libc::c_int;
        }
    }
    return rc;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_expert_sql(
    mut p: *mut sqlite3expert,
    mut zSql: *const libc::c_char,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut pScanOrig: *mut IdxScan = (*p).pScan;
    let mut pStmtOrig: *mut IdxStatement = (*p).pStatement;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut zStmt: *const libc::c_char = zSql;
    if (*p).bRun != 0 {
        return 21 as libc::c_int;
    }
    while rc == 0 as libc::c_int && !zStmt.is_null()
        && *zStmt.offset(0 as libc::c_int as isize) as libc::c_int != 0
    {
        let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        rc = sqlite3_prepare_v2(
            (*p).dbv,
            zStmt,
            -(1 as libc::c_int),
            &mut pStmt,
            &mut zStmt,
        );
        if rc == 0 as libc::c_int {
            if !pStmt.is_null() {
                let mut pNew: *mut IdxStatement = 0 as *mut IdxStatement;
                let mut z: *const libc::c_char = sqlite3_sql(pStmt);
                let mut n: libc::c_int = strlen(z) as libc::c_int;
                pNew = idxMalloc(
                    &mut rc,
                    (::std::mem::size_of::<IdxStatement>() as libc::c_ulong)
                        .wrapping_add(n as libc::c_ulong)
                        .wrapping_add(1 as libc::c_int as libc::c_ulong) as libc::c_int,
                ) as *mut IdxStatement;
                if rc == 0 as libc::c_int {
                    let ref mut fresh196 = (*pNew).zSql;
                    *fresh196 = &mut *pNew.offset(1 as libc::c_int as isize)
                        as *mut IdxStatement as *mut libc::c_char;
                    memcpy(
                        (*pNew).zSql as *mut libc::c_void,
                        z as *const libc::c_void,
                        (n + 1 as libc::c_int) as libc::c_ulong,
                    );
                    let ref mut fresh197 = (*pNew).pNext;
                    *fresh197 = (*p).pStatement;
                    if !((*p).pStatement).is_null() {
                        (*pNew).iId = (*(*p).pStatement).iId + 1 as libc::c_int;
                    }
                    let ref mut fresh198 = (*p).pStatement;
                    *fresh198 = pNew;
                }
                sqlite3_finalize(pStmt);
            }
        } else {
            idxDatabaseError((*p).dbv, pzErr);
        }
    }
    if rc != 0 as libc::c_int {
        idxScanFree((*p).pScan, pScanOrig);
        idxStatementFree((*p).pStatement, pStmtOrig);
        let ref mut fresh199 = (*p).pScan;
        *fresh199 = pScanOrig;
        let ref mut fresh200 = (*p).pStatement;
        *fresh200 = pStmtOrig;
    }
    return rc;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_expert_analyze(
    mut p: *mut sqlite3expert,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    let mut pEntry: *mut IdxHashEntry = 0 as *mut IdxHashEntry;
    rc = idxProcessTriggers(p, pzErr);
    if rc == 0 as libc::c_int {
        rc = idxCreateCandidates(p);
    } else if rc == 5 as libc::c_int | (3 as libc::c_int) << 8 as libc::c_int {
        if !pzErr.is_null() {
            *pzErr = sqlite3_mprintf(
                b"Cannot find a unique index name to propose.\0" as *const u8
                    as *const libc::c_char,
            );
        }
        return rc;
    }
    if rc == 0 as libc::c_int {
        rc = idxPopulateStat1(p, pzErr);
    }
    pEntry = (*p).hIdx.pFirst;
    while !pEntry.is_null() {
        let ref mut fresh201 = (*p).zCandidates;
        *fresh201 = idxAppendText(
            &mut rc as *mut libc::c_int,
            (*p).zCandidates,
            b"%s;%s%s\n\0" as *const u8 as *const libc::c_char,
            (*pEntry).zVal,
            if !((*pEntry).zVal2).is_null() {
                b" -- stat1: \0" as *const u8 as *const libc::c_char
            } else {
                b"\0" as *const u8 as *const libc::c_char
            },
            (*pEntry).zVal2,
        );
        pEntry = (*pEntry).pNext;
    }
    if rc == 0 as libc::c_int {
        rc = idxFindIndexes(p, pzErr);
    }
    if rc == 0 as libc::c_int {
        (*p).bRun = 1 as libc::c_int;
    }
    return rc;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_expert_count(mut p: *mut sqlite3expert) -> libc::c_int {
    let mut nRet: libc::c_int = 0 as libc::c_int;
    if !((*p).pStatement).is_null() {
        nRet = (*(*p).pStatement).iId + 1 as libc::c_int;
    }
    return nRet;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_expert_report(
    mut p: *mut sqlite3expert,
    mut iStmt: libc::c_int,
    mut eReport: libc::c_int,
) -> *const libc::c_char {
    let mut zRet: *const libc::c_char = 0 as *const libc::c_char;
    let mut pStmt: *mut IdxStatement = 0 as *mut IdxStatement;
    if (*p).bRun == 0 as libc::c_int {
        return 0 as *const libc::c_char;
    }
    pStmt = (*p).pStatement;
    while !pStmt.is_null() && (*pStmt).iId != iStmt {
        pStmt = (*pStmt).pNext;
    }
    match eReport {
        1 => {
            if !pStmt.is_null() {
                zRet = (*pStmt).zSql;
            }
        }
        2 => {
            if !pStmt.is_null() {
                zRet = (*pStmt).zIdx;
            }
        }
        3 => {
            if !pStmt.is_null() {
                zRet = (*pStmt).zEQP;
            }
        }
        4 => {
            zRet = (*p).zCandidates;
        }
        _ => {}
    }
    return zRet;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_expert_destroy(mut p: *mut sqlite3expert) {
    if !p.is_null() {
        sqlite3_close((*p).dbm);
        sqlite3_close((*p).dbv);
        idxScanFree((*p).pScan, 0 as *mut IdxScan);
        idxStatementFree((*p).pStatement, 0 as *mut IdxStatement);
        idxTableFree((*p).pTable);
        idxWriteFree((*p).pWrite);
        idxHashClear(&mut (*p).hIdx);
        sqlite3_free((*p).zCandidates as *mut libc::c_void);
        sqlite3_free(p as *mut libc::c_void);
    }
}
unsafe extern "C" fn dbdataConnect(
    mut db: *mut sqlite3,
    mut pAux: *mut libc::c_void,
    mut argc: libc::c_int,
    mut argv: *const *const libc::c_char,
    mut ppVtab: *mut *mut sqlite3_vtab,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut pTab: *mut DbdataTable = 0 as *mut DbdataTable;
    let mut rc: libc::c_int = sqlite3_declare_vtab(
        db,
        if !pAux.is_null() {
            b"CREATE TABLE x(  pgno INTEGER,  child INTEGER,  schema TEXT HIDDEN)\0"
                as *const u8 as *const libc::c_char
        } else {
            b"CREATE TABLE x(  pgno INTEGER,  cell INTEGER,  field INTEGER,  value ANY,  schema TEXT HIDDEN)\0"
                as *const u8 as *const libc::c_char
        },
    );
    if rc == 0 as libc::c_int {
        pTab = sqlite3_malloc64(
            ::std::mem::size_of::<DbdataTable>() as libc::c_ulong as sqlite3_uint64,
        ) as *mut DbdataTable;
        if pTab.is_null() {
            rc = 7 as libc::c_int;
        } else {
            memset(
                pTab as *mut libc::c_void,
                0 as libc::c_int,
                ::std::mem::size_of::<DbdataTable>() as libc::c_ulong,
            );
            let ref mut fresh202 = (*pTab).db;
            *fresh202 = db;
            (*pTab).bPtr = (pAux != 0 as *mut libc::c_void) as libc::c_int;
        }
    }
    *ppVtab = pTab as *mut sqlite3_vtab;
    return rc;
}
unsafe extern "C" fn dbdataDisconnect(mut pVtab: *mut sqlite3_vtab) -> libc::c_int {
    let mut pTab: *mut DbdataTable = pVtab as *mut DbdataTable;
    if !pTab.is_null() {
        sqlite3_finalize((*pTab).pStmt);
        sqlite3_free(pVtab as *mut libc::c_void);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn dbdataBestIndex(
    mut tab: *mut sqlite3_vtab,
    mut pIdx: *mut sqlite3_index_info,
) -> libc::c_int {
    let mut pTab: *mut DbdataTable = tab as *mut DbdataTable;
    let mut i: libc::c_int = 0;
    let mut iSchema: libc::c_int = -(1 as libc::c_int);
    let mut iPgno: libc::c_int = -(1 as libc::c_int);
    let mut colSchema: libc::c_int = if (*pTab).bPtr != 0 {
        2 as libc::c_int
    } else {
        4 as libc::c_int
    };
    i = 0 as libc::c_int;
    while i < (*pIdx).nConstraint {
        let mut p: *mut sqlite3_index_constraint = &mut *((*pIdx).aConstraint)
            .offset(i as isize) as *mut sqlite3_index_constraint;
        if (*p).op as libc::c_int == 2 as libc::c_int {
            if (*p).iColumn == colSchema {
                if (*p).usable as libc::c_int == 0 as libc::c_int {
                    return 19 as libc::c_int;
                }
                iSchema = i;
            }
            if (*p).iColumn == 0 as libc::c_int && (*p).usable as libc::c_int != 0 {
                iPgno = i;
            }
        }
        i += 1;
    }
    if iSchema >= 0 as libc::c_int {
        (*((*pIdx).aConstraintUsage).offset(iSchema as isize))
            .argvIndex = 1 as libc::c_int;
        (*((*pIdx).aConstraintUsage).offset(iSchema as isize))
            .omit = 1 as libc::c_int as libc::c_uchar;
    }
    if iPgno >= 0 as libc::c_int {
        (*((*pIdx).aConstraintUsage).offset(iPgno as isize))
            .argvIndex = 1 as libc::c_int + (iSchema >= 0 as libc::c_int) as libc::c_int;
        (*((*pIdx).aConstraintUsage).offset(iPgno as isize))
            .omit = 1 as libc::c_int as libc::c_uchar;
        (*pIdx).estimatedCost = 100 as libc::c_int as libc::c_double;
        (*pIdx).estimatedRows = 50 as libc::c_int as sqlite3_int64;
        if (*pTab).bPtr == 0 as libc::c_int && (*pIdx).nOrderBy != 0
            && (*((*pIdx).aOrderBy).offset(0 as libc::c_int as isize)).desc
                as libc::c_int == 0 as libc::c_int
        {
            let mut iCol: libc::c_int = (*((*pIdx).aOrderBy)
                .offset(0 as libc::c_int as isize))
                .iColumn;
            if (*pIdx).nOrderBy == 1 as libc::c_int {
                (*pIdx)
                    .orderByConsumed = (iCol == 0 as libc::c_int
                    || iCol == 1 as libc::c_int) as libc::c_int;
            } else if (*pIdx).nOrderBy == 2 as libc::c_int
                && (*((*pIdx).aOrderBy).offset(1 as libc::c_int as isize)).desc
                    as libc::c_int == 0 as libc::c_int && iCol == 0 as libc::c_int
            {
                (*pIdx)
                    .orderByConsumed = ((*((*pIdx).aOrderBy)
                    .offset(1 as libc::c_int as isize))
                    .iColumn == 1 as libc::c_int) as libc::c_int;
            }
        }
    } else {
        (*pIdx).estimatedCost = 100000000 as libc::c_int as libc::c_double;
        (*pIdx).estimatedRows = 1000000000 as libc::c_int as sqlite3_int64;
    }
    (*pIdx)
        .idxNum = (if iSchema >= 0 as libc::c_int {
        0x1 as libc::c_int
    } else {
        0 as libc::c_int
    }) | (if iPgno >= 0 as libc::c_int { 0x2 as libc::c_int } else { 0 as libc::c_int });
    return 0 as libc::c_int;
}
unsafe extern "C" fn dbdataOpen(
    mut pVTab: *mut sqlite3_vtab,
    mut ppCursor: *mut *mut sqlite3_vtab_cursor,
) -> libc::c_int {
    let mut pCsr: *mut DbdataCursor = 0 as *mut DbdataCursor;
    pCsr = sqlite3_malloc64(
        ::std::mem::size_of::<DbdataCursor>() as libc::c_ulong as sqlite3_uint64,
    ) as *mut DbdataCursor;
    if pCsr.is_null() {
        return 7 as libc::c_int
    } else {
        memset(
            pCsr as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<DbdataCursor>() as libc::c_ulong,
        );
        let ref mut fresh203 = (*pCsr).base.pVtab;
        *fresh203 = pVTab;
    }
    *ppCursor = pCsr as *mut sqlite3_vtab_cursor;
    return 0 as libc::c_int;
}
unsafe extern "C" fn dbdataResetCursor(mut pCsr: *mut DbdataCursor) {
    let mut pTab: *mut DbdataTable = (*pCsr).base.pVtab as *mut DbdataTable;
    if ((*pTab).pStmt).is_null() {
        let ref mut fresh204 = (*pTab).pStmt;
        *fresh204 = (*pCsr).pStmt;
    } else {
        sqlite3_finalize((*pCsr).pStmt);
    }
    let ref mut fresh205 = (*pCsr).pStmt;
    *fresh205 = 0 as *mut sqlite3_stmt;
    (*pCsr).iPgno = 1 as libc::c_int;
    (*pCsr).iCell = 0 as libc::c_int;
    (*pCsr).iField = 0 as libc::c_int;
    (*pCsr).bOnePage = 0 as libc::c_int;
    sqlite3_free((*pCsr).aPage as *mut libc::c_void);
    sqlite3_free((*pCsr).pRec as *mut libc::c_void);
    let ref mut fresh206 = (*pCsr).pRec;
    *fresh206 = 0 as *mut u8_0;
    let ref mut fresh207 = (*pCsr).aPage;
    *fresh207 = 0 as *mut u8_0;
}
unsafe extern "C" fn dbdataClose(mut pCursor: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCsr: *mut DbdataCursor = pCursor as *mut DbdataCursor;
    dbdataResetCursor(pCsr);
    sqlite3_free(pCsr as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn get_uint16(mut a: *mut libc::c_uchar) -> u32_0 {
    return ((*a.offset(0 as libc::c_int as isize) as libc::c_int) << 8 as libc::c_int
        | *a.offset(1 as libc::c_int as isize) as libc::c_int) as u32_0;
}
unsafe extern "C" fn get_uint32(mut a: *mut libc::c_uchar) -> u32_0 {
    return (*a.offset(0 as libc::c_int as isize) as u32_0) << 24 as libc::c_int
        | (*a.offset(1 as libc::c_int as isize) as u32_0) << 16 as libc::c_int
        | (*a.offset(2 as libc::c_int as isize) as u32_0) << 8 as libc::c_int
        | *a.offset(3 as libc::c_int as isize) as u32_0;
}
unsafe extern "C" fn dbdataLoadPage(
    mut pCsr: *mut DbdataCursor,
    mut pgno: u32_0,
    mut ppPage: *mut *mut u8_0,
    mut pnPage: *mut libc::c_int,
) -> libc::c_int {
    let mut rc2: libc::c_int = 0;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut pStmt: *mut sqlite3_stmt = (*pCsr).pStmt;
    *ppPage = 0 as *mut u8_0;
    *pnPage = 0 as libc::c_int;
    if pgno > 0 as libc::c_int as libc::c_uint {
        sqlite3_bind_int64(pStmt, 2 as libc::c_int, pgno as sqlite3_int64);
        if 100 as libc::c_int == sqlite3_step(pStmt) {
            let mut nCopy: libc::c_int = sqlite3_column_bytes(pStmt, 0 as libc::c_int);
            if nCopy > 0 as libc::c_int {
                let mut pPage: *mut u8_0 = 0 as *mut u8_0;
                pPage = sqlite3_malloc64((nCopy + 100 as libc::c_int) as sqlite3_uint64)
                    as *mut u8_0;
                if pPage.is_null() {
                    rc = 7 as libc::c_int;
                } else {
                    let mut pCopy: *const u8_0 = sqlite3_column_blob(
                        pStmt,
                        0 as libc::c_int,
                    ) as *const u8_0;
                    memcpy(
                        pPage as *mut libc::c_void,
                        pCopy as *const libc::c_void,
                        nCopy as libc::c_ulong,
                    );
                    memset(
                        &mut *pPage.offset(nCopy as isize) as *mut u8_0
                            as *mut libc::c_void,
                        0 as libc::c_int,
                        100 as libc::c_int as libc::c_ulong,
                    );
                }
                *ppPage = pPage;
                *pnPage = nCopy;
            }
        }
        rc2 = sqlite3_reset(pStmt);
        if rc == 0 as libc::c_int {
            rc = rc2;
        }
    }
    return rc;
}
unsafe extern "C" fn dbdataGetVarint(
    mut z: *const u8_0,
    mut pVal: *mut sqlite3_int64,
) -> libc::c_int {
    let mut u: sqlite3_uint64 = 0 as libc::c_int as sqlite3_uint64;
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < 8 as libc::c_int {
        u = (u << 7 as libc::c_int)
            .wrapping_add(
                (*z.offset(i as isize) as libc::c_int & 0x7f as libc::c_int)
                    as libc::c_ulonglong,
            );
        if *z.offset(i as isize) as libc::c_int & 0x80 as libc::c_int == 0 as libc::c_int
        {
            *pVal = u as sqlite3_int64;
            return i + 1 as libc::c_int;
        }
        i += 1;
    }
    u = (u << 8 as libc::c_int)
        .wrapping_add(
            (*z.offset(i as isize) as libc::c_int & 0xff as libc::c_int)
                as libc::c_ulonglong,
        );
    *pVal = u as sqlite3_int64;
    return 9 as libc::c_int;
}
unsafe extern "C" fn dbdataGetVarintU32(
    mut z: *const u8_0,
    mut pVal: *mut sqlite3_int64,
) -> libc::c_int {
    let mut val: sqlite3_int64 = 0;
    let mut nRet: libc::c_int = dbdataGetVarint(z, &mut val);
    if val < 0 as libc::c_int as libc::c_longlong
        || val > 0xffffffff as libc::c_uint as libc::c_longlong
    {
        val = 0 as libc::c_int as sqlite3_int64;
    }
    *pVal = val;
    return nRet;
}
unsafe extern "C" fn dbdataValueBytes(mut eType: libc::c_int) -> libc::c_int {
    match eType {
        0 | 8 | 9 | 10 | 11 => return 0 as libc::c_int,
        1 => return 1 as libc::c_int,
        2 => return 2 as libc::c_int,
        3 => return 3 as libc::c_int,
        4 => return 4 as libc::c_int,
        5 => return 6 as libc::c_int,
        6 | 7 => return 8 as libc::c_int,
        _ => {
            if eType > 0 as libc::c_int {
                return (eType - 12 as libc::c_int) / 2 as libc::c_int;
            }
            return 0 as libc::c_int;
        }
    };
}
unsafe extern "C" fn dbdataValue(
    mut pCtx: *mut sqlite3_context,
    mut enc: u32_0,
    mut eType: libc::c_int,
    mut pData: *mut u8_0,
    mut nData: sqlite3_int64,
) {
    if eType >= 0 as libc::c_int && dbdataValueBytes(eType) as libc::c_longlong <= nData
    {
        match eType {
            0 | 10 | 11 => {
                sqlite3_result_null(pCtx);
            }
            8 => {
                sqlite3_result_int(pCtx, 0 as libc::c_int);
            }
            9 => {
                sqlite3_result_int(pCtx, 1 as libc::c_int);
            }
            1 | 2 | 3 | 4 | 5 | 6 | 7 => {
                let mut v: sqlite3_uint64 = *pData.offset(0 as libc::c_int as isize)
                    as libc::c_schar as sqlite3_uint64;
                pData = pData.offset(1);
                let mut current_block_13: u64;
                match eType {
                    7 | 6 => {
                        v = (v << 16 as libc::c_int)
                            .wrapping_add(
                                ((*pData.offset(0 as libc::c_int as isize) as libc::c_int)
                                    << 8 as libc::c_int) as libc::c_ulonglong,
                            )
                            .wrapping_add(
                                *pData.offset(1 as libc::c_int as isize)
                                    as libc::c_ulonglong,
                            );
                        pData = pData.offset(2 as libc::c_int as isize);
                        current_block_13 = 13245577818650221347;
                    }
                    5 => {
                        current_block_13 = 13245577818650221347;
                    }
                    4 => {
                        current_block_13 = 12436666440754361488;
                    }
                    3 => {
                        current_block_13 = 3878127790732541908;
                    }
                    2 => {
                        current_block_13 = 9733642543684482788;
                    }
                    _ => {
                        current_block_13 = 11584701595673473500;
                    }
                }
                match current_block_13 {
                    13245577818650221347 => {
                        v = (v << 16 as libc::c_int)
                            .wrapping_add(
                                ((*pData.offset(0 as libc::c_int as isize) as libc::c_int)
                                    << 8 as libc::c_int) as libc::c_ulonglong,
                            )
                            .wrapping_add(
                                *pData.offset(1 as libc::c_int as isize)
                                    as libc::c_ulonglong,
                            );
                        pData = pData.offset(2 as libc::c_int as isize);
                        current_block_13 = 12436666440754361488;
                    }
                    _ => {}
                }
                match current_block_13 {
                    12436666440754361488 => {
                        v = (v << 8 as libc::c_int)
                            .wrapping_add(
                                *pData.offset(0 as libc::c_int as isize)
                                    as libc::c_ulonglong,
                            );
                        pData = pData.offset(1);
                        current_block_13 = 3878127790732541908;
                    }
                    _ => {}
                }
                match current_block_13 {
                    3878127790732541908 => {
                        v = (v << 8 as libc::c_int)
                            .wrapping_add(
                                *pData.offset(0 as libc::c_int as isize)
                                    as libc::c_ulonglong,
                            );
                        pData = pData.offset(1);
                        current_block_13 = 9733642543684482788;
                    }
                    _ => {}
                }
                match current_block_13 {
                    9733642543684482788 => {
                        v = (v << 8 as libc::c_int)
                            .wrapping_add(
                                *pData.offset(0 as libc::c_int as isize)
                                    as libc::c_ulonglong,
                            );
                        pData = pData.offset(1);
                    }
                    _ => {}
                }
                if eType == 7 as libc::c_int {
                    let mut r: libc::c_double = 0.;
                    memcpy(
                        &mut r as *mut libc::c_double as *mut libc::c_void,
                        &mut v as *mut sqlite3_uint64 as *const libc::c_void,
                        ::std::mem::size_of::<libc::c_double>() as libc::c_ulong,
                    );
                    sqlite3_result_double(pCtx, r);
                } else {
                    sqlite3_result_int64(pCtx, v as sqlite3_int64);
                }
            }
            _ => {
                let mut n: libc::c_int = (eType - 12 as libc::c_int) / 2 as libc::c_int;
                if eType % 2 as libc::c_int != 0 {
                    match enc {
                        3 => {
                            sqlite3_result_text16be(
                                pCtx,
                                pData as *mut libc::c_void,
                                n,
                                ::std::mem::transmute::<
                                    libc::intptr_t,
                                    sqlite3_destructor_type,
                                >(-(1 as libc::c_int) as libc::intptr_t),
                            );
                        }
                        2 => {
                            sqlite3_result_text16le(
                                pCtx,
                                pData as *mut libc::c_void,
                                n,
                                ::std::mem::transmute::<
                                    libc::intptr_t,
                                    sqlite3_destructor_type,
                                >(-(1 as libc::c_int) as libc::intptr_t),
                            );
                        }
                        _ => {
                            sqlite3_result_text(
                                pCtx,
                                pData as *mut libc::c_char,
                                n,
                                ::std::mem::transmute::<
                                    libc::intptr_t,
                                    sqlite3_destructor_type,
                                >(-(1 as libc::c_int) as libc::intptr_t),
                            );
                        }
                    }
                } else {
                    sqlite3_result_blob(
                        pCtx,
                        pData as *const libc::c_void,
                        n,
                        ::std::mem::transmute::<
                            libc::intptr_t,
                            sqlite3_destructor_type,
                        >(-(1 as libc::c_int) as libc::intptr_t),
                    );
                }
            }
        }
    }
}
unsafe extern "C" fn dbdataNext(mut pCursor: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCsr: *mut DbdataCursor = pCursor as *mut DbdataCursor;
    let mut pTab: *mut DbdataTable = (*pCursor).pVtab as *mut DbdataTable;
    let ref mut fresh208 = (*pCsr).iRowid;
    *fresh208 += 1;
    loop {
        let mut rc: libc::c_int = 0;
        let mut iOff: libc::c_int = if (*pCsr).iPgno == 1 as libc::c_int {
            100 as libc::c_int
        } else {
            0 as libc::c_int
        };
        let mut bNextPage: libc::c_int = 0 as libc::c_int;
        if ((*pCsr).aPage).is_null() {
            loop {
                if (*pCsr).bOnePage == 0 as libc::c_int && (*pCsr).iPgno > (*pCsr).szDb {
                    return 0 as libc::c_int;
                }
                rc = dbdataLoadPage(
                    pCsr,
                    (*pCsr).iPgno as u32_0,
                    &mut (*pCsr).aPage,
                    &mut (*pCsr).nPage,
                );
                if rc != 0 as libc::c_int {
                    return rc;
                }
                if !((*pCsr).aPage).is_null() {
                    break;
                }
                if (*pCsr).bOnePage != 0 {
                    return 0 as libc::c_int;
                }
                let ref mut fresh209 = (*pCsr).iPgno;
                *fresh209 += 1;
            }
            (*pCsr)
                .iCell = if (*pTab).bPtr != 0 {
                -(2 as libc::c_int)
            } else {
                0 as libc::c_int
            };
            (*pCsr)
                .nCell = get_uint16(
                &mut *((*pCsr).aPage).offset((iOff + 3 as libc::c_int) as isize),
            ) as libc::c_int;
        }
        if (*pTab).bPtr != 0 {
            if *((*pCsr).aPage).offset(iOff as isize) as libc::c_int
                != 0x2 as libc::c_int
                && *((*pCsr).aPage).offset(iOff as isize) as libc::c_int
                    != 0x5 as libc::c_int
            {
                (*pCsr).iCell = (*pCsr).nCell;
            }
            let ref mut fresh210 = (*pCsr).iCell;
            *fresh210 += 1;
            if (*pCsr).iCell >= (*pCsr).nCell {
                sqlite3_free((*pCsr).aPage as *mut libc::c_void);
                let ref mut fresh211 = (*pCsr).aPage;
                *fresh211 = 0 as *mut u8_0;
                if (*pCsr).bOnePage != 0 {
                    return 0 as libc::c_int;
                }
                let ref mut fresh212 = (*pCsr).iPgno;
                *fresh212 += 1;
            } else {
                return 0 as libc::c_int
            }
        } else {
            if ((*pCsr).pRec).is_null() {
                let mut bHasRowid: libc::c_int = 0 as libc::c_int;
                let mut nPointer: libc::c_int = 0 as libc::c_int;
                let mut nPayload: sqlite3_int64 = 0 as libc::c_int as sqlite3_int64;
                let mut nHdr: sqlite3_int64 = 0 as libc::c_int as sqlite3_int64;
                let mut iHdr: libc::c_int = 0;
                let mut U: libc::c_int = 0;
                let mut X: libc::c_int = 0;
                let mut nLocal: libc::c_int = 0;
                match *((*pCsr).aPage).offset(iOff as isize) as libc::c_int {
                    2 => {
                        nPointer = 4 as libc::c_int;
                    }
                    10 => {}
                    13 => {
                        bHasRowid = 1 as libc::c_int;
                    }
                    _ => {
                        (*pCsr).iCell = (*pCsr).nCell;
                    }
                }
                if (*pCsr).iCell >= (*pCsr).nCell {
                    bNextPage = 1 as libc::c_int;
                } else {
                    iOff
                        += 8 as libc::c_int + nPointer
                            + (*pCsr).iCell * 2 as libc::c_int;
                    if iOff > (*pCsr).nPage {
                        bNextPage = 1 as libc::c_int;
                    } else {
                        iOff = get_uint16(&mut *((*pCsr).aPage).offset(iOff as isize))
                            as libc::c_int;
                    }
                    iOff += nPointer;
                    if bNextPage != 0 || iOff > (*pCsr).nPage {
                        bNextPage = 1 as libc::c_int;
                    } else {
                        iOff
                            += dbdataGetVarintU32(
                                &mut *((*pCsr).aPage).offset(iOff as isize),
                                &mut nPayload,
                            );
                    }
                    if bHasRowid != 0 && bNextPage == 0 && iOff < (*pCsr).nPage {
                        iOff
                            += dbdataGetVarint(
                                &mut *((*pCsr).aPage).offset(iOff as isize),
                                &mut (*pCsr).iIntkey,
                            );
                    }
                    U = (*pCsr).nPage;
                    if bHasRowid != 0 {
                        X = U - 35 as libc::c_int;
                    } else {
                        X = (U - 12 as libc::c_int) * 64 as libc::c_int
                            / 255 as libc::c_int - 23 as libc::c_int;
                    }
                    if nPayload <= X as libc::c_longlong {
                        nLocal = nPayload as libc::c_int;
                    } else {
                        let mut M: libc::c_int = 0;
                        let mut K: libc::c_int = 0;
                        M = (U - 12 as libc::c_int) * 32 as libc::c_int
                            / 255 as libc::c_int - 23 as libc::c_int;
                        K = (M as libc::c_longlong
                            + (nPayload - M as libc::c_longlong)
                                % (U - 4 as libc::c_int) as libc::c_longlong)
                            as libc::c_int;
                        if K <= X {
                            nLocal = K;
                        } else {
                            nLocal = M;
                        }
                    }
                    if bNextPage != 0 || nLocal + iOff > (*pCsr).nPage {
                        bNextPage = 1 as libc::c_int;
                    } else {
                        let ref mut fresh213 = (*pCsr).pRec;
                        *fresh213 = sqlite3_malloc64(
                            (nPayload + 100 as libc::c_int as libc::c_longlong)
                                as sqlite3_uint64,
                        ) as *mut u8_0;
                        if ((*pCsr).pRec).is_null() {
                            return 7 as libc::c_int;
                        }
                        memset(
                            (*pCsr).pRec as *mut libc::c_void,
                            0 as libc::c_int,
                            (nPayload + 100 as libc::c_int as libc::c_longlong)
                                as libc::c_ulong,
                        );
                        (*pCsr).nRec = nPayload;
                        memcpy(
                            (*pCsr).pRec as *mut libc::c_void,
                            &mut *((*pCsr).aPage).offset(iOff as isize) as *mut u8_0
                                as *const libc::c_void,
                            nLocal as libc::c_ulong,
                        );
                        iOff += nLocal;
                        if nPayload > nLocal as libc::c_longlong {
                            let mut nRem: sqlite3_int64 = nPayload
                                - nLocal as libc::c_longlong;
                            let mut pgnoOvfl: u32_0 = get_uint32(
                                &mut *((*pCsr).aPage).offset(iOff as isize),
                            );
                            while nRem > 0 as libc::c_int as libc::c_longlong {
                                let mut aOvfl: *mut u8_0 = 0 as *mut u8_0;
                                let mut nOvfl: libc::c_int = 0 as libc::c_int;
                                let mut nCopy: libc::c_int = 0;
                                rc = dbdataLoadPage(pCsr, pgnoOvfl, &mut aOvfl, &mut nOvfl);
                                if rc != 0 as libc::c_int {
                                    return rc;
                                }
                                if aOvfl.is_null() {
                                    break;
                                }
                                nCopy = U - 4 as libc::c_int;
                                if nCopy as libc::c_longlong > nRem {
                                    nCopy = nRem as libc::c_int;
                                }
                                memcpy(
                                    &mut *((*pCsr).pRec).offset((nPayload - nRem) as isize)
                                        as *mut u8_0 as *mut libc::c_void,
                                    &mut *aOvfl.offset(4 as libc::c_int as isize) as *mut u8_0
                                        as *const libc::c_void,
                                    nCopy as libc::c_ulong,
                                );
                                nRem -= nCopy as libc::c_longlong;
                                pgnoOvfl = get_uint32(aOvfl);
                                sqlite3_free(aOvfl as *mut libc::c_void);
                            }
                        }
                        iHdr = dbdataGetVarintU32((*pCsr).pRec, &mut nHdr);
                        if nHdr > nPayload {
                            nHdr = 0 as libc::c_int as sqlite3_int64;
                        }
                        (*pCsr).nHdr = nHdr;
                        let ref mut fresh214 = (*pCsr).pHdrPtr;
                        *fresh214 = &mut *((*pCsr).pRec).offset(iHdr as isize)
                            as *mut u8_0;
                        let ref mut fresh215 = (*pCsr).pPtr;
                        *fresh215 = &mut *((*pCsr).pRec).offset((*pCsr).nHdr as isize)
                            as *mut u8_0;
                        (*pCsr)
                            .iField = if bHasRowid != 0 {
                            -(1 as libc::c_int)
                        } else {
                            0 as libc::c_int
                        };
                    }
                }
            } else {
                let ref mut fresh216 = (*pCsr).iField;
                *fresh216 += 1;
                if (*pCsr).iField > 0 as libc::c_int {
                    let mut iType: sqlite3_int64 = 0;
                    if (*pCsr).pHdrPtr
                        > &mut *((*pCsr).pRec).offset((*pCsr).nRec as isize) as *mut u8_0
                    {
                        bNextPage = 1 as libc::c_int;
                    } else {
                        let ref mut fresh217 = (*pCsr).pHdrPtr;
                        *fresh217 = (*fresh217)
                            .offset(
                                dbdataGetVarintU32((*pCsr).pHdrPtr, &mut iType) as isize,
                            );
                        let ref mut fresh218 = (*pCsr).pPtr;
                        *fresh218 = (*fresh218)
                            .offset(dbdataValueBytes(iType as libc::c_int) as isize);
                    }
                }
            }
            if bNextPage != 0 {
                sqlite3_free((*pCsr).aPage as *mut libc::c_void);
                sqlite3_free((*pCsr).pRec as *mut libc::c_void);
                let ref mut fresh219 = (*pCsr).aPage;
                *fresh219 = 0 as *mut u8_0;
                let ref mut fresh220 = (*pCsr).pRec;
                *fresh220 = 0 as *mut u8_0;
                if (*pCsr).bOnePage != 0 {
                    return 0 as libc::c_int;
                }
                let ref mut fresh221 = (*pCsr).iPgno;
                *fresh221 += 1;
            } else {
                if (*pCsr).iField < 0 as libc::c_int
                    || (*pCsr).pHdrPtr
                        < &mut *((*pCsr).pRec).offset((*pCsr).nHdr as isize) as *mut u8_0
                {
                    return 0 as libc::c_int;
                }
                sqlite3_free((*pCsr).pRec as *mut libc::c_void);
                let ref mut fresh222 = (*pCsr).pRec;
                *fresh222 = 0 as *mut u8_0;
                let ref mut fresh223 = (*pCsr).iCell;
                *fresh223 += 1;
            }
        }
    };
}
unsafe extern "C" fn dbdataEof(mut pCursor: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCsr: *mut DbdataCursor = pCursor as *mut DbdataCursor;
    return ((*pCsr).aPage == 0 as *mut u8_0) as libc::c_int;
}
unsafe extern "C" fn dbdataIsFunction(mut zSchema: *const libc::c_char) -> libc::c_int {
    let mut n: size_t = strlen(zSchema);
    if n > 2 as libc::c_int as libc::c_ulong
        && *zSchema.offset(n.wrapping_sub(2 as libc::c_int as libc::c_ulong) as isize)
            as libc::c_int == '(' as i32
        && *zSchema.offset(n.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize)
            as libc::c_int == ')' as i32
    {
        return n as libc::c_int - 2 as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn dbdataDbsize(
    mut pCsr: *mut DbdataCursor,
    mut zSchema: *const libc::c_char,
) -> libc::c_int {
    let mut pTab: *mut DbdataTable = (*pCsr).base.pVtab as *mut DbdataTable;
    let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut rc: libc::c_int = 0;
    let mut rc2: libc::c_int = 0;
    let mut nFunc: libc::c_int = 0 as libc::c_int;
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    nFunc = dbdataIsFunction(zSchema);
    if nFunc > 0 as libc::c_int {
        zSql = sqlite3_mprintf(
            b"SELECT %.*s(0)\0" as *const u8 as *const libc::c_char,
            nFunc,
            zSchema,
        );
    } else {
        zSql = sqlite3_mprintf(
            b"PRAGMA %Q.page_count\0" as *const u8 as *const libc::c_char,
            zSchema,
        );
    }
    if zSql.is_null() {
        return 7 as libc::c_int;
    }
    rc = sqlite3_prepare_v2(
        (*pTab).db,
        zSql,
        -(1 as libc::c_int),
        &mut pStmt,
        0 as *mut *const libc::c_char,
    );
    sqlite3_free(zSql as *mut libc::c_void);
    if rc == 0 as libc::c_int && sqlite3_step(pStmt) == 100 as libc::c_int {
        (*pCsr).szDb = sqlite3_column_int(pStmt, 0 as libc::c_int);
    }
    rc2 = sqlite3_finalize(pStmt);
    if rc == 0 as libc::c_int {
        rc = rc2;
    }
    return rc;
}
unsafe extern "C" fn dbdataGetEncoding(mut pCsr: *mut DbdataCursor) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut nPg1: libc::c_int = 0 as libc::c_int;
    let mut aPg1: *mut u8_0 = 0 as *mut u8_0;
    rc = dbdataLoadPage(pCsr, 1 as libc::c_int as u32_0, &mut aPg1, &mut nPg1);
    if rc == 0 as libc::c_int && nPg1 > 0 as libc::c_int {
        (*pCsr).enc = get_uint32(&mut *aPg1.offset(56 as libc::c_int as isize));
    }
    sqlite3_free(aPg1 as *mut libc::c_void);
    return rc;
}
unsafe extern "C" fn dbdataFilter(
    mut pCursor: *mut sqlite3_vtab_cursor,
    mut idxNum: libc::c_int,
    mut idxStr: *const libc::c_char,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) -> libc::c_int {
    let mut pCsr: *mut DbdataCursor = pCursor as *mut DbdataCursor;
    let mut pTab: *mut DbdataTable = (*pCursor).pVtab as *mut DbdataTable;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut zSchema: *const libc::c_char = b"main\0" as *const u8 as *const libc::c_char;
    dbdataResetCursor(pCsr);
    if idxNum & 0x1 as libc::c_int != 0 {
        zSchema = sqlite3_value_text(*argv.offset(0 as libc::c_int as isize))
            as *const libc::c_char;
        if zSchema.is_null() {
            zSchema = b"\0" as *const u8 as *const libc::c_char;
        }
    }
    if idxNum & 0x2 as libc::c_int != 0 {
        (*pCsr)
            .iPgno = sqlite3_value_int(
            *argv.offset((idxNum & 0x1 as libc::c_int) as isize),
        );
        (*pCsr).bOnePage = 1 as libc::c_int;
    } else {
        rc = dbdataDbsize(pCsr, zSchema);
    }
    if rc == 0 as libc::c_int {
        let mut nFunc: libc::c_int = 0 as libc::c_int;
        if !((*pTab).pStmt).is_null() {
            let ref mut fresh224 = (*pCsr).pStmt;
            *fresh224 = (*pTab).pStmt;
            let ref mut fresh225 = (*pTab).pStmt;
            *fresh225 = 0 as *mut sqlite3_stmt;
        } else {
            nFunc = dbdataIsFunction(zSchema);
            if nFunc > 0 as libc::c_int {
                let mut zSql: *mut libc::c_char = sqlite3_mprintf(
                    b"SELECT %.*s(?2)\0" as *const u8 as *const libc::c_char,
                    nFunc,
                    zSchema,
                );
                if zSql.is_null() {
                    rc = 7 as libc::c_int;
                } else {
                    rc = sqlite3_prepare_v2(
                        (*pTab).db,
                        zSql,
                        -(1 as libc::c_int),
                        &mut (*pCsr).pStmt,
                        0 as *mut *const libc::c_char,
                    );
                    sqlite3_free(zSql as *mut libc::c_void);
                }
            } else {
                rc = sqlite3_prepare_v2(
                    (*pTab).db,
                    b"SELECT data FROM sqlite_dbpage(?) WHERE pgno=?\0" as *const u8
                        as *const libc::c_char,
                    -(1 as libc::c_int),
                    &mut (*pCsr).pStmt,
                    0 as *mut *const libc::c_char,
                );
            }
        }
    }
    if rc == 0 as libc::c_int {
        rc = sqlite3_bind_text(
            (*pCsr).pStmt,
            1 as libc::c_int,
            zSchema,
            -(1 as libc::c_int),
            ::std::mem::transmute::<
                libc::intptr_t,
                sqlite3_destructor_type,
            >(-(1 as libc::c_int) as libc::intptr_t),
        );
    } else {
        let ref mut fresh226 = (*pTab).base.zErrMsg;
        *fresh226 = sqlite3_mprintf(
            b"%s\0" as *const u8 as *const libc::c_char,
            sqlite3_errmsg((*pTab).db),
        );
    }
    if rc == 0 as libc::c_int {
        rc = dbdataGetEncoding(pCsr);
    }
    if rc == 0 as libc::c_int {
        rc = dbdataNext(pCursor);
    }
    return rc;
}
unsafe extern "C" fn dbdataColumn(
    mut pCursor: *mut sqlite3_vtab_cursor,
    mut ctx: *mut sqlite3_context,
    mut i: libc::c_int,
) -> libc::c_int {
    let mut pCsr: *mut DbdataCursor = pCursor as *mut DbdataCursor;
    let mut pTab: *mut DbdataTable = (*pCursor).pVtab as *mut DbdataTable;
    if (*pTab).bPtr != 0 {
        match i {
            0 => {
                sqlite3_result_int64(ctx, (*pCsr).iPgno as sqlite3_int64);
            }
            1 => {
                let mut iOff: libc::c_int = if (*pCsr).iPgno == 1 as libc::c_int {
                    100 as libc::c_int
                } else {
                    0 as libc::c_int
                };
                if (*pCsr).iCell < 0 as libc::c_int {
                    iOff += 8 as libc::c_int;
                } else {
                    iOff += 12 as libc::c_int + (*pCsr).iCell * 2 as libc::c_int;
                    if iOff > (*pCsr).nPage {
                        return 0 as libc::c_int;
                    }
                    iOff = get_uint16(&mut *((*pCsr).aPage).offset(iOff as isize))
                        as libc::c_int;
                }
                if iOff <= (*pCsr).nPage {
                    sqlite3_result_int64(
                        ctx,
                        get_uint32(&mut *((*pCsr).aPage).offset(iOff as isize))
                            as sqlite3_int64,
                    );
                }
            }
            _ => {}
        }
    } else {
        match i {
            0 => {
                sqlite3_result_int64(ctx, (*pCsr).iPgno as sqlite3_int64);
            }
            1 => {
                sqlite3_result_int(ctx, (*pCsr).iCell);
            }
            2 => {
                sqlite3_result_int(ctx, (*pCsr).iField);
            }
            3 => {
                if (*pCsr).iField < 0 as libc::c_int {
                    sqlite3_result_int64(ctx, (*pCsr).iIntkey);
                } else if &mut *((*pCsr).pRec).offset((*pCsr).nRec as isize) as *mut u8_0
                    >= (*pCsr).pPtr
                {
                    let mut iType: sqlite3_int64 = 0;
                    dbdataGetVarintU32((*pCsr).pHdrPtr, &mut iType);
                    dbdataValue(
                        ctx,
                        (*pCsr).enc,
                        iType as libc::c_int,
                        (*pCsr).pPtr,
                        (&mut *((*pCsr).pRec).offset((*pCsr).nRec as isize) as *mut u8_0)
                            .offset_from((*pCsr).pPtr) as libc::c_long as sqlite3_int64,
                    );
                }
            }
            _ => {}
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn dbdataRowid(
    mut pCursor: *mut sqlite3_vtab_cursor,
    mut pRowid: *mut sqlite_int64,
) -> libc::c_int {
    let mut pCsr: *mut DbdataCursor = pCursor as *mut DbdataCursor;
    *pRowid = (*pCsr).iRowid;
    return 0 as libc::c_int;
}
unsafe extern "C" fn sqlite3DbdataRegister(mut db: *mut sqlite3) -> libc::c_int {
    static mut dbdata_module: sqlite3_module = unsafe {
        {
            let mut init = sqlite3_module {
                iVersion: 0 as libc::c_int,
                xCreate: None,
                xConnect: Some(
                    dbdataConnect
                        as unsafe extern "C" fn(
                            *mut sqlite3,
                            *mut libc::c_void,
                            libc::c_int,
                            *const *const libc::c_char,
                            *mut *mut sqlite3_vtab,
                            *mut *mut libc::c_char,
                        ) -> libc::c_int,
                ),
                xBestIndex: Some(
                    dbdataBestIndex
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab,
                            *mut sqlite3_index_info,
                        ) -> libc::c_int,
                ),
                xDisconnect: Some(
                    dbdataDisconnect
                        as unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int,
                ),
                xDestroy: None,
                xOpen: Some(
                    dbdataOpen
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab,
                            *mut *mut sqlite3_vtab_cursor,
                        ) -> libc::c_int,
                ),
                xClose: Some(
                    dbdataClose
                        as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xFilter: Some(
                    dbdataFilter
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab_cursor,
                            libc::c_int,
                            *const libc::c_char,
                            libc::c_int,
                            *mut *mut sqlite3_value,
                        ) -> libc::c_int,
                ),
                xNext: Some(
                    dbdataNext
                        as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xEof: Some(
                    dbdataEof
                        as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xColumn: Some(
                    dbdataColumn
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab_cursor,
                            *mut sqlite3_context,
                            libc::c_int,
                        ) -> libc::c_int,
                ),
                xRowid: Some(
                    dbdataRowid
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab_cursor,
                            *mut sqlite_int64,
                        ) -> libc::c_int,
                ),
                xUpdate: None,
                xBegin: None,
                xSync: None,
                xCommit: None,
                xRollback: None,
                xFindFunction: None,
                xRename: None,
                xSavepoint: None,
                xRelease: None,
                xRollbackTo: None,
                xShadowName: None,
            };
            init
        }
    };
    let mut rc: libc::c_int = sqlite3_create_module(
        db,
        b"sqlite_dbdata\0" as *const u8 as *const libc::c_char,
        &mut dbdata_module,
        0 as *mut libc::c_void,
    );
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_module(
            db,
            b"sqlite_dbptr\0" as *const u8 as *const libc::c_char,
            &mut dbdata_module,
            1 as libc::c_int as *mut libc::c_void,
        );
    }
    return rc;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_dbdata_init(
    mut db: *mut sqlite3,
    mut pzErrMsg: *mut *mut libc::c_char,
    mut pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    return sqlite3DbdataRegister(db);
}
static mut recover_g: RecoverGlobal = RecoverGlobal {
    pMethods: 0 as *const sqlite3_io_methods,
    p: 0 as *const sqlite3_recover as *mut sqlite3_recover,
};
unsafe extern "C" fn recoverEnterMutex() {
    sqlite3_mutex_enter(sqlite3_mutex_alloc(9 as libc::c_int));
}
unsafe extern "C" fn recoverLeaveMutex() {
    sqlite3_mutex_leave(sqlite3_mutex_alloc(9 as libc::c_int));
}
unsafe extern "C" fn recoverStrlen(mut zStr: *const libc::c_char) -> libc::c_int {
    if zStr.is_null() {
        return 0 as libc::c_int;
    }
    return (strlen(zStr) & 0x7fffffff as libc::c_int as libc::c_ulong) as libc::c_int;
}
unsafe extern "C" fn recoverMalloc(
    mut p: *mut sqlite3_recover,
    mut nByte: i64_0,
) -> *mut libc::c_void {
    let mut pRet: *mut libc::c_void = 0 as *mut libc::c_void;
    if (*p).errCode == 0 as libc::c_int {
        pRet = sqlite3_malloc64(nByte as sqlite3_uint64);
        if !pRet.is_null() {
            memset(pRet, 0 as libc::c_int, nByte as libc::c_ulong);
        } else {
            (*p).errCode = 7 as libc::c_int;
        }
    }
    return pRet;
}
unsafe extern "C" fn recoverError(
    mut p: *mut sqlite3_recover,
    mut errCode: libc::c_int,
    mut zFmt: *const libc::c_char,
    mut args: ...
) -> libc::c_int {
    let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut ap: ::std::ffi::VaListImpl;
    ap = args.clone();
    if !zFmt.is_null() {
        z = sqlite3_vmprintf(zFmt, ap.as_va_list());
    }
    sqlite3_free((*p).zErrMsg as *mut libc::c_void);
    let ref mut fresh227 = (*p).zErrMsg;
    *fresh227 = z;
    (*p).errCode = errCode;
    return errCode;
}
unsafe extern "C" fn recoverBitmapAlloc(
    mut p: *mut sqlite3_recover,
    mut nPg: i64_0,
) -> *mut RecoverBitmap {
    let mut nElem: libc::c_int = ((nPg + 1 as libc::c_int as libc::c_longlong
        + 31 as libc::c_int as libc::c_longlong) / 32 as libc::c_int as libc::c_longlong)
        as libc::c_int;
    let mut nByte: libc::c_int = (::std::mem::size_of::<RecoverBitmap>()
        as libc::c_ulong)
        .wrapping_add(
            (nElem as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<u32_0>() as libc::c_ulong),
        ) as libc::c_int;
    let mut pRet: *mut RecoverBitmap = recoverMalloc(p, nByte as i64_0)
        as *mut RecoverBitmap;
    if !pRet.is_null() {
        (*pRet).nPg = nPg;
    }
    return pRet;
}
unsafe extern "C" fn recoverBitmapFree(mut pMap: *mut RecoverBitmap) {
    sqlite3_free(pMap as *mut libc::c_void);
}
unsafe extern "C" fn recoverBitmapSet(mut pMap: *mut RecoverBitmap, mut iPg: i64_0) {
    if iPg <= (*pMap).nPg {
        let mut iElem: libc::c_int = (iPg / 32 as libc::c_int as libc::c_longlong)
            as libc::c_int;
        let mut iBit: libc::c_int = (iPg % 32 as libc::c_int as libc::c_longlong)
            as libc::c_int;
        let ref mut fresh228 = *((*pMap).aElem).as_mut_ptr().offset(iElem as isize);
        *fresh228 |= (1 as libc::c_int as u32_0) << iBit;
    }
}
unsafe extern "C" fn recoverBitmapQuery(
    mut pMap: *mut RecoverBitmap,
    mut iPg: i64_0,
) -> libc::c_int {
    let mut ret: libc::c_int = 1 as libc::c_int;
    if iPg <= (*pMap).nPg && iPg > 0 as libc::c_int as libc::c_longlong {
        let mut iElem: libc::c_int = (iPg / 32 as libc::c_int as libc::c_longlong)
            as libc::c_int;
        let mut iBit: libc::c_int = (iPg % 32 as libc::c_int as libc::c_longlong)
            as libc::c_int;
        ret = if *((*pMap).aElem).as_mut_ptr().offset(iElem as isize)
            & (1 as libc::c_int as u32_0) << iBit != 0
        {
            1 as libc::c_int
        } else {
            0 as libc::c_int
        };
    }
    return ret;
}
unsafe extern "C" fn recoverDbError(
    mut p: *mut sqlite3_recover,
    mut db: *mut sqlite3,
) -> libc::c_int {
    return recoverError(
        p,
        sqlite3_errcode(db),
        b"%s\0" as *const u8 as *const libc::c_char,
        sqlite3_errmsg(db),
    );
}
unsafe extern "C" fn recoverPrepare(
    mut p: *mut sqlite3_recover,
    mut db: *mut sqlite3,
    mut zSql: *const libc::c_char,
) -> *mut sqlite3_stmt {
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    if (*p).errCode == 0 as libc::c_int {
        if sqlite3_prepare_v2(
            db,
            zSql,
            -(1 as libc::c_int),
            &mut pStmt,
            0 as *mut *const libc::c_char,
        ) != 0
        {
            recoverDbError(p, db);
        }
    }
    return pStmt;
}
unsafe extern "C" fn recoverPreparePrintf(
    mut p: *mut sqlite3_recover,
    mut db: *mut sqlite3,
    mut zFmt: *const libc::c_char,
    mut args: ...
) -> *mut sqlite3_stmt {
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    if (*p).errCode == 0 as libc::c_int {
        let mut ap: ::std::ffi::VaListImpl;
        let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
        ap = args.clone();
        z = sqlite3_vmprintf(zFmt, ap.as_va_list());
        if z.is_null() {
            (*p).errCode = 7 as libc::c_int;
        } else {
            pStmt = recoverPrepare(p, db, z);
            sqlite3_free(z as *mut libc::c_void);
        }
    }
    return pStmt;
}
unsafe extern "C" fn recoverReset(
    mut p: *mut sqlite3_recover,
    mut pStmt: *mut sqlite3_stmt,
) -> *mut sqlite3_stmt {
    let mut rc: libc::c_int = sqlite3_reset(pStmt);
    if rc != 0 as libc::c_int && rc != 19 as libc::c_int
        && (*p).errCode == 0 as libc::c_int
    {
        recoverDbError(p, sqlite3_db_handle(pStmt));
    }
    return pStmt;
}
unsafe extern "C" fn recoverFinalize(
    mut p: *mut sqlite3_recover,
    mut pStmt: *mut sqlite3_stmt,
) {
    let mut db: *mut sqlite3 = sqlite3_db_handle(pStmt);
    let mut rc: libc::c_int = sqlite3_finalize(pStmt);
    if rc != 0 as libc::c_int && (*p).errCode == 0 as libc::c_int {
        recoverDbError(p, db);
    }
}
unsafe extern "C" fn recoverExec(
    mut p: *mut sqlite3_recover,
    mut db: *mut sqlite3,
    mut zSql: *const libc::c_char,
) -> libc::c_int {
    if (*p).errCode == 0 as libc::c_int {
        let mut rc: libc::c_int = sqlite3_exec(
            db,
            zSql,
            None,
            0 as *mut libc::c_void,
            0 as *mut *mut libc::c_char,
        );
        if rc != 0 {
            recoverDbError(p, db);
        }
    }
    return (*p).errCode;
}
unsafe extern "C" fn recoverBindValue(
    mut p: *mut sqlite3_recover,
    mut pStmt: *mut sqlite3_stmt,
    mut iBind: libc::c_int,
    mut pVal: *mut sqlite3_value,
) {
    if (*p).errCode == 0 as libc::c_int {
        let mut rc: libc::c_int = sqlite3_bind_value(pStmt, iBind, pVal);
        if rc != 0 {
            recoverError(p, rc, 0 as *const libc::c_char);
        }
    }
}
unsafe extern "C" fn recoverMPrintf(
    mut p: *mut sqlite3_recover,
    mut zFmt: *const libc::c_char,
    mut args: ...
) -> *mut libc::c_char {
    let mut ap: ::std::ffi::VaListImpl;
    let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
    ap = args.clone();
    z = sqlite3_vmprintf(zFmt, ap.as_va_list());
    if (*p).errCode == 0 as libc::c_int {
        if z.is_null() {
            (*p).errCode = 7 as libc::c_int;
        }
    } else {
        sqlite3_free(z as *mut libc::c_void);
        z = 0 as *mut libc::c_char;
    }
    return z;
}
unsafe extern "C" fn recoverPageCount(mut p: *mut sqlite3_recover) -> i64_0 {
    let mut nPg: i64_0 = 0 as libc::c_int as i64_0;
    if (*p).errCode == 0 as libc::c_int {
        let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        pStmt = recoverPreparePrintf(
            p,
            (*p).dbIn,
            b"PRAGMA %Q.page_count\0" as *const u8 as *const libc::c_char,
            (*p).zDb,
        );
        if !pStmt.is_null() {
            sqlite3_step(pStmt);
            nPg = sqlite3_column_int64(pStmt, 0 as libc::c_int);
        }
        recoverFinalize(p, pStmt);
    }
    return nPg;
}
unsafe extern "C" fn recoverReadI32(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut pBlob: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut nBlob: libc::c_int = 0;
    let mut iInt: libc::c_int = 0;
    nBlob = sqlite3_value_bytes(*argv.offset(0 as libc::c_int as isize));
    pBlob = sqlite3_value_blob(*argv.offset(0 as libc::c_int as isize))
        as *const libc::c_uchar;
    iInt = sqlite3_value_int(*argv.offset(1 as libc::c_int as isize))
        & 0xffff as libc::c_int;
    if (iInt + 1 as libc::c_int) * 4 as libc::c_int <= nBlob {
        let mut a: *const libc::c_uchar = &*pBlob
            .offset((iInt * 4 as libc::c_int) as isize) as *const libc::c_uchar;
        let mut iVal: i64_0 = ((*a.offset(0 as libc::c_int as isize) as i64_0)
            << 24 as libc::c_int)
            + ((*a.offset(1 as libc::c_int as isize) as i64_0) << 16 as libc::c_int)
            + ((*a.offset(2 as libc::c_int as isize) as i64_0) << 8 as libc::c_int)
            + ((*a.offset(3 as libc::c_int as isize) as i64_0) << 0 as libc::c_int);
        sqlite3_result_int64(context, iVal);
    }
}
unsafe extern "C" fn recoverPageIsUsed(
    mut pCtx: *mut sqlite3_context,
    mut nArg: libc::c_int,
    mut apArg: *mut *mut sqlite3_value,
) {
    let mut p: *mut sqlite3_recover = sqlite3_user_data(pCtx) as *mut sqlite3_recover;
    let mut pgno: i64_0 = sqlite3_value_int64(*apArg.offset(0 as libc::c_int as isize));
    sqlite3_result_int(pCtx, recoverBitmapQuery((*p).laf.pUsed, pgno));
}
unsafe extern "C" fn recoverGetPage(
    mut pCtx: *mut sqlite3_context,
    mut nArg: libc::c_int,
    mut apArg: *mut *mut sqlite3_value,
) {
    let mut p: *mut sqlite3_recover = sqlite3_user_data(pCtx) as *mut sqlite3_recover;
    let mut pgno: i64_0 = sqlite3_value_int64(*apArg.offset(0 as libc::c_int as isize));
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    if pgno == 0 as libc::c_int as libc::c_longlong {
        let mut nPg: i64_0 = recoverPageCount(p);
        sqlite3_result_int64(pCtx, nPg);
        return;
    } else {
        if ((*p).pGetPage).is_null() {
            let ref mut fresh229 = (*p).pGetPage;
            *fresh229 = recoverPreparePrintf(
                p,
                (*p).dbIn,
                b"SELECT data FROM sqlite_dbpage(%Q) WHERE pgno=?\0" as *const u8
                    as *const libc::c_char,
                (*p).zDb,
            );
            pStmt = *fresh229;
        } else if (*p).errCode == 0 as libc::c_int {
            pStmt = (*p).pGetPage;
        }
        if !pStmt.is_null() {
            sqlite3_bind_int64(pStmt, 1 as libc::c_int, pgno);
            if 100 as libc::c_int == sqlite3_step(pStmt) {
                let mut aPg: *const u8_0 = 0 as *const u8_0;
                let mut nPg_0: libc::c_int = 0;
                aPg = sqlite3_column_blob(pStmt, 0 as libc::c_int) as *const u8_0;
                nPg_0 = sqlite3_column_bytes(pStmt, 0 as libc::c_int);
                if pgno == 1 as libc::c_int as libc::c_longlong && nPg_0 == (*p).pgsz
                    && 0 as libc::c_int
                        == memcmp(
                            (*p).pPage1Cache as *const libc::c_void,
                            aPg as *const libc::c_void,
                            nPg_0 as libc::c_ulong,
                        )
                {
                    aPg = (*p).pPage1Disk;
                }
                sqlite3_result_blob(
                    pCtx,
                    aPg as *const libc::c_void,
                    nPg_0 - (*p).nReserve,
                    ::std::mem::transmute::<
                        libc::intptr_t,
                        sqlite3_destructor_type,
                    >(-(1 as libc::c_int) as libc::intptr_t),
                );
            }
            recoverReset(p, pStmt);
        }
    }
    if (*p).errCode != 0 {
        if !((*p).zErrMsg).is_null() {
            sqlite3_result_error(pCtx, (*p).zErrMsg, -(1 as libc::c_int));
        }
        sqlite3_result_error_code(pCtx, (*p).errCode);
    }
}
unsafe extern "C" fn recoverUnusedString(
    mut z: *const libc::c_char,
    mut zA: *const libc::c_char,
    mut zB: *const libc::c_char,
    mut zBuf: *mut libc::c_char,
) -> *const libc::c_char {
    let mut i: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    if (strstr(z, zA)).is_null() {
        return zA;
    }
    if (strstr(z, zB)).is_null() {
        return zB;
    }
    loop {
        let fresh230 = i;
        i = i.wrapping_add(1);
        sqlite3_snprintf(
            20 as libc::c_int,
            zBuf,
            b"(%s%u)\0" as *const u8 as *const libc::c_char,
            zA,
            fresh230,
        );
        if (strstr(z, zBuf)).is_null() {
            break;
        }
    }
    return zBuf;
}
unsafe extern "C" fn recoverEscapeCrnl(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut zText: *const libc::c_char = sqlite3_value_text(
        *argv.offset(0 as libc::c_int as isize),
    ) as *const libc::c_char;
    if !zText.is_null()
        && *zText.offset(0 as libc::c_int as isize) as libc::c_int == '\'' as i32
    {
        let mut nText: libc::c_int = sqlite3_value_bytes(
            *argv.offset(0 as libc::c_int as isize),
        );
        let mut i: libc::c_int = 0;
        let mut zBuf1: [libc::c_char; 20] = [0; 20];
        let mut zBuf2: [libc::c_char; 20] = [0; 20];
        let mut zNL: *const libc::c_char = 0 as *const libc::c_char;
        let mut zCR: *const libc::c_char = 0 as *const libc::c_char;
        let mut nCR: libc::c_int = 0 as libc::c_int;
        let mut nNL: libc::c_int = 0 as libc::c_int;
        i = 0 as libc::c_int;
        while *zText.offset(i as isize) != 0 {
            if zNL.is_null() && *zText.offset(i as isize) as libc::c_int == '\n' as i32 {
                zNL = recoverUnusedString(
                    zText,
                    b"\\n\0" as *const u8 as *const libc::c_char,
                    b"\\012\0" as *const u8 as *const libc::c_char,
                    zBuf1.as_mut_ptr(),
                );
                nNL = strlen(zNL) as libc::c_int;
            }
            if zCR.is_null() && *zText.offset(i as isize) as libc::c_int == '\r' as i32 {
                zCR = recoverUnusedString(
                    zText,
                    b"\\r\0" as *const u8 as *const libc::c_char,
                    b"\\015\0" as *const u8 as *const libc::c_char,
                    zBuf2.as_mut_ptr(),
                );
                nCR = strlen(zCR) as libc::c_int;
            }
            i += 1;
        }
        if !zNL.is_null() || !zCR.is_null() {
            let mut iOut: libc::c_int = 0 as libc::c_int;
            let mut nMax: i64_0 = (if nNL > nCR { nNL } else { nCR }) as i64_0;
            let mut nAlloc: i64_0 = nMax * nText as libc::c_longlong
                + (nMax + 64 as libc::c_int as libc::c_longlong)
                    * 2 as libc::c_int as libc::c_longlong;
            let mut zOut: *mut libc::c_char = sqlite3_malloc64(nAlloc as sqlite3_uint64)
                as *mut libc::c_char;
            if zOut.is_null() {
                sqlite3_result_error_nomem(context);
                return;
            }
            if !zNL.is_null() && !zCR.is_null() {
                memcpy(
                    &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                        as *mut libc::c_void,
                    b"replace(replace(\0" as *const u8 as *const libc::c_char
                        as *const libc::c_void,
                    16 as libc::c_int as libc::c_ulong,
                );
                iOut += 16 as libc::c_int;
            } else {
                memcpy(
                    &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                        as *mut libc::c_void,
                    b"replace(\0" as *const u8 as *const libc::c_char
                        as *const libc::c_void,
                    8 as libc::c_int as libc::c_ulong,
                );
                iOut += 8 as libc::c_int;
            }
            i = 0 as libc::c_int;
            while *zText.offset(i as isize) != 0 {
                if *zText.offset(i as isize) as libc::c_int == '\n' as i32 {
                    memcpy(
                        &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                            as *mut libc::c_void,
                        zNL as *const libc::c_void,
                        nNL as libc::c_ulong,
                    );
                    iOut += nNL;
                } else if *zText.offset(i as isize) as libc::c_int == '\r' as i32 {
                    memcpy(
                        &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                            as *mut libc::c_void,
                        zCR as *const libc::c_void,
                        nCR as libc::c_ulong,
                    );
                    iOut += nCR;
                } else {
                    *zOut.offset(iOut as isize) = *zText.offset(i as isize);
                    iOut += 1;
                }
                i += 1;
            }
            if !zNL.is_null() {
                memcpy(
                    &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                        as *mut libc::c_void,
                    b",'\0" as *const u8 as *const libc::c_char as *const libc::c_void,
                    2 as libc::c_int as libc::c_ulong,
                );
                iOut += 2 as libc::c_int;
                memcpy(
                    &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                        as *mut libc::c_void,
                    zNL as *const libc::c_void,
                    nNL as libc::c_ulong,
                );
                iOut += nNL;
                memcpy(
                    &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                        as *mut libc::c_void,
                    b"', char(10))\0" as *const u8 as *const libc::c_char
                        as *const libc::c_void,
                    12 as libc::c_int as libc::c_ulong,
                );
                iOut += 12 as libc::c_int;
            }
            if !zCR.is_null() {
                memcpy(
                    &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                        as *mut libc::c_void,
                    b",'\0" as *const u8 as *const libc::c_char as *const libc::c_void,
                    2 as libc::c_int as libc::c_ulong,
                );
                iOut += 2 as libc::c_int;
                memcpy(
                    &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                        as *mut libc::c_void,
                    zCR as *const libc::c_void,
                    nCR as libc::c_ulong,
                );
                iOut += nCR;
                memcpy(
                    &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                        as *mut libc::c_void,
                    b"', char(13))\0" as *const u8 as *const libc::c_char
                        as *const libc::c_void,
                    12 as libc::c_int as libc::c_ulong,
                );
                iOut += 12 as libc::c_int;
            }
            sqlite3_result_text(
                context,
                zOut,
                iOut,
                ::std::mem::transmute::<
                    libc::intptr_t,
                    sqlite3_destructor_type,
                >(-(1 as libc::c_int) as libc::intptr_t),
            );
            sqlite3_free(zOut as *mut libc::c_void);
            return;
        }
    }
    sqlite3_result_value(context, *argv.offset(0 as libc::c_int as isize));
}
unsafe extern "C" fn recoverCacheSchema(mut p: *mut sqlite3_recover) -> libc::c_int {
    return recoverExec(
        p,
        (*p).dbOut,
        b"WITH RECURSIVE pages(p) AS (  SELECT 1    UNION  SELECT child FROM sqlite_dbptr('getpage()'), pages WHERE pgno=p)INSERT INTO recovery.schema SELECT  max(CASE WHEN field=0 THEN value ELSE NULL END),  max(CASE WHEN field=1 THEN value ELSE NULL END),  max(CASE WHEN field=2 THEN value ELSE NULL END),  max(CASE WHEN field=3 THEN value ELSE NULL END),  max(CASE WHEN field=4 THEN value ELSE NULL END)FROM sqlite_dbdata('getpage()') WHERE pgno IN (  SELECT p FROM pages) GROUP BY pgno, cell\0"
            as *const u8 as *const libc::c_char,
    );
}
unsafe extern "C" fn recoverSqlCallback(
    mut p: *mut sqlite3_recover,
    mut zSql: *const libc::c_char,
) {
    if (*p).errCode == 0 as libc::c_int && ((*p).xSql).is_some() {
        let mut res: libc::c_int = ((*p).xSql)
            .expect("non-null function pointer")((*p).pSqlCtx, zSql);
        if res != 0 {
            recoverError(
                p,
                1 as libc::c_int,
                b"callback returned an error - %d\0" as *const u8 as *const libc::c_char,
                res,
            );
        }
    }
}
unsafe extern "C" fn recoverTransferSettings(mut p: *mut sqlite3_recover) {
    let mut aPragma: [*const libc::c_char; 5] = [
        b"encoding\0" as *const u8 as *const libc::c_char,
        b"page_size\0" as *const u8 as *const libc::c_char,
        b"auto_vacuum\0" as *const u8 as *const libc::c_char,
        b"user_version\0" as *const u8 as *const libc::c_char,
        b"application_id\0" as *const u8 as *const libc::c_char,
    ];
    let mut ii: libc::c_int = 0;
    if (*p).errCode == 0 as libc::c_int {
        let mut db2: *mut sqlite3 = 0 as *mut sqlite3;
        let mut rc: libc::c_int = sqlite3_open(
            b"\0" as *const u8 as *const libc::c_char,
            &mut db2,
        );
        if rc != 0 as libc::c_int {
            recoverDbError(p, db2);
            return;
        }
        ii = 0 as libc::c_int;
        while (ii as libc::c_ulong)
            < (::std::mem::size_of::<[*const libc::c_char; 5]>() as libc::c_ulong)
                .wrapping_div(
                    ::std::mem::size_of::<*const libc::c_char>() as libc::c_ulong,
                )
        {
            let mut zPrag: *const libc::c_char = aPragma[ii as usize];
            let mut p1: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
            p1 = recoverPreparePrintf(
                p,
                (*p).dbIn,
                b"PRAGMA %Q.%s\0" as *const u8 as *const libc::c_char,
                (*p).zDb,
                zPrag,
            );
            if (*p).errCode == 0 as libc::c_int && sqlite3_step(p1) == 100 as libc::c_int
            {
                let mut zArg: *const libc::c_char = sqlite3_column_text(
                    p1,
                    0 as libc::c_int,
                ) as *const libc::c_char;
                let mut z2: *mut libc::c_char = recoverMPrintf(
                    p,
                    b"PRAGMA %s = %Q\0" as *const u8 as *const libc::c_char,
                    zPrag,
                    zArg,
                );
                recoverSqlCallback(p, z2);
                recoverExec(p, db2, z2);
                sqlite3_free(z2 as *mut libc::c_void);
                if zArg.is_null() {
                    recoverError(p, 7 as libc::c_int, 0 as *const libc::c_char);
                }
            }
            recoverFinalize(p, p1);
            ii += 1;
        }
        recoverExec(
            p,
            db2,
            b"CREATE TABLE t1(a); DROP TABLE t1;\0" as *const u8 as *const libc::c_char,
        );
        if (*p).errCode == 0 as libc::c_int {
            let mut db: *mut sqlite3 = (*p).dbOut;
            let mut pBackup: *mut sqlite3_backup = sqlite3_backup_init(
                db,
                b"main\0" as *const u8 as *const libc::c_char,
                db2,
                b"main\0" as *const u8 as *const libc::c_char,
            );
            if !pBackup.is_null() {
                sqlite3_backup_step(pBackup, -(1 as libc::c_int));
                (*p).errCode = sqlite3_backup_finish(pBackup);
            } else {
                recoverDbError(p, db);
            }
        }
        sqlite3_close(db2);
    }
}
unsafe extern "C" fn recoverOpenOutput(mut p: *mut sqlite3_recover) -> libc::c_int {
    let mut aFunc: [Func; 4] = [
        {
            let mut init = Func {
                zName: b"getpage\0" as *const u8 as *const libc::c_char,
                nArg: 1 as libc::c_int,
                xFunc: Some(
                    recoverGetPage
                        as unsafe extern "C" fn(
                            *mut sqlite3_context,
                            libc::c_int,
                            *mut *mut sqlite3_value,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = Func {
                zName: b"page_is_used\0" as *const u8 as *const libc::c_char,
                nArg: 1 as libc::c_int,
                xFunc: Some(
                    recoverPageIsUsed
                        as unsafe extern "C" fn(
                            *mut sqlite3_context,
                            libc::c_int,
                            *mut *mut sqlite3_value,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = Func {
                zName: b"read_i32\0" as *const u8 as *const libc::c_char,
                nArg: 2 as libc::c_int,
                xFunc: Some(
                    recoverReadI32
                        as unsafe extern "C" fn(
                            *mut sqlite3_context,
                            libc::c_int,
                            *mut *mut sqlite3_value,
                        ) -> (),
                ),
            };
            init
        },
        {
            let mut init = Func {
                zName: b"escape_crnl\0" as *const u8 as *const libc::c_char,
                nArg: 1 as libc::c_int,
                xFunc: Some(
                    recoverEscapeCrnl
                        as unsafe extern "C" fn(
                            *mut sqlite3_context,
                            libc::c_int,
                            *mut *mut sqlite3_value,
                        ) -> (),
                ),
            };
            init
        },
    ];
    let flags: libc::c_int = 0x40 as libc::c_int | 0x4 as libc::c_int
        | 0x2 as libc::c_int;
    let mut db: *mut sqlite3 = 0 as *mut sqlite3;
    let mut ii: libc::c_int = 0;
    if sqlite3_open_v2((*p).zUri, &mut db, flags, 0 as *const libc::c_char) != 0 {
        recoverDbError(p, db);
    }
    if (*p).errCode == 0 as libc::c_int {
        (*p)
            .errCode = sqlite3_dbdata_init(
            db,
            0 as *mut *mut libc::c_char,
            0 as *const sqlite3_api_routines,
        );
    }
    ii = 0 as libc::c_int;
    while (*p).errCode == 0 as libc::c_int
        && (ii as libc::c_ulong)
            < (::std::mem::size_of::<[Func; 4]>() as libc::c_ulong)
                .wrapping_div(::std::mem::size_of::<Func>() as libc::c_ulong)
    {
        (*p)
            .errCode = sqlite3_create_function(
            db,
            aFunc[ii as usize].zName,
            aFunc[ii as usize].nArg,
            1 as libc::c_int,
            p as *mut libc::c_void,
            aFunc[ii as usize].xFunc,
            None,
            None,
        );
        ii += 1;
    }
    let ref mut fresh231 = (*p).dbOut;
    *fresh231 = db;
    return (*p).errCode;
}
unsafe extern "C" fn recoverOpenRecovery(mut p: *mut sqlite3_recover) {
    let mut zSql: *mut libc::c_char = recoverMPrintf(
        p,
        b"ATTACH %Q AS recovery;\0" as *const u8 as *const libc::c_char,
        (*p).zStateDb,
    );
    recoverExec(p, (*p).dbOut, zSql);
    recoverExec(
        p,
        (*p).dbOut,
        b"PRAGMA writable_schema = 1;CREATE TABLE recovery.map(pgno INTEGER PRIMARY KEY, parent INT);CREATE TABLE recovery.schema(type, name, tbl_name, rootpage, sql);\0"
            as *const u8 as *const libc::c_char,
    );
    sqlite3_free(zSql as *mut libc::c_void);
}
unsafe extern "C" fn recoverAddTable(
    mut p: *mut sqlite3_recover,
    mut zName: *const libc::c_char,
    mut iRoot: i64_0,
) {
    let mut pStmt: *mut sqlite3_stmt = recoverPreparePrintf(
        p,
        (*p).dbOut,
        b"PRAGMA table_xinfo(%Q)\0" as *const u8 as *const libc::c_char,
        zName,
    );
    if !pStmt.is_null() {
        let mut iPk: libc::c_int = -(1 as libc::c_int);
        let mut iBind: libc::c_int = 1 as libc::c_int;
        let mut pNew: *mut RecoverTable = 0 as *mut RecoverTable;
        let mut nCol: libc::c_int = 0 as libc::c_int;
        let mut nName: libc::c_int = recoverStrlen(zName);
        let mut nByte: libc::c_int = 0 as libc::c_int;
        while sqlite3_step(pStmt) == 100 as libc::c_int {
            nCol += 1;
            nByte += sqlite3_column_bytes(pStmt, 1 as libc::c_int) + 1 as libc::c_int;
        }
        nByte = (nByte as libc::c_ulong)
            .wrapping_add(
                (::std::mem::size_of::<RecoverTable>() as libc::c_ulong)
                    .wrapping_add(
                        (nCol as libc::c_ulong)
                            .wrapping_mul(
                                ::std::mem::size_of::<RecoverColumn>() as libc::c_ulong,
                            ),
                    )
                    .wrapping_add(nName as libc::c_ulong)
                    .wrapping_add(1 as libc::c_int as libc::c_ulong),
            ) as libc::c_int as libc::c_int;
        recoverReset(p, pStmt);
        pNew = recoverMalloc(p, nByte as i64_0) as *mut RecoverTable;
        if !pNew.is_null() {
            let mut i: libc::c_int = 0 as libc::c_int;
            let mut iField: libc::c_int = 0 as libc::c_int;
            let mut csr: *mut libc::c_char = 0 as *mut libc::c_char;
            let ref mut fresh232 = (*pNew).aCol;
            *fresh232 = &mut *pNew.offset(1 as libc::c_int as isize) as *mut RecoverTable
                as *mut RecoverColumn;
            csr = &mut *((*pNew).aCol).offset(nCol as isize) as *mut RecoverColumn
                as *mut libc::c_char;
            let ref mut fresh233 = (*pNew).zTab;
            *fresh233 = csr;
            (*pNew).nCol = nCol;
            (*pNew).iRoot = iRoot as u32_0;
            memcpy(
                csr as *mut libc::c_void,
                zName as *const libc::c_void,
                nName as libc::c_ulong,
            );
            csr = csr.offset((nName + 1 as libc::c_int) as isize);
            i = 0 as libc::c_int;
            while sqlite3_step(pStmt) == 100 as libc::c_int {
                let mut iPKF: libc::c_int = sqlite3_column_int(pStmt, 5 as libc::c_int);
                let mut n: libc::c_int = sqlite3_column_bytes(pStmt, 1 as libc::c_int);
                let mut z: *const libc::c_char = sqlite3_column_text(
                    pStmt,
                    1 as libc::c_int,
                ) as *const libc::c_char;
                let mut zType: *const libc::c_char = sqlite3_column_text(
                    pStmt,
                    2 as libc::c_int,
                ) as *const libc::c_char;
                let mut eHidden: libc::c_int = sqlite3_column_int(
                    pStmt,
                    6 as libc::c_int,
                );
                if iPk == -(1 as libc::c_int) && iPKF == 1 as libc::c_int
                    && sqlite3_stricmp(
                        b"integer\0" as *const u8 as *const libc::c_char,
                        zType,
                    ) == 0
                {
                    iPk = i;
                }
                if iPKF > 1 as libc::c_int {
                    iPk = -(2 as libc::c_int);
                }
                let ref mut fresh234 = (*((*pNew).aCol).offset(i as isize)).zCol;
                *fresh234 = csr;
                (*((*pNew).aCol).offset(i as isize)).eHidden = eHidden;
                if eHidden == 2 as libc::c_int {
                    (*((*pNew).aCol).offset(i as isize)).iField = -(1 as libc::c_int);
                } else {
                    let fresh235 = iField;
                    iField = iField + 1;
                    (*((*pNew).aCol).offset(i as isize)).iField = fresh235;
                }
                if eHidden != 2 as libc::c_int && eHidden != 3 as libc::c_int {
                    let fresh236 = iBind;
                    iBind = iBind + 1;
                    (*((*pNew).aCol).offset(i as isize)).iBind = fresh236;
                }
                memcpy(
                    csr as *mut libc::c_void,
                    z as *const libc::c_void,
                    n as libc::c_ulong,
                );
                csr = csr.offset((n + 1 as libc::c_int) as isize);
                i += 1;
            }
            let ref mut fresh237 = (*pNew).pNext;
            *fresh237 = (*p).pTblList;
            let ref mut fresh238 = (*p).pTblList;
            *fresh238 = pNew;
            (*pNew).bIntkey = 1 as libc::c_int;
        }
        recoverFinalize(p, pStmt);
        pStmt = recoverPreparePrintf(
            p,
            (*p).dbOut,
            b"PRAGMA index_xinfo(%Q)\0" as *const u8 as *const libc::c_char,
            zName,
        );
        while !pStmt.is_null() && sqlite3_step(pStmt) == 100 as libc::c_int {
            let mut iField_0: libc::c_int = sqlite3_column_int(pStmt, 0 as libc::c_int);
            let mut iCol: libc::c_int = sqlite3_column_int(pStmt, 1 as libc::c_int);
            (*((*pNew).aCol).offset(iCol as isize)).iField = iField_0;
            (*pNew).bIntkey = 0 as libc::c_int;
            iPk = -(2 as libc::c_int);
        }
        recoverFinalize(p, pStmt);
        if (*p).errCode == 0 as libc::c_int {
            if iPk >= 0 as libc::c_int {
                (*((*pNew).aCol).offset(iPk as isize)).bIPK = 1 as libc::c_int;
            } else if (*pNew).bIntkey != 0 {
                let fresh239 = iBind;
                iBind = iBind + 1;
                (*pNew).iRowidBind = fresh239;
            }
        }
    }
}
unsafe extern "C" fn recoverWriteSchema1(mut p: *mut sqlite3_recover) -> libc::c_int {
    let mut pSelect: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut pTblname: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    pSelect = recoverPrepare(
        p,
        (*p).dbOut,
        b"WITH dbschema(rootpage, name, sql, tbl, isVirtual, isIndex) AS (  SELECT rootpage, name, sql,     type='table',     sql LIKE 'create virtual%',    (type='index' AND (sql LIKE '%unique%' OR ?1))  FROM recovery.schema)SELECT rootpage, tbl, isVirtual, name, sql FROM dbschema   WHERE tbl OR isIndex  ORDER BY tbl DESC, name=='sqlite_sequence' DESC\0"
            as *const u8 as *const libc::c_char,
    );
    pTblname = recoverPrepare(
        p,
        (*p).dbOut,
        b"SELECT name FROM sqlite_schema WHERE type='table' ORDER BY rowid DESC LIMIT 1\0"
            as *const u8 as *const libc::c_char,
    );
    if !pSelect.is_null() {
        sqlite3_bind_int(pSelect, 1 as libc::c_int, (*p).bSlowIndexes);
        while sqlite3_step(pSelect) == 100 as libc::c_int {
            let mut iRoot: i64_0 = sqlite3_column_int64(pSelect, 0 as libc::c_int);
            let mut bTable: libc::c_int = sqlite3_column_int(pSelect, 1 as libc::c_int);
            let mut bVirtual: libc::c_int = sqlite3_column_int(
                pSelect,
                2 as libc::c_int,
            );
            let mut zName: *const libc::c_char = sqlite3_column_text(
                pSelect,
                3 as libc::c_int,
            ) as *const libc::c_char;
            let mut zSql: *const libc::c_char = sqlite3_column_text(
                pSelect,
                4 as libc::c_int,
            ) as *const libc::c_char;
            let mut zFree: *mut libc::c_char = 0 as *mut libc::c_char;
            let mut rc: libc::c_int = 0 as libc::c_int;
            if bVirtual != 0 {
                zFree = recoverMPrintf(
                    p,
                    b"INSERT INTO sqlite_schema VALUES('table', %Q, %Q, 0, %Q)\0"
                        as *const u8 as *const libc::c_char,
                    zName,
                    zName,
                    zSql,
                );
                zSql = zFree as *const libc::c_char;
            }
            rc = sqlite3_exec(
                (*p).dbOut,
                zSql,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
            if rc == 0 as libc::c_int {
                recoverSqlCallback(p, zSql);
                if bTable != 0 && bVirtual == 0 {
                    if 100 as libc::c_int == sqlite3_step(pTblname) {
                        let mut zTbl: *const libc::c_char = sqlite3_column_text(
                            pTblname,
                            0 as libc::c_int,
                        ) as *const libc::c_char;
                        recoverAddTable(p, zTbl, iRoot);
                    }
                    recoverReset(p, pTblname);
                }
            } else if rc != 1 as libc::c_int {
                recoverDbError(p, (*p).dbOut);
            }
            sqlite3_free(zFree as *mut libc::c_void);
        }
    }
    recoverFinalize(p, pSelect);
    recoverFinalize(p, pTblname);
    return (*p).errCode;
}
unsafe extern "C" fn recoverWriteSchema2(mut p: *mut sqlite3_recover) -> libc::c_int {
    let mut pSelect: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    pSelect = recoverPrepare(
        p,
        (*p).dbOut,
        if (*p).bSlowIndexes != 0 {
            b"SELECT rootpage, sql FROM recovery.schema   WHERE type!='table' AND type!='index'\0"
                as *const u8 as *const libc::c_char
        } else {
            b"SELECT rootpage, sql FROM recovery.schema   WHERE type!='table' AND (type!='index' OR sql NOT LIKE '%unique%')\0"
                as *const u8 as *const libc::c_char
        },
    );
    if !pSelect.is_null() {
        while sqlite3_step(pSelect) == 100 as libc::c_int {
            let mut zSql: *const libc::c_char = sqlite3_column_text(
                pSelect,
                1 as libc::c_int,
            ) as *const libc::c_char;
            let mut rc: libc::c_int = sqlite3_exec(
                (*p).dbOut,
                zSql,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
            if rc == 0 as libc::c_int {
                recoverSqlCallback(p, zSql);
            } else if rc != 1 as libc::c_int {
                recoverDbError(p, (*p).dbOut);
            }
        }
    }
    recoverFinalize(p, pSelect);
    return (*p).errCode;
}
unsafe extern "C" fn recoverInsertStmt(
    mut p: *mut sqlite3_recover,
    mut pTab: *mut RecoverTable,
    mut nField: libc::c_int,
) -> *mut sqlite3_stmt {
    let mut pRet: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut zSep: *const libc::c_char = b"\0" as *const u8 as *const libc::c_char;
    let mut zSqlSep: *const libc::c_char = b"\0" as *const u8 as *const libc::c_char;
    let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zFinal: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zBind: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut ii: libc::c_int = 0;
    let mut bSql: libc::c_int = if ((*p).xSql).is_some() {
        1 as libc::c_int
    } else {
        0 as libc::c_int
    };
    if nField <= 0 as libc::c_int {
        return 0 as *mut sqlite3_stmt;
    }
    zSql = recoverMPrintf(
        p,
        b"INSERT OR IGNORE INTO %Q(\0" as *const u8 as *const libc::c_char,
        (*pTab).zTab,
    );
    if (*pTab).iRowidBind != 0 {
        zSql = recoverMPrintf(
            p,
            b"%z_rowid_\0" as *const u8 as *const libc::c_char,
            zSql,
        );
        if bSql != 0 {
            zBind = recoverMPrintf(
                p,
                b"%zquote(?%d)\0" as *const u8 as *const libc::c_char,
                zBind,
                (*pTab).iRowidBind,
            );
        } else {
            zBind = recoverMPrintf(
                p,
                b"%z?%d\0" as *const u8 as *const libc::c_char,
                zBind,
                (*pTab).iRowidBind,
            );
        }
        zSqlSep = b"||', '||\0" as *const u8 as *const libc::c_char;
        zSep = b", \0" as *const u8 as *const libc::c_char;
    }
    ii = 0 as libc::c_int;
    while ii < nField {
        let mut eHidden: libc::c_int = (*((*pTab).aCol).offset(ii as isize)).eHidden;
        if eHidden != 2 as libc::c_int && eHidden != 3 as libc::c_int {
            zSql = recoverMPrintf(
                p,
                b"%z%s%Q\0" as *const u8 as *const libc::c_char,
                zSql,
                zSep,
                (*((*pTab).aCol).offset(ii as isize)).zCol,
            );
            if bSql != 0 {
                zBind = recoverMPrintf(
                    p,
                    b"%z%sescape_crnl(quote(?%d))\0" as *const u8 as *const libc::c_char,
                    zBind,
                    zSqlSep,
                    (*((*pTab).aCol).offset(ii as isize)).iBind,
                );
                zSqlSep = b"||', '||\0" as *const u8 as *const libc::c_char;
            } else {
                zBind = recoverMPrintf(
                    p,
                    b"%z%s?%d\0" as *const u8 as *const libc::c_char,
                    zBind,
                    zSep,
                    (*((*pTab).aCol).offset(ii as isize)).iBind,
                );
            }
            zSep = b", \0" as *const u8 as *const libc::c_char;
        }
        ii += 1;
    }
    if bSql != 0 {
        zFinal = recoverMPrintf(
            p,
            b"SELECT %Q || ') VALUES (' || %s || ')'\0" as *const u8
                as *const libc::c_char,
            zSql,
            zBind,
        );
    } else {
        zFinal = recoverMPrintf(
            p,
            b"%s) VALUES (%s)\0" as *const u8 as *const libc::c_char,
            zSql,
            zBind,
        );
    }
    pRet = recoverPrepare(p, (*p).dbOut, zFinal);
    sqlite3_free(zSql as *mut libc::c_void);
    sqlite3_free(zBind as *mut libc::c_void);
    sqlite3_free(zFinal as *mut libc::c_void);
    return pRet;
}
unsafe extern "C" fn recoverFindTable(
    mut p: *mut sqlite3_recover,
    mut iRoot: u32_0,
) -> *mut RecoverTable {
    let mut pRet: *mut RecoverTable = 0 as *mut RecoverTable;
    pRet = (*p).pTblList;
    while !pRet.is_null() && (*pRet).iRoot != iRoot {
        pRet = (*pRet).pNext;
    }
    return pRet;
}
unsafe extern "C" fn recoverLostAndFoundCreate(
    mut p: *mut sqlite3_recover,
    mut nField: libc::c_int,
) -> *mut libc::c_char {
    let mut zTbl: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut pProbe: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut ii: libc::c_int = 0 as libc::c_int;
    pProbe = recoverPrepare(
        p,
        (*p).dbOut,
        b"SELECT 1 FROM sqlite_schema WHERE name=?\0" as *const u8 as *const libc::c_char,
    );
    ii = -(1 as libc::c_int);
    while zTbl.is_null() && (*p).errCode == 0 as libc::c_int && ii < 1000 as libc::c_int
    {
        let mut bFail: libc::c_int = 0 as libc::c_int;
        if ii < 0 as libc::c_int {
            zTbl = recoverMPrintf(
                p,
                b"%s\0" as *const u8 as *const libc::c_char,
                (*p).zLostAndFound,
            );
        } else {
            zTbl = recoverMPrintf(
                p,
                b"%s_%d\0" as *const u8 as *const libc::c_char,
                (*p).zLostAndFound,
                ii,
            );
        }
        if (*p).errCode == 0 as libc::c_int {
            sqlite3_bind_text(pProbe, 1 as libc::c_int, zTbl, -(1 as libc::c_int), None);
            if 100 as libc::c_int == sqlite3_step(pProbe) {
                bFail = 1 as libc::c_int;
            }
            recoverReset(p, pProbe);
        }
        if bFail != 0 {
            sqlite3_clear_bindings(pProbe);
            sqlite3_free(zTbl as *mut libc::c_void);
            zTbl = 0 as *mut libc::c_char;
        }
        ii += 1;
    }
    recoverFinalize(p, pProbe);
    if !zTbl.is_null() {
        let mut zSep: *const libc::c_char = 0 as *const libc::c_char;
        let mut zField: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
        zSep = b"rootpgno INTEGER, pgno INTEGER, nfield INTEGER, id INTEGER, \0"
            as *const u8 as *const libc::c_char;
        ii = 0 as libc::c_int;
        while (*p).errCode == 0 as libc::c_int && ii < nField {
            zField = recoverMPrintf(
                p,
                b"%z%sc%d\0" as *const u8 as *const libc::c_char,
                zField,
                zSep,
                ii,
            );
            zSep = b", \0" as *const u8 as *const libc::c_char;
            ii += 1;
        }
        zSql = recoverMPrintf(
            p,
            b"CREATE TABLE %s(%s)\0" as *const u8 as *const libc::c_char,
            zTbl,
            zField,
        );
        sqlite3_free(zField as *mut libc::c_void);
        recoverExec(p, (*p).dbOut, zSql);
        recoverSqlCallback(p, zSql);
        sqlite3_free(zSql as *mut libc::c_void);
    } else if (*p).errCode == 0 as libc::c_int {
        recoverError(
            p,
            1 as libc::c_int,
            b"failed to create %s output table\0" as *const u8 as *const libc::c_char,
            (*p).zLostAndFound,
        );
    }
    return zTbl;
}
unsafe extern "C" fn recoverLostAndFoundInsert(
    mut p: *mut sqlite3_recover,
    mut zTab: *const libc::c_char,
    mut nField: libc::c_int,
) -> *mut sqlite3_stmt {
    let mut nTotal: libc::c_int = nField + 4 as libc::c_int;
    let mut ii: libc::c_int = 0;
    let mut zBind: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut pRet: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    if ((*p).xSql).is_none() {
        ii = 0 as libc::c_int;
        while ii < nTotal {
            zBind = recoverMPrintf(
                p,
                b"%z%s?\0" as *const u8 as *const libc::c_char,
                zBind,
                if !zBind.is_null() {
                    b", \0" as *const u8 as *const libc::c_char
                } else {
                    b"\0" as *const u8 as *const libc::c_char
                },
                ii,
            );
            ii += 1;
        }
        pRet = recoverPreparePrintf(
            p,
            (*p).dbOut,
            b"INSERT INTO %s VALUES(%s)\0" as *const u8 as *const libc::c_char,
            zTab,
            zBind,
        );
    } else {
        let mut zSep: *const libc::c_char = b"\0" as *const u8 as *const libc::c_char;
        ii = 0 as libc::c_int;
        while ii < nTotal {
            zBind = recoverMPrintf(
                p,
                b"%z%squote(?)\0" as *const u8 as *const libc::c_char,
                zBind,
                zSep,
            );
            zSep = b"|| ', ' ||\0" as *const u8 as *const libc::c_char;
            ii += 1;
        }
        pRet = recoverPreparePrintf(
            p,
            (*p).dbOut,
            b"SELECT 'INSERT INTO %s VALUES(' || %s || ')'\0" as *const u8
                as *const libc::c_char,
            zTab,
            zBind,
        );
    }
    sqlite3_free(zBind as *mut libc::c_void);
    return pRet;
}
unsafe extern "C" fn recoverLostAndFoundFindRoot(
    mut p: *mut sqlite3_recover,
    mut iPg: i64_0,
    mut piRoot: *mut i64_0,
) -> libc::c_int {
    let mut pLaf: *mut RecoverStateLAF = &mut (*p).laf;
    if ((*pLaf).pFindRoot).is_null() {
        let ref mut fresh240 = (*pLaf).pFindRoot;
        *fresh240 = recoverPrepare(
            p,
            (*p).dbOut,
            b"WITH RECURSIVE p(pgno) AS (  SELECT ?    UNION  SELECT parent FROM recovery.map AS m, p WHERE m.pgno=p.pgno) SELECT p.pgno FROM p, recovery.map m WHERE m.pgno=p.pgno     AND m.parent IS NULL\0"
                as *const u8 as *const libc::c_char,
        );
    }
    if (*p).errCode == 0 as libc::c_int {
        sqlite3_bind_int64((*pLaf).pFindRoot, 1 as libc::c_int, iPg);
        if sqlite3_step((*pLaf).pFindRoot) == 100 as libc::c_int {
            *piRoot = sqlite3_column_int64((*pLaf).pFindRoot, 0 as libc::c_int);
        } else {
            *piRoot = iPg;
        }
        recoverReset(p, (*pLaf).pFindRoot);
    }
    return (*p).errCode;
}
unsafe extern "C" fn recoverLostAndFoundOnePage(
    mut p: *mut sqlite3_recover,
    mut iPage: i64_0,
) {
    let mut pLaf: *mut RecoverStateLAF = &mut (*p).laf;
    let mut apVal: *mut *mut sqlite3_value = (*pLaf).apVal;
    let mut pPageData: *mut sqlite3_stmt = (*pLaf).pPageData;
    let mut pInsert: *mut sqlite3_stmt = (*pLaf).pInsert;
    let mut nVal: libc::c_int = -(1 as libc::c_int);
    let mut iPrevCell: libc::c_int = 0 as libc::c_int;
    let mut iRoot: i64_0 = 0 as libc::c_int as i64_0;
    let mut bHaveRowid: libc::c_int = 0 as libc::c_int;
    let mut iRowid: i64_0 = 0 as libc::c_int as i64_0;
    let mut ii: libc::c_int = 0 as libc::c_int;
    if recoverLostAndFoundFindRoot(p, iPage, &mut iRoot) != 0 {
        return;
    }
    sqlite3_bind_int64(pPageData, 1 as libc::c_int, iPage);
    while (*p).errCode == 0 as libc::c_int
        && 100 as libc::c_int == sqlite3_step(pPageData)
    {
        let mut iCell: libc::c_int = sqlite3_column_int64(pPageData, 0 as libc::c_int)
            as libc::c_int;
        let mut iField: libc::c_int = sqlite3_column_int64(pPageData, 1 as libc::c_int)
            as libc::c_int;
        if iPrevCell != iCell && nVal >= 0 as libc::c_int {
            sqlite3_bind_int64(pInsert, 1 as libc::c_int, iRoot);
            sqlite3_bind_int64(pInsert, 2 as libc::c_int, iPage);
            sqlite3_bind_int(pInsert, 3 as libc::c_int, nVal);
            if bHaveRowid != 0 {
                sqlite3_bind_int64(pInsert, 4 as libc::c_int, iRowid);
            }
            ii = 0 as libc::c_int;
            while ii < nVal {
                recoverBindValue(
                    p,
                    pInsert,
                    5 as libc::c_int + ii,
                    *apVal.offset(ii as isize),
                );
                ii += 1;
            }
            if sqlite3_step(pInsert) == 100 as libc::c_int {
                recoverSqlCallback(
                    p,
                    sqlite3_column_text(pInsert, 0 as libc::c_int) as *const libc::c_char,
                );
            }
            recoverReset(p, pInsert);
            ii = 0 as libc::c_int;
            while ii < nVal {
                sqlite3_value_free(*apVal.offset(ii as isize));
                let ref mut fresh241 = *apVal.offset(ii as isize);
                *fresh241 = 0 as *mut sqlite3_value;
                ii += 1;
            }
            sqlite3_clear_bindings(pInsert);
            bHaveRowid = 0 as libc::c_int;
            nVal = -(1 as libc::c_int);
        }
        if iCell < 0 as libc::c_int {
            break;
        }
        if iField < 0 as libc::c_int {
            iRowid = sqlite3_column_int64(pPageData, 2 as libc::c_int);
            bHaveRowid = 1 as libc::c_int;
            nVal = 0 as libc::c_int;
        } else if iField < (*pLaf).nMaxField {
            let mut pVal: *mut sqlite3_value = sqlite3_column_value(
                pPageData,
                2 as libc::c_int,
            );
            let ref mut fresh242 = *apVal.offset(iField as isize);
            *fresh242 = sqlite3_value_dup(pVal);
            nVal = iField + 1 as libc::c_int;
            if (*apVal.offset(iField as isize)).is_null() {
                recoverError(p, 7 as libc::c_int, 0 as *const libc::c_char);
            }
        }
        iPrevCell = iCell;
    }
    recoverReset(p, pPageData);
    ii = 0 as libc::c_int;
    while ii < nVal {
        sqlite3_value_free(*apVal.offset(ii as isize));
        let ref mut fresh243 = *apVal.offset(ii as isize);
        *fresh243 = 0 as *mut sqlite3_value;
        ii += 1;
    }
}
unsafe extern "C" fn recoverLostAndFound3Step(
    mut p: *mut sqlite3_recover,
) -> libc::c_int {
    let mut pLaf: *mut RecoverStateLAF = &mut (*p).laf;
    if (*p).errCode == 0 as libc::c_int {
        if ((*pLaf).pInsert).is_null() {
            return 101 as libc::c_int
        } else {
            if (*p).errCode == 0 as libc::c_int {
                let mut res: libc::c_int = sqlite3_step((*pLaf).pAllPage);
                if res == 100 as libc::c_int {
                    let mut iPage: i64_0 = sqlite3_column_int64(
                        (*pLaf).pAllPage,
                        0 as libc::c_int,
                    );
                    if recoverBitmapQuery((*pLaf).pUsed, iPage) == 0 as libc::c_int {
                        recoverLostAndFoundOnePage(p, iPage);
                    }
                } else {
                    recoverReset(p, (*pLaf).pAllPage);
                    return 101 as libc::c_int;
                }
            }
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn recoverLostAndFound3Init(mut p: *mut sqlite3_recover) {
    let mut pLaf: *mut RecoverStateLAF = &mut (*p).laf;
    if (*pLaf).nMaxField > 0 as libc::c_int {
        let mut zTab: *mut libc::c_char = 0 as *mut libc::c_char;
        zTab = recoverLostAndFoundCreate(p, (*pLaf).nMaxField);
        let ref mut fresh244 = (*pLaf).pInsert;
        *fresh244 = recoverLostAndFoundInsert(p, zTab, (*pLaf).nMaxField);
        sqlite3_free(zTab as *mut libc::c_void);
        let ref mut fresh245 = (*pLaf).pAllPage;
        *fresh245 = recoverPreparePrintf(
            p,
            (*p).dbOut,
            b"WITH RECURSIVE seq(ii) AS (  SELECT 1 UNION ALL SELECT ii+1 FROM seq WHERE ii<%lld)SELECT ii FROM seq\0"
                as *const u8 as *const libc::c_char,
            (*p).laf.nPg,
        );
        let ref mut fresh246 = (*pLaf).pPageData;
        *fresh246 = recoverPrepare(
            p,
            (*p).dbOut,
            b"SELECT cell, field, value FROM sqlite_dbdata('getpage()') d WHERE d.pgno=? UNION ALL SELECT -1, -1, -1\0"
                as *const u8 as *const libc::c_char,
        );
        let ref mut fresh247 = (*pLaf).apVal;
        *fresh247 = recoverMalloc(
            p,
            ((*pLaf).nMaxField as libc::c_ulong)
                .wrapping_mul(
                    ::std::mem::size_of::<*mut sqlite3_value>() as libc::c_ulong,
                ) as i64_0,
        ) as *mut *mut sqlite3_value;
    }
}
unsafe extern "C" fn recoverWriteDataInit(mut p: *mut sqlite3_recover) -> libc::c_int {
    let mut p1: *mut RecoverStateW1 = &mut (*p).w1;
    let mut pTbl: *mut RecoverTable = 0 as *mut RecoverTable;
    let mut nByte: libc::c_int = 0 as libc::c_int;
    pTbl = (*p).pTblList;
    while !pTbl.is_null() {
        if (*pTbl).nCol > (*p1).nMax {
            (*p1).nMax = (*pTbl).nCol;
        }
        pTbl = (*pTbl).pNext;
    }
    nByte = (::std::mem::size_of::<*mut sqlite3_value>() as libc::c_ulong)
        .wrapping_mul(((*p1).nMax + 1 as libc::c_int) as libc::c_ulong) as libc::c_int;
    let ref mut fresh248 = (*p1).apVal;
    *fresh248 = recoverMalloc(p, nByte as i64_0) as *mut *mut sqlite3_value;
    if ((*p1).apVal).is_null() {
        return (*p).errCode;
    }
    let ref mut fresh249 = (*p1).pTbls;
    *fresh249 = recoverPrepare(
        p,
        (*p).dbOut,
        b"SELECT rootpage FROM recovery.schema   WHERE type='table' AND (sql NOT LIKE 'create virtual%')  ORDER BY (tbl_name='sqlite_sequence') ASC\0"
            as *const u8 as *const libc::c_char,
    );
    let ref mut fresh250 = (*p1).pSel;
    *fresh250 = recoverPrepare(
        p,
        (*p).dbOut,
        b"WITH RECURSIVE pages(page) AS (  SELECT ?1    UNION  SELECT child FROM sqlite_dbptr('getpage()'), pages     WHERE pgno=page) SELECT page, cell, field, value FROM sqlite_dbdata('getpage()') d, pages p WHERE p.page=d.pgno UNION ALL SELECT 0, 0, 0, 0\0"
            as *const u8 as *const libc::c_char,
    );
    return (*p).errCode;
}
unsafe extern "C" fn recoverWriteDataCleanup(mut p: *mut sqlite3_recover) {
    let mut p1: *mut RecoverStateW1 = &mut (*p).w1;
    let mut ii: libc::c_int = 0;
    ii = 0 as libc::c_int;
    while ii < (*p1).nVal {
        sqlite3_value_free(*((*p1).apVal).offset(ii as isize));
        ii += 1;
    }
    sqlite3_free((*p1).apVal as *mut libc::c_void);
    recoverFinalize(p, (*p1).pInsert);
    recoverFinalize(p, (*p1).pTbls);
    recoverFinalize(p, (*p1).pSel);
    memset(
        p1 as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<RecoverStateW1>() as libc::c_ulong,
    );
}
unsafe extern "C" fn recoverWriteDataStep(mut p: *mut sqlite3_recover) -> libc::c_int {
    let mut p1: *mut RecoverStateW1 = &mut (*p).w1;
    let mut pSel: *mut sqlite3_stmt = (*p1).pSel;
    let mut apVal: *mut *mut sqlite3_value = (*p1).apVal;
    if (*p).errCode == 0 as libc::c_int && ((*p1).pTab).is_null() {
        if sqlite3_step((*p1).pTbls) == 100 as libc::c_int {
            let mut iRoot: i64_0 = sqlite3_column_int64((*p1).pTbls, 0 as libc::c_int);
            let ref mut fresh251 = (*p1).pTab;
            *fresh251 = recoverFindTable(p, iRoot as u32_0);
            recoverFinalize(p, (*p1).pInsert);
            let ref mut fresh252 = (*p1).pInsert;
            *fresh252 = 0 as *mut sqlite3_stmt;
            if ((*p1).pTab).is_null() {
                return (*p).errCode;
            }
            if sqlite3_stricmp(
                b"sqlite_sequence\0" as *const u8 as *const libc::c_char,
                (*(*p1).pTab).zTab,
            ) == 0 as libc::c_int
            {
                recoverExec(
                    p,
                    (*p).dbOut,
                    b"DELETE FROM sqlite_sequence\0" as *const u8 as *const libc::c_char,
                );
                recoverSqlCallback(
                    p,
                    b"DELETE FROM sqlite_sequence\0" as *const u8 as *const libc::c_char,
                );
            }
            sqlite3_bind_int64(pSel, 1 as libc::c_int, iRoot);
            (*p1).nVal = 0 as libc::c_int;
            (*p1).bHaveRowid = 0 as libc::c_int;
            (*p1).iPrevPage = -(1 as libc::c_int) as i64_0;
            (*p1).iPrevCell = -(1 as libc::c_int);
        } else {
            return 101 as libc::c_int
        }
    }
    if (*p).errCode == 0 as libc::c_int && sqlite3_step(pSel) == 100 as libc::c_int {
        let mut pTab: *mut RecoverTable = (*p1).pTab;
        let mut iPage: i64_0 = sqlite3_column_int64(pSel, 0 as libc::c_int);
        let mut iCell: libc::c_int = sqlite3_column_int(pSel, 1 as libc::c_int);
        let mut iField: libc::c_int = sqlite3_column_int(pSel, 2 as libc::c_int);
        let mut pVal: *mut sqlite3_value = sqlite3_column_value(pSel, 3 as libc::c_int);
        let mut bNewCell: libc::c_int = ((*p1).iPrevPage != iPage
            || (*p1).iPrevCell != iCell) as libc::c_int;
        if bNewCell != 0 {
            let mut ii: libc::c_int = 0 as libc::c_int;
            if (*p1).nVal >= 0 as libc::c_int {
                if ((*p1).pInsert).is_null() || (*p1).nVal != (*p1).nInsert {
                    recoverFinalize(p, (*p1).pInsert);
                    let ref mut fresh253 = (*p1).pInsert;
                    *fresh253 = recoverInsertStmt(p, pTab, (*p1).nVal);
                    (*p1).nInsert = (*p1).nVal;
                }
                if (*p1).nVal > 0 as libc::c_int {
                    let mut pInsert: *mut sqlite3_stmt = (*p1).pInsert;
                    ii = 0 as libc::c_int;
                    while ii < (*pTab).nCol {
                        let mut pCol: *mut RecoverColumn = &mut *((*pTab).aCol)
                            .offset(ii as isize) as *mut RecoverColumn;
                        let mut iBind: libc::c_int = (*pCol).iBind;
                        if iBind > 0 as libc::c_int {
                            if (*pCol).bIPK != 0 {
                                sqlite3_bind_int64(pInsert, iBind, (*p1).iRowid);
                            } else if (*pCol).iField < (*p1).nVal {
                                recoverBindValue(
                                    p,
                                    pInsert,
                                    iBind,
                                    *apVal.offset((*pCol).iField as isize),
                                );
                            }
                        }
                        ii += 1;
                    }
                    if (*p).bRecoverRowid != 0 && (*pTab).iRowidBind > 0 as libc::c_int
                        && (*p1).bHaveRowid != 0
                    {
                        sqlite3_bind_int64(pInsert, (*pTab).iRowidBind, (*p1).iRowid);
                    }
                    if 100 as libc::c_int == sqlite3_step(pInsert) {
                        let mut z: *const libc::c_char = sqlite3_column_text(
                            pInsert,
                            0 as libc::c_int,
                        ) as *const libc::c_char;
                        recoverSqlCallback(p, z);
                    }
                    recoverReset(p, pInsert);
                    if !pInsert.is_null() {
                        sqlite3_clear_bindings(pInsert);
                    }
                }
            }
            ii = 0 as libc::c_int;
            while ii < (*p1).nVal {
                sqlite3_value_free(*apVal.offset(ii as isize));
                let ref mut fresh254 = *apVal.offset(ii as isize);
                *fresh254 = 0 as *mut sqlite3_value;
                ii += 1;
            }
            (*p1).nVal = -(1 as libc::c_int);
            (*p1).bHaveRowid = 0 as libc::c_int;
        }
        if iPage != 0 as libc::c_int as libc::c_longlong {
            if iField < 0 as libc::c_int {
                (*p1).iRowid = sqlite3_column_int64(pSel, 3 as libc::c_int);
                (*p1).nVal = 0 as libc::c_int;
                (*p1).bHaveRowid = 1 as libc::c_int;
            } else if iField < (*pTab).nCol {
                let ref mut fresh255 = *apVal.offset(iField as isize);
                *fresh255 = sqlite3_value_dup(pVal);
                if (*apVal.offset(iField as isize)).is_null() {
                    recoverError(p, 7 as libc::c_int, 0 as *const libc::c_char);
                }
                (*p1).nVal = iField + 1 as libc::c_int;
            }
            (*p1).iPrevCell = iCell;
            (*p1).iPrevPage = iPage;
        }
    } else {
        recoverReset(p, pSel);
        let ref mut fresh256 = (*p1).pTab;
        *fresh256 = 0 as *mut RecoverTable;
    }
    return (*p).errCode;
}
unsafe extern "C" fn recoverLostAndFound1Init(mut p: *mut sqlite3_recover) {
    let mut pLaf: *mut RecoverStateLAF = &mut (*p).laf;
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    (*pLaf).nPg = recoverPageCount(p);
    let ref mut fresh257 = (*pLaf).pUsed;
    *fresh257 = recoverBitmapAlloc(p, (*pLaf).nPg);
    pStmt = recoverPrepare(
        p,
        (*p).dbOut,
        b"WITH trunk(pgno) AS (  SELECT read_i32(getpage(1), 8) AS x WHERE x>0    UNION  SELECT read_i32(getpage(trunk.pgno), 0) AS x FROM trunk WHERE x>0),trunkdata(pgno, data) AS (  SELECT pgno, getpage(pgno) FROM trunk),freelist(data, n, freepgno) AS (  SELECT data, min(16384, read_i32(data, 1)-1), pgno FROM trunkdata    UNION ALL  SELECT data, n-1, read_i32(data, 2+n) FROM freelist WHERE n>=0),roots(r) AS (  SELECT 1 UNION ALL  SELECT rootpage FROM recovery.schema WHERE rootpage>0),used(page) AS (  SELECT r FROM roots    UNION  SELECT child FROM sqlite_dbptr('getpage()'), used     WHERE pgno=page) SELECT page FROM used UNION ALL SELECT freepgno FROM freelist WHERE NOT ?\0"
            as *const u8 as *const libc::c_char,
    );
    if !pStmt.is_null() {
        sqlite3_bind_int(pStmt, 1 as libc::c_int, (*p).bFreelistCorrupt);
    }
    let ref mut fresh258 = (*pLaf).pUsedPages;
    *fresh258 = pStmt;
}
unsafe extern "C" fn recoverLostAndFound1Step(
    mut p: *mut sqlite3_recover,
) -> libc::c_int {
    let mut pLaf: *mut RecoverStateLAF = &mut (*p).laf;
    let mut rc: libc::c_int = (*p).errCode;
    if rc == 0 as libc::c_int {
        rc = sqlite3_step((*pLaf).pUsedPages);
        if rc == 100 as libc::c_int {
            let mut iPg: i64_0 = sqlite3_column_int64(
                (*pLaf).pUsedPages,
                0 as libc::c_int,
            );
            recoverBitmapSet((*pLaf).pUsed, iPg);
            rc = 0 as libc::c_int;
        } else {
            recoverFinalize(p, (*pLaf).pUsedPages);
            let ref mut fresh259 = (*pLaf).pUsedPages;
            *fresh259 = 0 as *mut sqlite3_stmt;
        }
    }
    return rc;
}
unsafe extern "C" fn recoverLostAndFound2Init(mut p: *mut sqlite3_recover) {
    let mut pLaf: *mut RecoverStateLAF = &mut (*p).laf;
    let ref mut fresh260 = (*pLaf).pMapInsert;
    *fresh260 = recoverPrepare(
        p,
        (*p).dbOut,
        b"INSERT OR IGNORE INTO recovery.map(pgno, parent) VALUES(?, ?)\0" as *const u8
            as *const libc::c_char,
    );
    let ref mut fresh261 = (*pLaf).pAllAndParent;
    *fresh261 = recoverPreparePrintf(
        p,
        (*p).dbOut,
        b"WITH RECURSIVE seq(ii) AS (  SELECT 1 UNION ALL SELECT ii+1 FROM seq WHERE ii<%lld)SELECT pgno, child FROM sqlite_dbptr('getpage()')  UNION ALL SELECT NULL, ii FROM seq\0"
            as *const u8 as *const libc::c_char,
        (*p).laf.nPg,
    );
    let ref mut fresh262 = (*pLaf).pMaxField;
    *fresh262 = recoverPreparePrintf(
        p,
        (*p).dbOut,
        b"SELECT max(field)+1 FROM sqlite_dbdata('getpage') WHERE pgno = ?\0"
            as *const u8 as *const libc::c_char,
    );
}
unsafe extern "C" fn recoverLostAndFound2Step(
    mut p: *mut sqlite3_recover,
) -> libc::c_int {
    let mut pLaf: *mut RecoverStateLAF = &mut (*p).laf;
    if (*p).errCode == 0 as libc::c_int {
        let mut res: libc::c_int = sqlite3_step((*pLaf).pAllAndParent);
        if res == 100 as libc::c_int {
            let mut iChild: i64_0 = sqlite3_column_int(
                (*pLaf).pAllAndParent,
                1 as libc::c_int,
            ) as i64_0;
            if recoverBitmapQuery((*pLaf).pUsed, iChild) == 0 as libc::c_int {
                sqlite3_bind_int64((*pLaf).pMapInsert, 1 as libc::c_int, iChild);
                sqlite3_bind_value(
                    (*pLaf).pMapInsert,
                    2 as libc::c_int,
                    sqlite3_column_value((*pLaf).pAllAndParent, 0 as libc::c_int),
                );
                sqlite3_step((*pLaf).pMapInsert);
                recoverReset(p, (*pLaf).pMapInsert);
                sqlite3_bind_int64((*pLaf).pMaxField, 1 as libc::c_int, iChild);
                if 100 as libc::c_int == sqlite3_step((*pLaf).pMaxField) {
                    let mut nMax: libc::c_int = sqlite3_column_int(
                        (*pLaf).pMaxField,
                        0 as libc::c_int,
                    );
                    if nMax > (*pLaf).nMaxField {
                        (*pLaf).nMaxField = nMax;
                    }
                }
                recoverReset(p, (*pLaf).pMaxField);
            }
        } else {
            recoverFinalize(p, (*pLaf).pAllAndParent);
            let ref mut fresh263 = (*pLaf).pAllAndParent;
            *fresh263 = 0 as *mut sqlite3_stmt;
            return 101 as libc::c_int;
        }
    }
    return (*p).errCode;
}
unsafe extern "C" fn recoverLostAndFoundCleanup(mut p: *mut sqlite3_recover) {
    recoverBitmapFree((*p).laf.pUsed);
    let ref mut fresh264 = (*p).laf.pUsed;
    *fresh264 = 0 as *mut RecoverBitmap;
    sqlite3_finalize((*p).laf.pUsedPages);
    sqlite3_finalize((*p).laf.pAllAndParent);
    sqlite3_finalize((*p).laf.pMapInsert);
    sqlite3_finalize((*p).laf.pMaxField);
    sqlite3_finalize((*p).laf.pFindRoot);
    sqlite3_finalize((*p).laf.pInsert);
    sqlite3_finalize((*p).laf.pAllPage);
    sqlite3_finalize((*p).laf.pPageData);
    let ref mut fresh265 = (*p).laf.pUsedPages;
    *fresh265 = 0 as *mut sqlite3_stmt;
    let ref mut fresh266 = (*p).laf.pAllAndParent;
    *fresh266 = 0 as *mut sqlite3_stmt;
    let ref mut fresh267 = (*p).laf.pMapInsert;
    *fresh267 = 0 as *mut sqlite3_stmt;
    let ref mut fresh268 = (*p).laf.pMaxField;
    *fresh268 = 0 as *mut sqlite3_stmt;
    let ref mut fresh269 = (*p).laf.pFindRoot;
    *fresh269 = 0 as *mut sqlite3_stmt;
    let ref mut fresh270 = (*p).laf.pInsert;
    *fresh270 = 0 as *mut sqlite3_stmt;
    let ref mut fresh271 = (*p).laf.pAllPage;
    *fresh271 = 0 as *mut sqlite3_stmt;
    let ref mut fresh272 = (*p).laf.pPageData;
    *fresh272 = 0 as *mut sqlite3_stmt;
    sqlite3_free((*p).laf.apVal as *mut libc::c_void);
    let ref mut fresh273 = (*p).laf.apVal;
    *fresh273 = 0 as *mut *mut sqlite3_value;
}
unsafe extern "C" fn recoverFinalCleanup(mut p: *mut sqlite3_recover) {
    let mut pTab: *mut RecoverTable = 0 as *mut RecoverTable;
    let mut pNext: *mut RecoverTable = 0 as *mut RecoverTable;
    recoverWriteDataCleanup(p);
    recoverLostAndFoundCleanup(p);
    pTab = (*p).pTblList;
    while !pTab.is_null() {
        pNext = (*pTab).pNext;
        sqlite3_free(pTab as *mut libc::c_void);
        pTab = pNext;
    }
    let ref mut fresh274 = (*p).pTblList;
    *fresh274 = 0 as *mut RecoverTable;
    sqlite3_finalize((*p).pGetPage);
    let ref mut fresh275 = (*p).pGetPage;
    *fresh275 = 0 as *mut sqlite3_stmt;
    sqlite3_file_control((*p).dbIn, (*p).zDb, 42 as libc::c_int, 0 as *mut libc::c_void);
    sqlite3_close((*p).dbOut);
    let ref mut fresh276 = (*p).dbOut;
    *fresh276 = 0 as *mut sqlite3;
}
unsafe extern "C" fn recoverGetU16(mut a: *const u8_0) -> u32_0 {
    return ((*a.offset(0 as libc::c_int as isize) as u32_0) << 8 as libc::c_int)
        .wrapping_add(*a.offset(1 as libc::c_int as isize) as u32_0);
}
unsafe extern "C" fn recoverGetU32(mut a: *const u8_0) -> u32_0 {
    return ((*a.offset(0 as libc::c_int as isize) as u32_0) << 24 as libc::c_int)
        .wrapping_add(
            (*a.offset(1 as libc::c_int as isize) as u32_0) << 16 as libc::c_int,
        )
        .wrapping_add(
            (*a.offset(2 as libc::c_int as isize) as u32_0) << 8 as libc::c_int,
        )
        .wrapping_add(*a.offset(3 as libc::c_int as isize) as u32_0);
}
unsafe extern "C" fn recoverGetVarint(
    mut a: *const u8_0,
    mut pVal: *mut i64_0,
) -> libc::c_int {
    let mut u: sqlite3_uint64 = 0 as libc::c_int as sqlite3_uint64;
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < 8 as libc::c_int {
        u = (u << 7 as libc::c_int)
            .wrapping_add(
                (*a.offset(i as isize) as libc::c_int & 0x7f as libc::c_int)
                    as libc::c_ulonglong,
            );
        if *a.offset(i as isize) as libc::c_int & 0x80 as libc::c_int == 0 as libc::c_int
        {
            *pVal = u as sqlite3_int64;
            return i + 1 as libc::c_int;
        }
        i += 1;
    }
    u = (u << 8 as libc::c_int)
        .wrapping_add(
            (*a.offset(i as isize) as libc::c_int & 0xff as libc::c_int)
                as libc::c_ulonglong,
        );
    *pVal = u as sqlite3_int64;
    return 9 as libc::c_int;
}
unsafe extern "C" fn recoverIsValidPage(
    mut aTmp: *mut u8_0,
    mut a: *const u8_0,
    mut n: libc::c_int,
) -> libc::c_int {
    let mut aUsed: *mut u8_0 = aTmp;
    let mut nFrag: libc::c_int = 0 as libc::c_int;
    let mut nActual: libc::c_int = 0 as libc::c_int;
    let mut iFree: libc::c_int = 0 as libc::c_int;
    let mut nCell: libc::c_int = 0 as libc::c_int;
    let mut iCellOff: libc::c_int = 0 as libc::c_int;
    let mut iContent: libc::c_int = 0 as libc::c_int;
    let mut eType: libc::c_int = 0 as libc::c_int;
    let mut ii: libc::c_int = 0 as libc::c_int;
    eType = *a.offset(0 as libc::c_int as isize) as libc::c_int;
    if eType != 0x2 as libc::c_int && eType != 0x5 as libc::c_int
        && eType != 0xa as libc::c_int && eType != 0xd as libc::c_int
    {
        return 0 as libc::c_int;
    }
    iFree = recoverGetU16(&*a.offset(1 as libc::c_int as isize)) as libc::c_int;
    nCell = recoverGetU16(&*a.offset(3 as libc::c_int as isize)) as libc::c_int;
    iContent = recoverGetU16(&*a.offset(5 as libc::c_int as isize)) as libc::c_int;
    if iContent == 0 as libc::c_int {
        iContent = 65536 as libc::c_int;
    }
    nFrag = *a.offset(7 as libc::c_int as isize) as libc::c_int;
    if iContent > n {
        return 0 as libc::c_int;
    }
    memset(aUsed as *mut libc::c_void, 0 as libc::c_int, n as libc::c_ulong);
    memset(aUsed as *mut libc::c_void, 0xff as libc::c_int, iContent as libc::c_ulong);
    if iFree != 0 && iFree <= iContent {
        return 0 as libc::c_int;
    }
    while iFree != 0 {
        let mut iNext: libc::c_int = 0 as libc::c_int;
        let mut nByte: libc::c_int = 0 as libc::c_int;
        if iFree > n - 4 as libc::c_int {
            return 0 as libc::c_int;
        }
        iNext = recoverGetU16(&*a.offset(iFree as isize)) as libc::c_int;
        nByte = recoverGetU16(&*a.offset((iFree + 2 as libc::c_int) as isize))
            as libc::c_int;
        if iFree + nByte > n {
            return 0 as libc::c_int;
        }
        if iNext != 0 && iNext < iFree + nByte {
            return 0 as libc::c_int;
        }
        memset(
            &mut *aUsed.offset(iFree as isize) as *mut u8_0 as *mut libc::c_void,
            0xff as libc::c_int,
            nByte as libc::c_ulong,
        );
        iFree = iNext;
    }
    if eType == 0x2 as libc::c_int || eType == 0x5 as libc::c_int {
        iCellOff = 12 as libc::c_int;
    } else {
        iCellOff = 8 as libc::c_int;
    }
    if iCellOff + 2 as libc::c_int * nCell > iContent {
        return 0 as libc::c_int;
    }
    ii = 0 as libc::c_int;
    while ii < nCell {
        let mut iByte: libc::c_int = 0;
        let mut nPayload: i64_0 = 0 as libc::c_int as i64_0;
        let mut nByte_0: libc::c_int = 0 as libc::c_int;
        let mut iOff: libc::c_int = recoverGetU16(
            &*a.offset((iCellOff + 2 as libc::c_int * ii) as isize),
        ) as libc::c_int;
        if iOff < iContent || iOff > n {
            return 0 as libc::c_int;
        }
        if eType == 0x5 as libc::c_int || eType == 0x2 as libc::c_int {
            nByte_0 += 4 as libc::c_int;
        }
        nByte_0
            += recoverGetVarint(&*a.offset((iOff + nByte_0) as isize), &mut nPayload);
        if eType == 0xd as libc::c_int {
            let mut dummy: i64_0 = 0 as libc::c_int as i64_0;
            nByte_0
                += recoverGetVarint(&*a.offset((iOff + nByte_0) as isize), &mut dummy);
        }
        if eType != 0x5 as libc::c_int {
            let mut X: libc::c_int = if eType == 0xd as libc::c_int {
                n - 35 as libc::c_int
            } else {
                (n - 12 as libc::c_int) * 64 as libc::c_int / 255 as libc::c_int
                    - 23 as libc::c_int
            };
            let mut M: libc::c_int = (n - 12 as libc::c_int) * 32 as libc::c_int
                / 255 as libc::c_int - 23 as libc::c_int;
            let mut K: libc::c_int = (M as libc::c_longlong
                + (nPayload - M as libc::c_longlong)
                    % (n - 4 as libc::c_int) as libc::c_longlong) as libc::c_int;
            if nPayload < X as libc::c_longlong {
                nByte_0 = (nByte_0 as libc::c_longlong + nPayload) as libc::c_int;
            } else if K <= X {
                nByte_0 += K + 4 as libc::c_int;
            } else {
                nByte_0 += M + 4 as libc::c_int;
            }
        }
        if iOff + nByte_0 > n {
            return 0 as libc::c_int;
        }
        iByte = iOff;
        while iByte < iOff + nByte_0 {
            if *aUsed.offset(iByte as isize) as libc::c_int != 0 as libc::c_int {
                return 0 as libc::c_int;
            }
            *aUsed.offset(iByte as isize) = 0xff as libc::c_int as u8_0;
            iByte += 1;
        }
        ii += 1;
    }
    nActual = 0 as libc::c_int;
    ii = 0 as libc::c_int;
    while ii < n {
        if *aUsed.offset(ii as isize) as libc::c_int == 0 as libc::c_int {
            nActual += 1;
        }
        ii += 1;
    }
    return (nActual == nFrag) as libc::c_int;
}
static mut recover_methods: sqlite3_io_methods = unsafe {
    {
        let mut init = sqlite3_io_methods {
            iVersion: 2 as libc::c_int,
            xClose: Some(
                recoverVfsClose as unsafe extern "C" fn(*mut sqlite3_file) -> libc::c_int,
            ),
            xRead: Some(
                recoverVfsRead
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        *mut libc::c_void,
                        libc::c_int,
                        sqlite3_int64,
                    ) -> libc::c_int,
            ),
            xWrite: Some(
                recoverVfsWrite
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        *const libc::c_void,
                        libc::c_int,
                        sqlite3_int64,
                    ) -> libc::c_int,
            ),
            xTruncate: Some(
                recoverVfsTruncate
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        sqlite3_int64,
                    ) -> libc::c_int,
            ),
            xSync: Some(
                recoverVfsSync
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            xFileSize: Some(
                recoverVfsFileSize
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        *mut sqlite3_int64,
                    ) -> libc::c_int,
            ),
            xLock: Some(
                recoverVfsLock
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            xUnlock: Some(
                recoverVfsUnlock
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            xCheckReservedLock: Some(
                recoverVfsCheckReservedLock
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        *mut libc::c_int,
                    ) -> libc::c_int,
            ),
            xFileControl: Some(
                recoverVfsFileControl
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        libc::c_int,
                        *mut libc::c_void,
                    ) -> libc::c_int,
            ),
            xSectorSize: Some(
                recoverVfsSectorSize
                    as unsafe extern "C" fn(*mut sqlite3_file) -> libc::c_int,
            ),
            xDeviceCharacteristics: Some(
                recoverVfsDeviceCharacteristics
                    as unsafe extern "C" fn(*mut sqlite3_file) -> libc::c_int,
            ),
            xShmMap: Some(
                recoverVfsShmMap
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        libc::c_int,
                        libc::c_int,
                        libc::c_int,
                        *mut *mut libc::c_void,
                    ) -> libc::c_int,
            ),
            xShmLock: Some(
                recoverVfsShmLock
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        libc::c_int,
                        libc::c_int,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            xShmBarrier: Some(
                recoverVfsShmBarrier as unsafe extern "C" fn(*mut sqlite3_file) -> (),
            ),
            xShmUnmap: Some(
                recoverVfsShmUnmap
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            xFetch: Some(
                recoverVfsFetch
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        sqlite3_int64,
                        libc::c_int,
                        *mut *mut libc::c_void,
                    ) -> libc::c_int,
            ),
            xUnfetch: Some(
                recoverVfsUnfetch
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        sqlite3_int64,
                        *mut libc::c_void,
                    ) -> libc::c_int,
            ),
        };
        init
    }
};
unsafe extern "C" fn recoverVfsClose(mut pFd: *mut sqlite3_file) -> libc::c_int {
    return ((*(*pFd).pMethods).xClose).expect("non-null function pointer")(pFd);
}
unsafe extern "C" fn recoverPutU16(mut a: *mut u8_0, mut v: u32_0) {
    *a
        .offset(
            0 as libc::c_int as isize,
        ) = (v >> 8 as libc::c_int & 0xff as libc::c_int as libc::c_uint) as u8_0;
    *a
        .offset(
            1 as libc::c_int as isize,
        ) = (v >> 0 as libc::c_int & 0xff as libc::c_int as libc::c_uint) as u8_0;
}
unsafe extern "C" fn recoverPutU32(mut a: *mut u8_0, mut v: u32_0) {
    *a
        .offset(
            0 as libc::c_int as isize,
        ) = (v >> 24 as libc::c_int & 0xff as libc::c_int as libc::c_uint) as u8_0;
    *a
        .offset(
            1 as libc::c_int as isize,
        ) = (v >> 16 as libc::c_int & 0xff as libc::c_int as libc::c_uint) as u8_0;
    *a
        .offset(
            2 as libc::c_int as isize,
        ) = (v >> 8 as libc::c_int & 0xff as libc::c_int as libc::c_uint) as u8_0;
    *a
        .offset(
            3 as libc::c_int as isize,
        ) = (v >> 0 as libc::c_int & 0xff as libc::c_int as libc::c_uint) as u8_0;
}
unsafe extern "C" fn recoverVfsDetectPagesize(
    mut p: *mut sqlite3_recover,
    mut pFd: *mut sqlite3_file,
    mut nReserve: u32_0,
    mut nSz: i64_0,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let nMin: libc::c_int = 512 as libc::c_int;
    let nMax: libc::c_int = 65536 as libc::c_int;
    let nMaxBlk: libc::c_int = 4 as libc::c_int;
    let mut pgsz: u32_0 = 0 as libc::c_int as u32_0;
    let mut iBlk: libc::c_int = 0 as libc::c_int;
    let mut aPg: *mut u8_0 = 0 as *mut u8_0;
    let mut aTmp: *mut u8_0 = 0 as *mut u8_0;
    let mut nBlk: libc::c_int = 0 as libc::c_int;
    aPg = sqlite3_malloc(2 as libc::c_int * nMax) as *mut u8_0;
    if aPg.is_null() {
        return 7 as libc::c_int;
    }
    aTmp = &mut *aPg.offset(nMax as isize) as *mut u8_0;
    nBlk = ((nSz + nMax as libc::c_longlong - 1 as libc::c_int as libc::c_longlong)
        / nMax as libc::c_longlong) as libc::c_int;
    if nBlk > nMaxBlk {
        nBlk = nMaxBlk;
    }
    loop {
        iBlk = 0 as libc::c_int;
        while rc == 0 as libc::c_int && iBlk < nBlk {
            let mut nByte: libc::c_int = (if nSz
                >= ((iBlk + 1 as libc::c_int) * nMax) as libc::c_longlong
            {
                nMax as libc::c_longlong
            } else {
                nSz % nMax as libc::c_longlong
            }) as libc::c_int;
            memset(aPg as *mut libc::c_void, 0 as libc::c_int, nMax as libc::c_ulong);
            rc = ((*(*pFd).pMethods).xRead)
                .expect(
                    "non-null function pointer",
                )(pFd, aPg as *mut libc::c_void, nByte, (iBlk * nMax) as sqlite3_int64);
            if rc == 0 as libc::c_int {
                let mut pgsz2: libc::c_int = 0;
                pgsz2 = (if pgsz != 0 {
                    pgsz.wrapping_mul(2 as libc::c_int as libc::c_uint)
                } else {
                    nMin as libc::c_uint
                }) as libc::c_int;
                while pgsz2 <= nMax {
                    let mut iOff: libc::c_int = 0;
                    iOff = 0 as libc::c_int;
                    while iOff < nMax {
                        if recoverIsValidPage(
                            aTmp,
                            &mut *aPg.offset(iOff as isize),
                            (pgsz2 as libc::c_uint).wrapping_sub(nReserve) as libc::c_int,
                        ) != 0
                        {
                            pgsz = pgsz2 as u32_0;
                            break;
                        } else {
                            iOff += pgsz2;
                        }
                    }
                    pgsz2 = pgsz2 * 2 as libc::c_int;
                }
            }
            iBlk += 1;
        }
        if pgsz > (*p).detected_pgsz as u32_0 {
            (*p).detected_pgsz = pgsz as libc::c_int;
            (*p).nReserve = nReserve as libc::c_int;
        }
        if nReserve == 0 as libc::c_int as libc::c_uint {
            break;
        }
        nReserve = 0 as libc::c_int as u32_0;
    }
    (*p).detected_pgsz = pgsz as libc::c_int;
    sqlite3_free(aPg as *mut libc::c_void);
    return rc;
}
unsafe extern "C" fn recoverVfsRead(
    mut pFd: *mut sqlite3_file,
    mut aBuf: *mut libc::c_void,
    mut nByte: libc::c_int,
    mut iOff: i64_0,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (*pFd).pMethods
        == &mut recover_methods as *mut sqlite3_io_methods as *const sqlite3_io_methods
    {
        let ref mut fresh277 = (*pFd).pMethods;
        *fresh277 = recover_g.pMethods;
        rc = ((*(*pFd).pMethods).xRead)
            .expect("non-null function pointer")(pFd, aBuf, nByte, iOff);
        if nByte == 16 as libc::c_int {
            sqlite3_randomness(16 as libc::c_int, aBuf);
        } else if rc == 0 as libc::c_int && iOff == 0 as libc::c_int as libc::c_longlong
            && nByte >= 108 as libc::c_int
        {
            let aPreserve: [libc::c_int; 6] = [
                32 as libc::c_int,
                36 as libc::c_int,
                52 as libc::c_int,
                60 as libc::c_int,
                64 as libc::c_int,
                68 as libc::c_int,
            ];
            let mut aHdr: [u8_0; 108] = [
                0x53 as libc::c_int as u8_0,
                0x51 as libc::c_int as u8_0,
                0x4c as libc::c_int as u8_0,
                0x69 as libc::c_int as u8_0,
                0x74 as libc::c_int as u8_0,
                0x65 as libc::c_int as u8_0,
                0x20 as libc::c_int as u8_0,
                0x66 as libc::c_int as u8_0,
                0x6f as libc::c_int as u8_0,
                0x72 as libc::c_int as u8_0,
                0x6d as libc::c_int as u8_0,
                0x61 as libc::c_int as u8_0,
                0x74 as libc::c_int as u8_0,
                0x20 as libc::c_int as u8_0,
                0x33 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0x1 as libc::c_int as u8_0,
                0x1 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0x40 as libc::c_int as u8_0,
                0x20 as libc::c_int as u8_0,
                0x20 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0x4 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0x10 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0x2e as libc::c_int as u8_0,
                0x5b as libc::c_int as u8_0,
                0x30 as libc::c_int as u8_0,
                0xd as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
            ];
            let mut a: *mut u8_0 = aBuf as *mut u8_0;
            let mut pgsz: u32_0 = recoverGetU16(
                &mut *a.offset(16 as libc::c_int as isize),
            );
            let mut nReserve: u32_0 = *a.offset(20 as libc::c_int as isize) as u32_0;
            let mut enc: u32_0 = recoverGetU32(
                &mut *a.offset(56 as libc::c_int as isize),
            );
            let mut dbsz: u32_0 = 0 as libc::c_int as u32_0;
            let mut dbFileSize: i64_0 = 0 as libc::c_int as i64_0;
            let mut ii: libc::c_int = 0;
            let mut p: *mut sqlite3_recover = recover_g.p;
            if pgsz == 0x1 as libc::c_int as libc::c_uint {
                pgsz = 65536 as libc::c_int as u32_0;
            }
            rc = ((*(*pFd).pMethods).xFileSize)
                .expect("non-null function pointer")(pFd, &mut dbFileSize);
            if rc == 0 as libc::c_int && (*p).detected_pgsz == 0 as libc::c_int {
                rc = recoverVfsDetectPagesize(p, pFd, nReserve, dbFileSize);
            }
            if (*p).detected_pgsz != 0 {
                pgsz = (*p).detected_pgsz as u32_0;
                nReserve = (*p).nReserve as u32_0;
            }
            if pgsz != 0 {
                dbsz = (dbFileSize / pgsz as libc::c_longlong) as u32_0;
            }
            if enc != 1 as libc::c_int as libc::c_uint
                && enc != 3 as libc::c_int as libc::c_uint
                && enc != 2 as libc::c_int as libc::c_uint
            {
                enc = 1 as libc::c_int as u32_0;
            }
            sqlite3_free((*p).pPage1Cache as *mut libc::c_void);
            let ref mut fresh278 = (*p).pPage1Cache;
            *fresh278 = 0 as *mut u8_0;
            let ref mut fresh279 = (*p).pPage1Disk;
            *fresh279 = 0 as *mut u8_0;
            (*p).pgsz = nByte;
            let ref mut fresh280 = (*p).pPage1Cache;
            *fresh280 = recoverMalloc(p, (nByte * 2 as libc::c_int) as i64_0)
                as *mut u8_0;
            if !((*p).pPage1Cache).is_null() {
                let ref mut fresh281 = (*p).pPage1Disk;
                *fresh281 = &mut *((*p).pPage1Cache).offset(nByte as isize) as *mut u8_0;
                memcpy(
                    (*p).pPage1Disk as *mut libc::c_void,
                    aBuf,
                    nByte as libc::c_ulong,
                );
                aHdr[18 as libc::c_int as usize] = *a.offset(18 as libc::c_int as isize);
                aHdr[19 as libc::c_int as usize] = *a.offset(19 as libc::c_int as isize);
                recoverPutU32(
                    &mut *aHdr.as_mut_ptr().offset(28 as libc::c_int as isize),
                    dbsz,
                );
                recoverPutU32(
                    &mut *aHdr.as_mut_ptr().offset(56 as libc::c_int as isize),
                    enc,
                );
                recoverPutU16(
                    &mut *aHdr.as_mut_ptr().offset(105 as libc::c_int as isize),
                    pgsz.wrapping_sub(nReserve),
                );
                if pgsz == 65536 as libc::c_int as libc::c_uint {
                    pgsz = 1 as libc::c_int as u32_0;
                }
                recoverPutU16(
                    &mut *aHdr.as_mut_ptr().offset(16 as libc::c_int as isize),
                    pgsz,
                );
                aHdr[20 as libc::c_int as usize] = nReserve as u8_0;
                ii = 0 as libc::c_int;
                while (ii as libc::c_ulong)
                    < (::std::mem::size_of::<[libc::c_int; 6]>() as libc::c_ulong)
                        .wrapping_div(
                            ::std::mem::size_of::<libc::c_int>() as libc::c_ulong,
                        )
                {
                    memcpy(
                        &mut *aHdr
                            .as_mut_ptr()
                            .offset(*aPreserve.as_ptr().offset(ii as isize) as isize)
                            as *mut u8_0 as *mut libc::c_void,
                        &mut *a.offset(*aPreserve.as_ptr().offset(ii as isize) as isize)
                            as *mut u8_0 as *const libc::c_void,
                        4 as libc::c_int as libc::c_ulong,
                    );
                    ii += 1;
                }
                memcpy(
                    aBuf,
                    aHdr.as_mut_ptr() as *const libc::c_void,
                    ::std::mem::size_of::<[u8_0; 108]>() as libc::c_ulong,
                );
                memset(
                    &mut *(aBuf as *mut u8_0)
                        .offset(
                            ::std::mem::size_of::<[u8_0; 108]>() as libc::c_ulong
                                as isize,
                        ) as *mut u8_0 as *mut libc::c_void,
                    0 as libc::c_int,
                    (nByte as libc::c_ulong)
                        .wrapping_sub(
                            ::std::mem::size_of::<[u8_0; 108]>() as libc::c_ulong,
                        ),
                );
                memcpy(
                    (*p).pPage1Cache as *mut libc::c_void,
                    aBuf,
                    nByte as libc::c_ulong,
                );
            } else {
                rc = (*p).errCode;
            }
        }
        let ref mut fresh282 = (*pFd).pMethods;
        *fresh282 = &mut recover_methods;
    } else {
        rc = ((*(*pFd).pMethods).xRead)
            .expect("non-null function pointer")(pFd, aBuf, nByte, iOff);
    }
    return rc;
}
unsafe extern "C" fn recoverVfsWrite(
    mut pFd: *mut sqlite3_file,
    mut aBuf: *const libc::c_void,
    mut nByte: libc::c_int,
    mut iOff: i64_0,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (*pFd).pMethods
        == &mut recover_methods as *mut sqlite3_io_methods as *const sqlite3_io_methods
    {
        let ref mut fresh283 = (*pFd).pMethods;
        *fresh283 = recover_g.pMethods;
        rc = ((*(*pFd).pMethods).xWrite)
            .expect("non-null function pointer")(pFd, aBuf, nByte, iOff);
        let ref mut fresh284 = (*pFd).pMethods;
        *fresh284 = &mut recover_methods;
    } else {
        rc = ((*(*pFd).pMethods).xWrite)
            .expect("non-null function pointer")(pFd, aBuf, nByte, iOff);
    }
    return rc;
}
unsafe extern "C" fn recoverVfsTruncate(
    mut pFd: *mut sqlite3_file,
    mut size: sqlite3_int64,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (*pFd).pMethods
        == &mut recover_methods as *mut sqlite3_io_methods as *const sqlite3_io_methods
    {
        let ref mut fresh285 = (*pFd).pMethods;
        *fresh285 = recover_g.pMethods;
        rc = ((*(*pFd).pMethods).xTruncate)
            .expect("non-null function pointer")(pFd, size);
        let ref mut fresh286 = (*pFd).pMethods;
        *fresh286 = &mut recover_methods;
    } else {
        rc = ((*(*pFd).pMethods).xTruncate)
            .expect("non-null function pointer")(pFd, size);
    }
    return rc;
}
unsafe extern "C" fn recoverVfsSync(
    mut pFd: *mut sqlite3_file,
    mut flags: libc::c_int,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (*pFd).pMethods
        == &mut recover_methods as *mut sqlite3_io_methods as *const sqlite3_io_methods
    {
        let ref mut fresh287 = (*pFd).pMethods;
        *fresh287 = recover_g.pMethods;
        rc = ((*(*pFd).pMethods).xSync).expect("non-null function pointer")(pFd, flags);
        let ref mut fresh288 = (*pFd).pMethods;
        *fresh288 = &mut recover_methods;
    } else {
        rc = ((*(*pFd).pMethods).xSync).expect("non-null function pointer")(pFd, flags);
    }
    return rc;
}
unsafe extern "C" fn recoverVfsFileSize(
    mut pFd: *mut sqlite3_file,
    mut pSize: *mut sqlite3_int64,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (*pFd).pMethods
        == &mut recover_methods as *mut sqlite3_io_methods as *const sqlite3_io_methods
    {
        let ref mut fresh289 = (*pFd).pMethods;
        *fresh289 = recover_g.pMethods;
        rc = ((*(*pFd).pMethods).xFileSize)
            .expect("non-null function pointer")(pFd, pSize);
        let ref mut fresh290 = (*pFd).pMethods;
        *fresh290 = &mut recover_methods;
    } else {
        rc = ((*(*pFd).pMethods).xFileSize)
            .expect("non-null function pointer")(pFd, pSize);
    }
    return rc;
}
unsafe extern "C" fn recoverVfsLock(
    mut pFd: *mut sqlite3_file,
    mut eLock: libc::c_int,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (*pFd).pMethods
        == &mut recover_methods as *mut sqlite3_io_methods as *const sqlite3_io_methods
    {
        let ref mut fresh291 = (*pFd).pMethods;
        *fresh291 = recover_g.pMethods;
        rc = ((*(*pFd).pMethods).xLock).expect("non-null function pointer")(pFd, eLock);
        let ref mut fresh292 = (*pFd).pMethods;
        *fresh292 = &mut recover_methods;
    } else {
        rc = ((*(*pFd).pMethods).xLock).expect("non-null function pointer")(pFd, eLock);
    }
    return rc;
}
unsafe extern "C" fn recoverVfsUnlock(
    mut pFd: *mut sqlite3_file,
    mut eLock: libc::c_int,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (*pFd).pMethods
        == &mut recover_methods as *mut sqlite3_io_methods as *const sqlite3_io_methods
    {
        let ref mut fresh293 = (*pFd).pMethods;
        *fresh293 = recover_g.pMethods;
        rc = ((*(*pFd).pMethods).xUnlock)
            .expect("non-null function pointer")(pFd, eLock);
        let ref mut fresh294 = (*pFd).pMethods;
        *fresh294 = &mut recover_methods;
    } else {
        rc = ((*(*pFd).pMethods).xUnlock)
            .expect("non-null function pointer")(pFd, eLock);
    }
    return rc;
}
unsafe extern "C" fn recoverVfsCheckReservedLock(
    mut pFd: *mut sqlite3_file,
    mut pResOut: *mut libc::c_int,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (*pFd).pMethods
        == &mut recover_methods as *mut sqlite3_io_methods as *const sqlite3_io_methods
    {
        let ref mut fresh295 = (*pFd).pMethods;
        *fresh295 = recover_g.pMethods;
        rc = ((*(*pFd).pMethods).xCheckReservedLock)
            .expect("non-null function pointer")(pFd, pResOut);
        let ref mut fresh296 = (*pFd).pMethods;
        *fresh296 = &mut recover_methods;
    } else {
        rc = ((*(*pFd).pMethods).xCheckReservedLock)
            .expect("non-null function pointer")(pFd, pResOut);
    }
    return rc;
}
unsafe extern "C" fn recoverVfsFileControl(
    mut pFd: *mut sqlite3_file,
    mut op: libc::c_int,
    mut pArg: *mut libc::c_void,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (*pFd).pMethods
        == &mut recover_methods as *mut sqlite3_io_methods as *const sqlite3_io_methods
    {
        let ref mut fresh297 = (*pFd).pMethods;
        *fresh297 = recover_g.pMethods;
        rc = if !((*pFd).pMethods).is_null() {
            ((*(*pFd).pMethods).xFileControl)
                .expect("non-null function pointer")(pFd, op, pArg)
        } else {
            12 as libc::c_int
        };
        let ref mut fresh298 = (*pFd).pMethods;
        *fresh298 = &mut recover_methods;
    } else {
        rc = if !((*pFd).pMethods).is_null() {
            ((*(*pFd).pMethods).xFileControl)
                .expect("non-null function pointer")(pFd, op, pArg)
        } else {
            12 as libc::c_int
        };
    }
    return rc;
}
unsafe extern "C" fn recoverVfsSectorSize(mut pFd: *mut sqlite3_file) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (*pFd).pMethods
        == &mut recover_methods as *mut sqlite3_io_methods as *const sqlite3_io_methods
    {
        let ref mut fresh299 = (*pFd).pMethods;
        *fresh299 = recover_g.pMethods;
        rc = ((*(*pFd).pMethods).xSectorSize).expect("non-null function pointer")(pFd);
        let ref mut fresh300 = (*pFd).pMethods;
        *fresh300 = &mut recover_methods;
    } else {
        rc = ((*(*pFd).pMethods).xSectorSize).expect("non-null function pointer")(pFd);
    }
    return rc;
}
unsafe extern "C" fn recoverVfsDeviceCharacteristics(
    mut pFd: *mut sqlite3_file,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (*pFd).pMethods
        == &mut recover_methods as *mut sqlite3_io_methods as *const sqlite3_io_methods
    {
        let ref mut fresh301 = (*pFd).pMethods;
        *fresh301 = recover_g.pMethods;
        rc = ((*(*pFd).pMethods).xDeviceCharacteristics)
            .expect("non-null function pointer")(pFd);
        let ref mut fresh302 = (*pFd).pMethods;
        *fresh302 = &mut recover_methods;
    } else {
        rc = ((*(*pFd).pMethods).xDeviceCharacteristics)
            .expect("non-null function pointer")(pFd);
    }
    return rc;
}
unsafe extern "C" fn recoverVfsShmMap(
    mut pFd: *mut sqlite3_file,
    mut iPg: libc::c_int,
    mut pgsz: libc::c_int,
    mut bExtend: libc::c_int,
    mut pp: *mut *mut libc::c_void,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (*pFd).pMethods
        == &mut recover_methods as *mut sqlite3_io_methods as *const sqlite3_io_methods
    {
        let ref mut fresh303 = (*pFd).pMethods;
        *fresh303 = recover_g.pMethods;
        rc = ((*(*pFd).pMethods).xShmMap)
            .expect("non-null function pointer")(pFd, iPg, pgsz, bExtend, pp);
        let ref mut fresh304 = (*pFd).pMethods;
        *fresh304 = &mut recover_methods;
    } else {
        rc = ((*(*pFd).pMethods).xShmMap)
            .expect("non-null function pointer")(pFd, iPg, pgsz, bExtend, pp);
    }
    return rc;
}
unsafe extern "C" fn recoverVfsShmLock(
    mut pFd: *mut sqlite3_file,
    mut offset: libc::c_int,
    mut n: libc::c_int,
    mut flags: libc::c_int,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (*pFd).pMethods
        == &mut recover_methods as *mut sqlite3_io_methods as *const sqlite3_io_methods
    {
        let ref mut fresh305 = (*pFd).pMethods;
        *fresh305 = recover_g.pMethods;
        rc = ((*(*pFd).pMethods).xShmLock)
            .expect("non-null function pointer")(pFd, offset, n, flags);
        let ref mut fresh306 = (*pFd).pMethods;
        *fresh306 = &mut recover_methods;
    } else {
        rc = ((*(*pFd).pMethods).xShmLock)
            .expect("non-null function pointer")(pFd, offset, n, flags);
    }
    return rc;
}
unsafe extern "C" fn recoverVfsShmBarrier(mut pFd: *mut sqlite3_file) {
    if (*pFd).pMethods
        == &mut recover_methods as *mut sqlite3_io_methods as *const sqlite3_io_methods
    {
        let ref mut fresh307 = (*pFd).pMethods;
        *fresh307 = recover_g.pMethods;
        ((*(*pFd).pMethods).xShmBarrier).expect("non-null function pointer")(pFd);
        let ref mut fresh308 = (*pFd).pMethods;
        *fresh308 = &mut recover_methods;
    } else {
        ((*(*pFd).pMethods).xShmBarrier).expect("non-null function pointer")(pFd);
    };
}
unsafe extern "C" fn recoverVfsShmUnmap(
    mut pFd: *mut sqlite3_file,
    mut deleteFlag: libc::c_int,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (*pFd).pMethods
        == &mut recover_methods as *mut sqlite3_io_methods as *const sqlite3_io_methods
    {
        let ref mut fresh309 = (*pFd).pMethods;
        *fresh309 = recover_g.pMethods;
        rc = ((*(*pFd).pMethods).xShmUnmap)
            .expect("non-null function pointer")(pFd, deleteFlag);
        let ref mut fresh310 = (*pFd).pMethods;
        *fresh310 = &mut recover_methods;
    } else {
        rc = ((*(*pFd).pMethods).xShmUnmap)
            .expect("non-null function pointer")(pFd, deleteFlag);
    }
    return rc;
}
unsafe extern "C" fn recoverVfsFetch(
    mut pFd: *mut sqlite3_file,
    mut iOff: sqlite3_int64,
    mut iAmt: libc::c_int,
    mut pp: *mut *mut libc::c_void,
) -> libc::c_int {
    *pp = 0 as *mut libc::c_void;
    return 0 as libc::c_int;
}
unsafe extern "C" fn recoverVfsUnfetch(
    mut pFd: *mut sqlite3_file,
    mut iOff: sqlite3_int64,
    mut p: *mut libc::c_void,
) -> libc::c_int {
    return 0 as libc::c_int;
}
unsafe extern "C" fn recoverInstallWrapper(mut p: *mut sqlite3_recover) {
    let mut pFd: *mut sqlite3_file = 0 as *mut sqlite3_file;
    sqlite3_file_control(
        (*p).dbIn,
        (*p).zDb,
        7 as libc::c_int,
        &mut pFd as *mut *mut sqlite3_file as *mut libc::c_void,
    );
    if !pFd.is_null() && !((*pFd).pMethods).is_null() {
        let mut iVersion: libc::c_int = 1 as libc::c_int
            + ((*(*pFd).pMethods).iVersion > 1 as libc::c_int
                && ((*(*pFd).pMethods).xShmMap).is_some()) as libc::c_int;
        recover_g.pMethods = (*pFd).pMethods;
        recover_g.p = p;
        recover_methods.iVersion = iVersion;
        let ref mut fresh311 = (*pFd).pMethods;
        *fresh311 = &mut recover_methods;
    }
}
unsafe extern "C" fn recoverUninstallWrapper(mut p: *mut sqlite3_recover) {
    let mut pFd: *mut sqlite3_file = 0 as *mut sqlite3_file;
    sqlite3_file_control(
        (*p).dbIn,
        (*p).zDb,
        7 as libc::c_int,
        &mut pFd as *mut *mut sqlite3_file as *mut libc::c_void,
    );
    if !pFd.is_null() && !((*pFd).pMethods).is_null() {
        let ref mut fresh312 = (*pFd).pMethods;
        *fresh312 = recover_g.pMethods;
        recover_g.pMethods = 0 as *const sqlite3_io_methods;
        recover_g.p = 0 as *mut sqlite3_recover;
    }
}
unsafe extern "C" fn recoverStep(mut p: *mut sqlite3_recover) {
    match (*p).eState {
        0 => {
            recoverSqlCallback(p, b"BEGIN\0" as *const u8 as *const libc::c_char);
            recoverSqlCallback(
                p,
                b"PRAGMA writable_schema = on\0" as *const u8 as *const libc::c_char,
            );
            recoverEnterMutex();
            recoverInstallWrapper(p);
            recoverOpenOutput(p);
            sqlite3_file_control(
                (*p).dbIn,
                (*p).zDb,
                42 as libc::c_int,
                0 as *mut libc::c_void,
            );
            recoverExec(
                p,
                (*p).dbIn,
                b"PRAGMA writable_schema = on\0" as *const u8 as *const libc::c_char,
            );
            recoverExec(p, (*p).dbIn, b"BEGIN\0" as *const u8 as *const libc::c_char);
            if (*p).errCode == 0 as libc::c_int {
                (*p).bCloseTransaction = 1 as libc::c_int;
            }
            recoverExec(
                p,
                (*p).dbIn,
                b"SELECT 1 FROM sqlite_schema\0" as *const u8 as *const libc::c_char,
            );
            recoverTransferSettings(p);
            recoverOpenRecovery(p);
            recoverCacheSchema(p);
            recoverUninstallWrapper(p);
            recoverLeaveMutex();
            recoverExec(p, (*p).dbOut, b"BEGIN\0" as *const u8 as *const libc::c_char);
            recoverWriteSchema1(p);
            (*p).eState = 1 as libc::c_int;
        }
        1 => {
            if ((*p).w1.pTbls).is_null() {
                recoverWriteDataInit(p);
            }
            if 101 as libc::c_int == recoverWriteDataStep(p) {
                recoverWriteDataCleanup(p);
                if !((*p).zLostAndFound).is_null() {
                    (*p).eState = 2 as libc::c_int;
                } else {
                    (*p).eState = 5 as libc::c_int;
                }
            }
        }
        2 => {
            if ((*p).laf.pUsed).is_null() {
                recoverLostAndFound1Init(p);
            }
            if 101 as libc::c_int == recoverLostAndFound1Step(p) {
                (*p).eState = 3 as libc::c_int;
            }
        }
        3 => {
            if ((*p).laf.pAllAndParent).is_null() {
                recoverLostAndFound2Init(p);
            }
            if 101 as libc::c_int == recoverLostAndFound2Step(p) {
                (*p).eState = 4 as libc::c_int;
            }
        }
        4 => {
            if ((*p).laf.pInsert).is_null() {
                recoverLostAndFound3Init(p);
            }
            if 101 as libc::c_int == recoverLostAndFound3Step(p) {
                (*p).eState = 5 as libc::c_int;
            }
        }
        5 => {
            let mut rc: libc::c_int = 0 as libc::c_int;
            recoverWriteSchema2(p);
            (*p).eState = 6 as libc::c_int;
            recoverExec(p, (*p).dbOut, b"COMMIT\0" as *const u8 as *const libc::c_char);
            rc = sqlite3_exec(
                (*p).dbIn,
                b"END\0" as *const u8 as *const libc::c_char,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
            if (*p).errCode == 0 as libc::c_int {
                (*p).errCode = rc;
            }
            recoverSqlCallback(
                p,
                b"PRAGMA writable_schema = off\0" as *const u8 as *const libc::c_char,
            );
            recoverSqlCallback(p, b"COMMIT\0" as *const u8 as *const libc::c_char);
            (*p).eState = 6 as libc::c_int;
            recoverFinalCleanup(p);
        }
        6 | _ => {}
    };
}
#[no_mangle]
pub unsafe extern "C" fn recoverInit(
    mut db: *mut sqlite3,
    mut zDb: *const libc::c_char,
    mut zUri: *const libc::c_char,
    mut xSql: Option::<
        unsafe extern "C" fn(*mut libc::c_void, *const libc::c_char) -> libc::c_int,
    >,
    mut pSqlCtx: *mut libc::c_void,
) -> *mut sqlite3_recover {
    let mut pRet: *mut sqlite3_recover = 0 as *mut sqlite3_recover;
    let mut nDb: libc::c_int = 0 as libc::c_int;
    let mut nUri: libc::c_int = 0 as libc::c_int;
    let mut nByte: libc::c_int = 0 as libc::c_int;
    if zDb.is_null() {
        zDb = b"main\0" as *const u8 as *const libc::c_char;
    }
    nDb = recoverStrlen(zDb);
    nUri = recoverStrlen(zUri);
    nByte = (::std::mem::size_of::<sqlite3_recover>() as libc::c_ulong)
        .wrapping_add(nDb as libc::c_ulong)
        .wrapping_add(1 as libc::c_int as libc::c_ulong)
        .wrapping_add(nUri as libc::c_ulong)
        .wrapping_add(1 as libc::c_int as libc::c_ulong) as libc::c_int;
    pRet = sqlite3_malloc(nByte) as *mut sqlite3_recover;
    if !pRet.is_null() {
        memset(pRet as *mut libc::c_void, 0 as libc::c_int, nByte as libc::c_ulong);
        let ref mut fresh313 = (*pRet).dbIn;
        *fresh313 = db;
        let ref mut fresh314 = (*pRet).zDb;
        *fresh314 = &mut *pRet.offset(1 as libc::c_int as isize) as *mut sqlite3_recover
            as *mut libc::c_char;
        let ref mut fresh315 = (*pRet).zUri;
        *fresh315 = &mut *((*pRet).zDb).offset((nDb + 1 as libc::c_int) as isize)
            as *mut libc::c_char;
        memcpy(
            (*pRet).zDb as *mut libc::c_void,
            zDb as *const libc::c_void,
            nDb as libc::c_ulong,
        );
        if nUri > 0 as libc::c_int && !zUri.is_null() {
            memcpy(
                (*pRet).zUri as *mut libc::c_void,
                zUri as *const libc::c_void,
                nUri as libc::c_ulong,
            );
        }
        let ref mut fresh316 = (*pRet).xSql;
        *fresh316 = xSql;
        let ref mut fresh317 = (*pRet).pSqlCtx;
        *fresh317 = pSqlCtx;
        (*pRet).bRecoverRowid = 1 as libc::c_int;
    }
    return pRet;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_recover_init(
    mut db: *mut sqlite3,
    mut zDb: *const libc::c_char,
    mut zUri: *const libc::c_char,
) -> *mut sqlite3_recover {
    return recoverInit(db, zDb, zUri, None, 0 as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_recover_init_sql(
    mut db: *mut sqlite3,
    mut zDb: *const libc::c_char,
    mut xSql: Option::<
        unsafe extern "C" fn(*mut libc::c_void, *const libc::c_char) -> libc::c_int,
    >,
    mut pSqlCtx: *mut libc::c_void,
) -> *mut sqlite3_recover {
    return recoverInit(db, zDb, 0 as *const libc::c_char, xSql, pSqlCtx);
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_recover_errmsg(
    mut p: *mut sqlite3_recover,
) -> *const libc::c_char {
    return if !p.is_null() && (*p).errCode != 7 as libc::c_int {
        (*p).zErrMsg as *const libc::c_char
    } else {
        b"out of memory\0" as *const u8 as *const libc::c_char
    };
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_recover_errcode(
    mut p: *mut sqlite3_recover,
) -> libc::c_int {
    return if !p.is_null() { (*p).errCode } else { 7 as libc::c_int };
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_recover_config(
    mut p: *mut sqlite3_recover,
    mut op: libc::c_int,
    mut pArg: *mut libc::c_void,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if p.is_null() {
        rc = 7 as libc::c_int;
    } else if (*p).eState != 0 as libc::c_int {
        rc = 21 as libc::c_int;
    } else {
        match op {
            789 => {
                sqlite3_free((*p).zStateDb as *mut libc::c_void);
                let ref mut fresh318 = (*p).zStateDb;
                *fresh318 = recoverMPrintf(
                    p,
                    b"%s\0" as *const u8 as *const libc::c_char,
                    pArg as *mut libc::c_char,
                );
            }
            1 => {
                let mut zArg: *const libc::c_char = pArg as *const libc::c_char;
                sqlite3_free((*p).zLostAndFound as *mut libc::c_void);
                if !zArg.is_null() {
                    let ref mut fresh319 = (*p).zLostAndFound;
                    *fresh319 = recoverMPrintf(
                        p,
                        b"%s\0" as *const u8 as *const libc::c_char,
                        zArg,
                    );
                } else {
                    let ref mut fresh320 = (*p).zLostAndFound;
                    *fresh320 = 0 as *mut libc::c_char;
                }
            }
            2 => {
                (*p).bFreelistCorrupt = *(pArg as *mut libc::c_int);
            }
            3 => {
                (*p).bRecoverRowid = *(pArg as *mut libc::c_int);
            }
            4 => {
                (*p).bSlowIndexes = *(pArg as *mut libc::c_int);
            }
            _ => {
                rc = 12 as libc::c_int;
            }
        }
    }
    return rc;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_recover_step(
    mut p: *mut sqlite3_recover,
) -> libc::c_int {
    if p.is_null() {
        return 7 as libc::c_int;
    }
    if (*p).errCode == 0 as libc::c_int {
        recoverStep(p);
    }
    if (*p).eState == 6 as libc::c_int && (*p).errCode == 0 as libc::c_int {
        return 101 as libc::c_int;
    }
    return (*p).errCode;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_recover_run(
    mut p: *mut sqlite3_recover,
) -> libc::c_int {
    while 0 as libc::c_int == sqlite3_recover_step(p) {}
    return sqlite3_recover_errcode(p);
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_recover_finish(
    mut p: *mut sqlite3_recover,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    if p.is_null() {
        rc = 7 as libc::c_int;
    } else {
        recoverFinalCleanup(p);
        if (*p).bCloseTransaction != 0
            && sqlite3_get_autocommit((*p).dbIn) == 0 as libc::c_int
        {
            rc = sqlite3_exec(
                (*p).dbIn,
                b"END\0" as *const u8 as *const libc::c_char,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
            if (*p).errCode == 0 as libc::c_int {
                (*p).errCode = rc;
            }
        }
        rc = (*p).errCode;
        sqlite3_free((*p).zErrMsg as *mut libc::c_void);
        sqlite3_free((*p).zStateDb as *mut libc::c_void);
        sqlite3_free((*p).zLostAndFound as *mut libc::c_void);
        sqlite3_free((*p).pPage1Cache as *mut libc::c_void);
        sqlite3_free(p as *mut libc::c_void);
    }
    return rc;
}
static mut modeDescr: [*const libc::c_char; 19] = [
    b"line\0" as *const u8 as *const libc::c_char,
    b"column\0" as *const u8 as *const libc::c_char,
    b"list\0" as *const u8 as *const libc::c_char,
    b"semi\0" as *const u8 as *const libc::c_char,
    b"html\0" as *const u8 as *const libc::c_char,
    b"insert\0" as *const u8 as *const libc::c_char,
    b"quote\0" as *const u8 as *const libc::c_char,
    b"tcl\0" as *const u8 as *const libc::c_char,
    b"csv\0" as *const u8 as *const libc::c_char,
    b"explain\0" as *const u8 as *const libc::c_char,
    b"ascii\0" as *const u8 as *const libc::c_char,
    b"prettyprint\0" as *const u8 as *const libc::c_char,
    b"eqp\0" as *const u8 as *const libc::c_char,
    b"json\0" as *const u8 as *const libc::c_char,
    b"markdown\0" as *const u8 as *const libc::c_char,
    b"table\0" as *const u8 as *const libc::c_char,
    b"box\0" as *const u8 as *const libc::c_char,
    b"count\0" as *const u8 as *const libc::c_char,
    b"off\0" as *const u8 as *const libc::c_char,
];
unsafe extern "C" fn shellLog(
    mut pArg: *mut libc::c_void,
    mut iErrCode: libc::c_int,
    mut zMsg: *const libc::c_char,
) {
    let mut p: *mut ShellState = pArg as *mut ShellState;
    if ((*p).pLog).is_null() {
        return;
    }
    fprintf(
        (*p).pLog,
        b"(%d) %s\n\0" as *const u8 as *const libc::c_char,
        iErrCode,
        zMsg,
    );
    fflush((*p).pLog);
}
unsafe extern "C" fn shellPutsFunc(
    mut pCtx: *mut sqlite3_context,
    mut nVal: libc::c_int,
    mut apVal: *mut *mut sqlite3_value,
) {
    let mut p: *mut ShellState = sqlite3_user_data(pCtx) as *mut ShellState;
    fprintf(
        (*p).out,
        b"%s\n\0" as *const u8 as *const libc::c_char,
        sqlite3_value_text(*apVal.offset(0 as libc::c_int as isize)),
    );
    sqlite3_result_value(pCtx, *apVal.offset(0 as libc::c_int as isize));
}
unsafe extern "C" fn failIfSafeMode(
    mut p: *mut ShellState,
    mut zErrMsg: *const libc::c_char,
    mut args: ...
) {
    if (*p).bSafeMode != 0 {
        let mut ap: ::std::ffi::VaListImpl;
        let mut zMsg: *mut libc::c_char = 0 as *mut libc::c_char;
        ap = args.clone();
        zMsg = sqlite3_vmprintf(zErrMsg, ap.as_va_list());
        fprintf(stderr, b"line %d: \0" as *const u8 as *const libc::c_char, (*p).lineno);
        fprintf(stderr, b"%s\n\0" as *const u8 as *const libc::c_char, zMsg);
        exit(1 as libc::c_int);
    }
}
unsafe extern "C" fn editFunc(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut zEditor: *const libc::c_char = 0 as *const libc::c_char;
    let mut zTempFile: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut db: *mut sqlite3 = 0 as *mut sqlite3;
    let mut zCmd: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut bBin: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    let mut hasCRNL: libc::c_int = 0 as libc::c_int;
    let mut f: *mut FILE = 0 as *mut FILE;
    let mut sz: sqlite3_int64 = 0;
    let mut x: sqlite3_int64 = 0;
    let mut p: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    if argc == 2 as libc::c_int {
        zEditor = sqlite3_value_text(*argv.offset(1 as libc::c_int as isize))
            as *const libc::c_char;
    } else {
        zEditor = getenv(b"VISUAL\0" as *const u8 as *const libc::c_char);
    }
    if zEditor.is_null() {
        sqlite3_result_error(
            context,
            b"no editor for edit()\0" as *const u8 as *const libc::c_char,
            -(1 as libc::c_int),
        );
        return;
    }
    if sqlite3_value_type(*argv.offset(0 as libc::c_int as isize)) == 5 as libc::c_int {
        sqlite3_result_error(
            context,
            b"NULL input to edit()\0" as *const u8 as *const libc::c_char,
            -(1 as libc::c_int),
        );
        return;
    }
    db = sqlite3_context_db_handle(context);
    zTempFile = 0 as *mut libc::c_char;
    sqlite3_file_control(
        db,
        0 as *const libc::c_char,
        16 as libc::c_int,
        &mut zTempFile as *mut *mut libc::c_char as *mut libc::c_void,
    );
    if zTempFile.is_null() {
        let mut r: sqlite3_uint64 = 0 as libc::c_int as sqlite3_uint64;
        sqlite3_randomness(
            ::std::mem::size_of::<sqlite3_uint64>() as libc::c_ulong as libc::c_int,
            &mut r as *mut sqlite3_uint64 as *mut libc::c_void,
        );
        zTempFile = sqlite3_mprintf(
            b"temp%llx\0" as *const u8 as *const libc::c_char,
            r,
        );
        if zTempFile.is_null() {
            sqlite3_result_error_nomem(context);
            return;
        }
    }
    bBin = (sqlite3_value_type(*argv.offset(0 as libc::c_int as isize))
        == 4 as libc::c_int) as libc::c_int;
    f = fopen(
        zTempFile,
        if bBin != 0 {
            b"wb\0" as *const u8 as *const libc::c_char
        } else {
            b"w\0" as *const u8 as *const libc::c_char
        },
    );
    if f.is_null() {
        sqlite3_result_error(
            context,
            b"edit() cannot open temp file\0" as *const u8 as *const libc::c_char,
            -(1 as libc::c_int),
        );
    } else {
        sz = sqlite3_value_bytes(*argv.offset(0 as libc::c_int as isize))
            as sqlite3_int64;
        if bBin != 0 {
            x = fwrite(
                sqlite3_value_blob(*argv.offset(0 as libc::c_int as isize)),
                1 as libc::c_int as libc::c_ulong,
                sz as size_t,
                f,
            ) as sqlite3_int64;
        } else {
            let mut z: *const libc::c_char = sqlite3_value_text(
                *argv.offset(0 as libc::c_int as isize),
            ) as *const libc::c_char;
            if !z.is_null()
                && !(strstr(z, b"\r\n\0" as *const u8 as *const libc::c_char)).is_null()
            {
                hasCRNL = 1 as libc::c_int;
            }
            x = fwrite(
                sqlite3_value_text(*argv.offset(0 as libc::c_int as isize))
                    as *const libc::c_void,
                1 as libc::c_int as libc::c_ulong,
                sz as size_t,
                f,
            ) as sqlite3_int64;
        }
        fclose(f);
        f = 0 as *mut FILE;
        if x != sz {
            sqlite3_result_error(
                context,
                b"edit() could not write the whole file\0" as *const u8
                    as *const libc::c_char,
                -(1 as libc::c_int),
            );
        } else {
            zCmd = sqlite3_mprintf(
                b"%s \"%s\"\0" as *const u8 as *const libc::c_char,
                zEditor,
                zTempFile,
            );
            if zCmd.is_null() {
                sqlite3_result_error_nomem(context);
            } else {
                rc = system(zCmd);
                sqlite3_free(zCmd as *mut libc::c_void);
                if rc != 0 {
                    sqlite3_result_error(
                        context,
                        b"EDITOR returned non-zero\0" as *const u8
                            as *const libc::c_char,
                        -(1 as libc::c_int),
                    );
                } else {
                    f = fopen(zTempFile, b"rb\0" as *const u8 as *const libc::c_char);
                    if f.is_null() {
                        sqlite3_result_error(
                            context,
                            b"edit() cannot reopen temp file after edit\0" as *const u8
                                as *const libc::c_char,
                            -(1 as libc::c_int),
                        );
                    } else {
                        fseek(f, 0 as libc::c_int as libc::c_long, 2 as libc::c_int);
                        sz = ftell(f) as sqlite3_int64;
                        rewind(f);
                        p = sqlite3_malloc64(
                            (sz + 1 as libc::c_int as libc::c_longlong) as sqlite3_uint64,
                        ) as *mut libc::c_uchar;
                        if p.is_null() {
                            sqlite3_result_error_nomem(context);
                        } else {
                            x = fread(
                                p as *mut libc::c_void,
                                1 as libc::c_int as libc::c_ulong,
                                sz as size_t,
                                f,
                            ) as sqlite3_int64;
                            fclose(f);
                            f = 0 as *mut FILE;
                            if x != sz {
                                sqlite3_result_error(
                                    context,
                                    b"could not read back the whole file\0" as *const u8
                                        as *const libc::c_char,
                                    -(1 as libc::c_int),
                                );
                            } else {
                                if bBin != 0 {
                                    sqlite3_result_blob64(
                                        context,
                                        p as *const libc::c_void,
                                        sz as sqlite3_uint64,
                                        Some(
                                            sqlite3_free
                                                as unsafe extern "C" fn(*mut libc::c_void) -> (),
                                        ),
                                    );
                                } else {
                                    let mut i: sqlite3_int64 = 0;
                                    let mut j: sqlite3_int64 = 0;
                                    if !(hasCRNL != 0) {
                                        j = 0 as libc::c_int as sqlite3_int64;
                                        i = j;
                                        while i < sz {
                                            if *p.offset(i as isize) as libc::c_int == '\r' as i32
                                                && *p
                                                    .offset((i + 1 as libc::c_int as libc::c_longlong) as isize)
                                                    as libc::c_int == '\n' as i32
                                            {
                                                i += 1;
                                            }
                                            let fresh321 = j;
                                            j = j + 1;
                                            *p.offset(fresh321 as isize) = *p.offset(i as isize);
                                            i += 1;
                                        }
                                        sz = j;
                                        *p.offset(sz as isize) = 0 as libc::c_int as libc::c_uchar;
                                    }
                                    sqlite3_result_text64(
                                        context,
                                        p as *const libc::c_char,
                                        sz as sqlite3_uint64,
                                        Some(
                                            sqlite3_free
                                                as unsafe extern "C" fn(*mut libc::c_void) -> (),
                                        ),
                                        1 as libc::c_int as libc::c_uchar,
                                    );
                                }
                                p = 0 as *mut libc::c_uchar;
                            }
                        }
                    }
                }
            }
        }
    }
    if !f.is_null() {
        fclose(f);
    }
    unlink(zTempFile);
    sqlite3_free(zTempFile as *mut libc::c_void);
    sqlite3_free(p as *mut libc::c_void);
}
unsafe extern "C" fn outputModePush(mut p: *mut ShellState) {
    (*p).modePrior = (*p).mode;
    (*p).priorShFlgs = (*p).shellFlgs;
    memcpy(
        ((*p).colSepPrior).as_mut_ptr() as *mut libc::c_void,
        ((*p).colSeparator).as_mut_ptr() as *const libc::c_void,
        ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
    memcpy(
        ((*p).rowSepPrior).as_mut_ptr() as *mut libc::c_void,
        ((*p).rowSeparator).as_mut_ptr() as *const libc::c_void,
        ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
}
unsafe extern "C" fn outputModePop(mut p: *mut ShellState) {
    (*p).mode = (*p).modePrior;
    (*p).shellFlgs = (*p).priorShFlgs;
    memcpy(
        ((*p).colSeparator).as_mut_ptr() as *mut libc::c_void,
        ((*p).colSepPrior).as_mut_ptr() as *const libc::c_void,
        ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
    memcpy(
        ((*p).rowSeparator).as_mut_ptr() as *mut libc::c_void,
        ((*p).rowSepPrior).as_mut_ptr() as *const libc::c_void,
        ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
}
unsafe extern "C" fn output_hex_blob(
    mut out: *mut FILE,
    mut pBlob: *const libc::c_void,
    mut nBlob: libc::c_int,
) {
    let mut i: libc::c_int = 0;
    let mut aBlob: *mut libc::c_uchar = pBlob as *mut libc::c_uchar;
    let mut zStr: *mut libc::c_char = sqlite3_malloc(
        nBlob * 2 as libc::c_int + 1 as libc::c_int,
    ) as *mut libc::c_char;
    shell_check_oom(zStr as *mut libc::c_void);
    i = 0 as libc::c_int;
    while i < nBlob {
        static mut aHex: [libc::c_char; 16] = [
            '0' as i32 as libc::c_char,
            '1' as i32 as libc::c_char,
            '2' as i32 as libc::c_char,
            '3' as i32 as libc::c_char,
            '4' as i32 as libc::c_char,
            '5' as i32 as libc::c_char,
            '6' as i32 as libc::c_char,
            '7' as i32 as libc::c_char,
            '8' as i32 as libc::c_char,
            '9' as i32 as libc::c_char,
            'a' as i32 as libc::c_char,
            'b' as i32 as libc::c_char,
            'c' as i32 as libc::c_char,
            'd' as i32 as libc::c_char,
            'e' as i32 as libc::c_char,
            'f' as i32 as libc::c_char,
        ];
        *zStr
            .offset(
                (i * 2 as libc::c_int) as isize,
            ) = aHex[(*aBlob.offset(i as isize) as libc::c_int >> 4 as libc::c_int)
            as usize];
        *zStr
            .offset(
                (i * 2 as libc::c_int + 1 as libc::c_int) as isize,
            ) = aHex[(*aBlob.offset(i as isize) as libc::c_int & 0xf as libc::c_int)
            as usize];
        i += 1;
    }
    *zStr.offset((i * 2 as libc::c_int) as isize) = '\0' as i32 as libc::c_char;
    fprintf(out, b"X'%s'\0" as *const u8 as *const libc::c_char, zStr);
    sqlite3_free(zStr as *mut libc::c_void);
}
unsafe extern "C" fn unused_string(
    mut z: *const libc::c_char,
    mut zA: *const libc::c_char,
    mut zB: *const libc::c_char,
    mut zBuf: *mut libc::c_char,
) -> *const libc::c_char {
    let mut i: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    if (strstr(z, zA)).is_null() {
        return zA;
    }
    if (strstr(z, zB)).is_null() {
        return zB;
    }
    loop {
        let fresh322 = i;
        i = i.wrapping_add(1);
        sqlite3_snprintf(
            20 as libc::c_int,
            zBuf,
            b"(%s%u)\0" as *const u8 as *const libc::c_char,
            zA,
            fresh322,
        );
        if (strstr(z, zBuf)).is_null() {
            break;
        }
    }
    return zBuf;
}
unsafe extern "C" fn output_quoted_string(
    mut out: *mut FILE,
    mut z: *const libc::c_char,
) {
    let mut i: libc::c_int = 0;
    let mut c: libc::c_char = 0;
    i = 0 as libc::c_int;
    loop {
        c = *z.offset(i as isize);
        if !(c as libc::c_int != 0 as libc::c_int && c as libc::c_int != '\'' as i32) {
            break;
        }
        i += 1;
    }
    if c as libc::c_int == 0 as libc::c_int {
        fprintf(out, b"'%s'\0" as *const u8 as *const libc::c_char, z);
    } else {
        fprintf(out, b"'\0" as *const u8 as *const libc::c_char);
        while *z != 0 {
            i = 0 as libc::c_int;
            loop {
                c = *z.offset(i as isize);
                if !(c as libc::c_int != 0 as libc::c_int
                    && c as libc::c_int != '\'' as i32)
                {
                    break;
                }
                i += 1;
            }
            if c as libc::c_int == '\'' as i32 {
                i += 1;
            }
            if i != 0 {
                fprintf(out, b"%.*s\0" as *const u8 as *const libc::c_char, i, z);
                z = z.offset(i as isize);
            }
            if c as libc::c_int == '\'' as i32 {
                fprintf(out, b"'\0" as *const u8 as *const libc::c_char);
            } else {
                if c as libc::c_int == 0 as libc::c_int {
                    break;
                }
                z = z.offset(1);
            }
        }
        fprintf(out, b"'\0" as *const u8 as *const libc::c_char);
    };
}
unsafe extern "C" fn output_quoted_escaped_string(
    mut out: *mut FILE,
    mut z: *const libc::c_char,
) {
    let mut i: libc::c_int = 0;
    let mut c: libc::c_char = 0;
    i = 0 as libc::c_int;
    loop {
        c = *z.offset(i as isize);
        if !(c as libc::c_int != 0 as libc::c_int && c as libc::c_int != '\'' as i32
            && c as libc::c_int != '\n' as i32 && c as libc::c_int != '\r' as i32)
        {
            break;
        }
        i += 1;
    }
    if c as libc::c_int == 0 as libc::c_int {
        fprintf(out, b"'%s'\0" as *const u8 as *const libc::c_char, z);
    } else {
        let mut zNL: *const libc::c_char = 0 as *const libc::c_char;
        let mut zCR: *const libc::c_char = 0 as *const libc::c_char;
        let mut nNL: libc::c_int = 0 as libc::c_int;
        let mut nCR: libc::c_int = 0 as libc::c_int;
        let mut zBuf1: [libc::c_char; 20] = [0; 20];
        let mut zBuf2: [libc::c_char; 20] = [0; 20];
        i = 0 as libc::c_int;
        while *z.offset(i as isize) != 0 {
            if *z.offset(i as isize) as libc::c_int == '\n' as i32 {
                nNL += 1;
            }
            if *z.offset(i as isize) as libc::c_int == '\r' as i32 {
                nCR += 1;
            }
            i += 1;
        }
        if nNL != 0 {
            fprintf(out, b"replace(\0" as *const u8 as *const libc::c_char);
            zNL = unused_string(
                z,
                b"\\n\0" as *const u8 as *const libc::c_char,
                b"\\012\0" as *const u8 as *const libc::c_char,
                zBuf1.as_mut_ptr(),
            );
        }
        if nCR != 0 {
            fprintf(out, b"replace(\0" as *const u8 as *const libc::c_char);
            zCR = unused_string(
                z,
                b"\\r\0" as *const u8 as *const libc::c_char,
                b"\\015\0" as *const u8 as *const libc::c_char,
                zBuf2.as_mut_ptr(),
            );
        }
        fprintf(out, b"'\0" as *const u8 as *const libc::c_char);
        while *z != 0 {
            i = 0 as libc::c_int;
            loop {
                c = *z.offset(i as isize);
                if !(c as libc::c_int != 0 as libc::c_int
                    && c as libc::c_int != '\n' as i32 && c as libc::c_int != '\r' as i32
                    && c as libc::c_int != '\'' as i32)
                {
                    break;
                }
                i += 1;
            }
            if c as libc::c_int == '\'' as i32 {
                i += 1;
            }
            if i != 0 {
                fprintf(out, b"%.*s\0" as *const u8 as *const libc::c_char, i, z);
                z = z.offset(i as isize);
            }
            if c as libc::c_int == '\'' as i32 {
                fprintf(out, b"'\0" as *const u8 as *const libc::c_char);
            } else {
                if c as libc::c_int == 0 as libc::c_int {
                    break;
                }
                z = z.offset(1);
                if c as libc::c_int == '\n' as i32 {
                    fprintf(out, b"%s\0" as *const u8 as *const libc::c_char, zNL);
                } else {
                    fprintf(out, b"%s\0" as *const u8 as *const libc::c_char, zCR);
                }
            }
        }
        fprintf(out, b"'\0" as *const u8 as *const libc::c_char);
        if nCR != 0 {
            fprintf(out, b",'%s',char(13))\0" as *const u8 as *const libc::c_char, zCR);
        }
        if nNL != 0 {
            fprintf(out, b",'%s',char(10))\0" as *const u8 as *const libc::c_char, zNL);
        }
    };
}
unsafe extern "C" fn output_c_string(mut out: *mut FILE, mut z: *const libc::c_char) {
    let mut c: libc::c_uint = 0;
    fputc('"' as i32, out);
    loop {
        let fresh323 = z;
        z = z.offset(1);
        c = *fresh323 as libc::c_uint;
        if !(c != 0 as libc::c_int as libc::c_uint) {
            break;
        }
        if c == '\\' as i32 as libc::c_uint {
            fputc(c as libc::c_int, out);
            fputc(c as libc::c_int, out);
        } else if c == '"' as i32 as libc::c_uint {
            fputc('\\' as i32, out);
            fputc('"' as i32, out);
        } else if c == '\t' as i32 as libc::c_uint {
            fputc('\\' as i32, out);
            fputc('t' as i32, out);
        } else if c == '\n' as i32 as libc::c_uint {
            fputc('\\' as i32, out);
            fputc('n' as i32, out);
        } else if c == '\r' as i32 as libc::c_uint {
            fputc('\\' as i32, out);
            fputc('r' as i32, out);
        } else if *(*__ctype_b_loc())
            .offset((c & 0xff as libc::c_int as libc::c_uint) as libc::c_int as isize)
            as libc::c_int & _ISprint as libc::c_int as libc::c_ushort as libc::c_int
            == 0
        {
            fprintf(
                out,
                b"\\%03o\0" as *const u8 as *const libc::c_char,
                c & 0xff as libc::c_int as libc::c_uint,
            );
        } else {
            fputc(c as libc::c_int, out);
        }
    }
    fputc('"' as i32, out);
}
unsafe extern "C" fn output_json_string(
    mut out: *mut FILE,
    mut z: *const libc::c_char,
    mut n: i64_0,
) {
    let mut c: libc::c_uint = 0;
    if n < 0 as libc::c_int as libc::c_longlong {
        n = strlen(z) as i64_0;
    }
    fputc('"' as i32, out);
    loop {
        let fresh324 = n;
        n = n - 1;
        if !(fresh324 != 0) {
            break;
        }
        let fresh325 = z;
        z = z.offset(1);
        c = *fresh325 as libc::c_uint;
        if c == '\\' as i32 as libc::c_uint || c == '"' as i32 as libc::c_uint {
            fputc('\\' as i32, out);
            fputc(c as libc::c_int, out);
        } else if c <= 0x1f as libc::c_int as libc::c_uint {
            fputc('\\' as i32, out);
            if c == '\u{8}' as i32 as libc::c_uint {
                fputc('b' as i32, out);
            } else if c == '\u{c}' as i32 as libc::c_uint {
                fputc('f' as i32, out);
            } else if c == '\n' as i32 as libc::c_uint {
                fputc('n' as i32, out);
            } else if c == '\r' as i32 as libc::c_uint {
                fputc('r' as i32, out);
            } else if c == '\t' as i32 as libc::c_uint {
                fputc('t' as i32, out);
            } else {
                fprintf(out, b"u%04x\0" as *const u8 as *const libc::c_char, c);
            }
        } else {
            fputc(c as libc::c_int, out);
        }
    }
    fputc('"' as i32, out);
}
unsafe extern "C" fn output_html_string(mut out: *mut FILE, mut z: *const libc::c_char) {
    let mut i: libc::c_int = 0;
    if z.is_null() {
        z = b"\0" as *const u8 as *const libc::c_char;
    }
    while *z != 0 {
        i = 0 as libc::c_int;
        while *z.offset(i as isize) as libc::c_int != 0
            && *z.offset(i as isize) as libc::c_int != '<' as i32
            && *z.offset(i as isize) as libc::c_int != '&' as i32
            && *z.offset(i as isize) as libc::c_int != '>' as i32
            && *z.offset(i as isize) as libc::c_int != '"' as i32
            && *z.offset(i as isize) as libc::c_int != '\'' as i32
        {
            i += 1;
        }
        if i > 0 as libc::c_int {
            fprintf(out, b"%.*s\0" as *const u8 as *const libc::c_char, i, z);
        }
        if *z.offset(i as isize) as libc::c_int == '<' as i32 {
            fprintf(out, b"&lt;\0" as *const u8 as *const libc::c_char);
        } else if *z.offset(i as isize) as libc::c_int == '&' as i32 {
            fprintf(out, b"&amp;\0" as *const u8 as *const libc::c_char);
        } else if *z.offset(i as isize) as libc::c_int == '>' as i32 {
            fprintf(out, b"&gt;\0" as *const u8 as *const libc::c_char);
        } else if *z.offset(i as isize) as libc::c_int == '"' as i32 {
            fprintf(out, b"&quot;\0" as *const u8 as *const libc::c_char);
        } else {
            if !(*z.offset(i as isize) as libc::c_int == '\'' as i32) {
                break;
            }
            fprintf(out, b"&#39;\0" as *const u8 as *const libc::c_char);
        }
        z = z.offset((i + 1 as libc::c_int) as isize);
    }
}
static mut needCsvQuote: [libc::c_char; 256] = [
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
];
unsafe extern "C" fn output_csv(
    mut p: *mut ShellState,
    mut z: *const libc::c_char,
    mut bSep: libc::c_int,
) {
    let mut out: *mut FILE = (*p).out;
    if z.is_null() {
        fprintf(
            out,
            b"%s\0" as *const u8 as *const libc::c_char,
            ((*p).nullValue).as_mut_ptr(),
        );
    } else {
        let mut i: libc::c_uint = 0;
        i = 0 as libc::c_int as libc::c_uint;
        while *z.offset(i as isize) != 0 {
            if needCsvQuote[*(z as *mut libc::c_uchar).offset(i as isize) as usize] != 0
            {
                i = 0 as libc::c_int as libc::c_uint;
                break;
            } else {
                i = i.wrapping_add(1);
            }
        }
        if i == 0 as libc::c_int as libc::c_uint
            || !(strstr(z, ((*p).colSeparator).as_mut_ptr())).is_null()
        {
            let mut zQuoted: *mut libc::c_char = sqlite3_mprintf(
                b"\"%w\"\0" as *const u8 as *const libc::c_char,
                z,
            );
            shell_check_oom(zQuoted as *mut libc::c_void);
            fprintf(out, b"%s\0" as *const u8 as *const libc::c_char, zQuoted);
            sqlite3_free(zQuoted as *mut libc::c_void);
        } else {
            fprintf(out, b"%s\0" as *const u8 as *const libc::c_char, z);
        }
    }
    if bSep != 0 {
        fprintf(
            (*p).out,
            b"%s\0" as *const u8 as *const libc::c_char,
            ((*p).colSeparator).as_mut_ptr(),
        );
    }
}
unsafe extern "C" fn interrupt_handler(mut NotUsed: libc::c_int) {
    ::std::ptr::write_volatile(
        &mut seenInterrupt as *mut libc::c_int,
        ::std::ptr::read_volatile::<libc::c_int>(&seenInterrupt as *const libc::c_int)
            + 1,
    );
    if seenInterrupt > 2 as libc::c_int {
        exit(1 as libc::c_int);
    }
    if !globalDb.is_null() {
        sqlite3_interrupt(globalDb);
    }
}
unsafe extern "C" fn safeModeAuth(
    mut pClientData: *mut libc::c_void,
    mut op: libc::c_int,
    mut zA1: *const libc::c_char,
    mut zA2: *const libc::c_char,
    mut zA3: *const libc::c_char,
    mut zA4: *const libc::c_char,
) -> libc::c_int {
    let mut p: *mut ShellState = pClientData as *mut ShellState;
    static mut azProhibitedFunctions: [*const libc::c_char; 7] = [
        b"edit\0" as *const u8 as *const libc::c_char,
        b"fts3_tokenizer\0" as *const u8 as *const libc::c_char,
        b"load_extension\0" as *const u8 as *const libc::c_char,
        b"readfile\0" as *const u8 as *const libc::c_char,
        b"writefile\0" as *const u8 as *const libc::c_char,
        b"zipfile\0" as *const u8 as *const libc::c_char,
        b"zipfile_cds\0" as *const u8 as *const libc::c_char,
    ];
    match op {
        24 => {
            failIfSafeMode(
                p,
                b"cannot run ATTACH in safe mode\0" as *const u8 as *const libc::c_char,
            );
        }
        31 => {
            let mut i: libc::c_int = 0;
            i = 0 as libc::c_int;
            while i
                < (::std::mem::size_of::<[*const libc::c_char; 7]>() as libc::c_ulong)
                    .wrapping_div(
                        ::std::mem::size_of::<*const libc::c_char>() as libc::c_ulong,
                    ) as libc::c_int
            {
                if sqlite3_stricmp(zA1, azProhibitedFunctions[i as usize])
                    == 0 as libc::c_int
                {
                    failIfSafeMode(
                        p,
                        b"cannot use the %s() function in safe mode\0" as *const u8
                            as *const libc::c_char,
                        azProhibitedFunctions[i as usize],
                    );
                }
                i += 1;
            }
        }
        _ => {}
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn shellAuth(
    mut pClientData: *mut libc::c_void,
    mut op: libc::c_int,
    mut zA1: *const libc::c_char,
    mut zA2: *const libc::c_char,
    mut zA3: *const libc::c_char,
    mut zA4: *const libc::c_char,
) -> libc::c_int {
    let mut p: *mut ShellState = pClientData as *mut ShellState;
    static mut azAction: [*const libc::c_char; 34] = [
        0 as *const libc::c_char,
        b"CREATE_INDEX\0" as *const u8 as *const libc::c_char,
        b"CREATE_TABLE\0" as *const u8 as *const libc::c_char,
        b"CREATE_TEMP_INDEX\0" as *const u8 as *const libc::c_char,
        b"CREATE_TEMP_TABLE\0" as *const u8 as *const libc::c_char,
        b"CREATE_TEMP_TRIGGER\0" as *const u8 as *const libc::c_char,
        b"CREATE_TEMP_VIEW\0" as *const u8 as *const libc::c_char,
        b"CREATE_TRIGGER\0" as *const u8 as *const libc::c_char,
        b"CREATE_VIEW\0" as *const u8 as *const libc::c_char,
        b"DELETE\0" as *const u8 as *const libc::c_char,
        b"DROP_INDEX\0" as *const u8 as *const libc::c_char,
        b"DROP_TABLE\0" as *const u8 as *const libc::c_char,
        b"DROP_TEMP_INDEX\0" as *const u8 as *const libc::c_char,
        b"DROP_TEMP_TABLE\0" as *const u8 as *const libc::c_char,
        b"DROP_TEMP_TRIGGER\0" as *const u8 as *const libc::c_char,
        b"DROP_TEMP_VIEW\0" as *const u8 as *const libc::c_char,
        b"DROP_TRIGGER\0" as *const u8 as *const libc::c_char,
        b"DROP_VIEW\0" as *const u8 as *const libc::c_char,
        b"INSERT\0" as *const u8 as *const libc::c_char,
        b"PRAGMA\0" as *const u8 as *const libc::c_char,
        b"READ\0" as *const u8 as *const libc::c_char,
        b"SELECT\0" as *const u8 as *const libc::c_char,
        b"TRANSACTION\0" as *const u8 as *const libc::c_char,
        b"UPDATE\0" as *const u8 as *const libc::c_char,
        b"ATTACH\0" as *const u8 as *const libc::c_char,
        b"DETACH\0" as *const u8 as *const libc::c_char,
        b"ALTER_TABLE\0" as *const u8 as *const libc::c_char,
        b"REINDEX\0" as *const u8 as *const libc::c_char,
        b"ANALYZE\0" as *const u8 as *const libc::c_char,
        b"CREATE_VTABLE\0" as *const u8 as *const libc::c_char,
        b"DROP_VTABLE\0" as *const u8 as *const libc::c_char,
        b"FUNCTION\0" as *const u8 as *const libc::c_char,
        b"SAVEPOINT\0" as *const u8 as *const libc::c_char,
        b"RECURSIVE\0" as *const u8 as *const libc::c_char,
    ];
    let mut i: libc::c_int = 0;
    let mut az: [*const libc::c_char; 4] = [0 as *const libc::c_char; 4];
    az[0 as libc::c_int as usize] = zA1;
    az[1 as libc::c_int as usize] = zA2;
    az[2 as libc::c_int as usize] = zA3;
    az[3 as libc::c_int as usize] = zA4;
    fprintf(
        (*p).out,
        b"authorizer: %s\0" as *const u8 as *const libc::c_char,
        azAction[op as usize],
    );
    i = 0 as libc::c_int;
    while i < 4 as libc::c_int {
        fprintf((*p).out, b" \0" as *const u8 as *const libc::c_char);
        if !(az[i as usize]).is_null() {
            output_c_string((*p).out, az[i as usize]);
        } else {
            fprintf((*p).out, b"NULL\0" as *const u8 as *const libc::c_char);
        }
        i += 1;
    }
    fprintf((*p).out, b"\n\0" as *const u8 as *const libc::c_char);
    if (*p).bSafeMode != 0 {
        safeModeAuth(pClientData, op, zA1, zA2, zA3, zA4);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn printSchemaLine(
    mut out: *mut FILE,
    mut z: *const libc::c_char,
    mut zTail: *const libc::c_char,
) {
    let mut zToFree: *mut libc::c_char = 0 as *mut libc::c_char;
    if z.is_null() {
        return;
    }
    if zTail.is_null() {
        return;
    }
    if *zTail.offset(0 as libc::c_int as isize) as libc::c_int == ';' as i32
        && (!(strstr(z, b"/*\0" as *const u8 as *const libc::c_char)).is_null()
            || !(strstr(z, b"--\0" as *const u8 as *const libc::c_char)).is_null())
    {
        let mut zOrig: *const libc::c_char = z;
        static mut azTerm: [*const libc::c_char; 3] = [
            b"\0" as *const u8 as *const libc::c_char,
            b"*/\0" as *const u8 as *const libc::c_char,
            b"\n\0" as *const u8 as *const libc::c_char,
        ];
        let mut i: libc::c_int = 0;
        i = 0 as libc::c_int;
        while i
            < (::std::mem::size_of::<[*const libc::c_char; 3]>() as libc::c_ulong)
                .wrapping_div(
                    ::std::mem::size_of::<*const libc::c_char>() as libc::c_ulong,
                ) as libc::c_int
        {
            let mut zNew: *mut libc::c_char = sqlite3_mprintf(
                b"%s%s;\0" as *const u8 as *const libc::c_char,
                zOrig,
                azTerm[i as usize],
            );
            if sqlite3_complete(zNew) != 0 {
                let mut n: size_t = strlen(zNew);
                *zNew
                    .offset(
                        n.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,
                    ) = 0 as libc::c_int as libc::c_char;
                zToFree = zNew;
                z = zNew;
                break;
            } else {
                sqlite3_free(zNew as *mut libc::c_void);
                i += 1;
            }
        }
    }
    if sqlite3_strglob(b"CREATE TABLE ['\"]*\0" as *const u8 as *const libc::c_char, z)
        == 0 as libc::c_int
    {
        fprintf(
            out,
            b"CREATE TABLE IF NOT EXISTS %s%s\0" as *const u8 as *const libc::c_char,
            z.offset(13 as libc::c_int as isize),
            zTail,
        );
    } else {
        fprintf(out, b"%s%s\0" as *const u8 as *const libc::c_char, z, zTail);
    }
    sqlite3_free(zToFree as *mut libc::c_void);
}
unsafe extern "C" fn printSchemaLineN(
    mut out: *mut FILE,
    mut z: *mut libc::c_char,
    mut n: libc::c_int,
    mut zTail: *const libc::c_char,
) {
    let mut c: libc::c_char = *z.offset(n as isize);
    *z.offset(n as isize) = 0 as libc::c_int as libc::c_char;
    printSchemaLine(out, z, zTail);
    *z.offset(n as isize) = c;
}
unsafe extern "C" fn wsToEol(mut z: *const libc::c_char) -> libc::c_int {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while *z.offset(i as isize) != 0 {
        if *z.offset(i as isize) as libc::c_int == '\n' as i32 {
            return 1 as libc::c_int;
        }
        if *(*__ctype_b_loc())
            .offset(*z.offset(i as isize) as libc::c_uchar as libc::c_int as isize)
            as libc::c_int & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
            != 0
        {
            i += 1;
        } else {
            if *z.offset(i as isize) as libc::c_int == '-' as i32
                && *z.offset((i + 1 as libc::c_int) as isize) as libc::c_int
                    == '-' as i32
            {
                return 1 as libc::c_int;
            }
            return 0 as libc::c_int;
        }
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn eqp_append(
    mut p: *mut ShellState,
    mut iEqpId: libc::c_int,
    mut p2: libc::c_int,
    mut zText: *const libc::c_char,
) {
    let mut pNew: *mut EQPGraphRow = 0 as *mut EQPGraphRow;
    let mut nText: i64_0 = 0;
    if zText.is_null() {
        return;
    }
    nText = strlen(zText) as i64_0;
    if (*p).autoEQPtest != 0 {
        fprintf(
            (*p).out,
            b"%d,%d,%s\n\0" as *const u8 as *const libc::c_char,
            iEqpId,
            p2,
            zText,
        );
    }
    pNew = sqlite3_malloc64(
        (::std::mem::size_of::<EQPGraphRow>() as libc::c_ulong as libc::c_ulonglong)
            .wrapping_add(nText as libc::c_ulonglong),
    ) as *mut EQPGraphRow;
    shell_check_oom(pNew as *mut libc::c_void);
    (*pNew).iEqpId = iEqpId;
    (*pNew).iParentId = p2;
    memcpy(
        ((*pNew).zText).as_mut_ptr() as *mut libc::c_void,
        zText as *const libc::c_void,
        (nText + 1 as libc::c_int as libc::c_longlong) as libc::c_ulong,
    );
    let ref mut fresh326 = (*pNew).pNext;
    *fresh326 = 0 as *mut EQPGraphRow;
    if !((*p).sGraph.pLast).is_null() {
        let ref mut fresh327 = (*(*p).sGraph.pLast).pNext;
        *fresh327 = pNew;
    } else {
        let ref mut fresh328 = (*p).sGraph.pRow;
        *fresh328 = pNew;
    }
    let ref mut fresh329 = (*p).sGraph.pLast;
    *fresh329 = pNew;
}
unsafe extern "C" fn eqp_reset(mut p: *mut ShellState) {
    let mut pRow: *mut EQPGraphRow = 0 as *mut EQPGraphRow;
    let mut pNext: *mut EQPGraphRow = 0 as *mut EQPGraphRow;
    pRow = (*p).sGraph.pRow;
    while !pRow.is_null() {
        pNext = (*pRow).pNext;
        sqlite3_free(pRow as *mut libc::c_void);
        pRow = pNext;
    }
    memset(
        &mut (*p).sGraph as *mut EQPGraph as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<EQPGraph>() as libc::c_ulong,
    );
}
unsafe extern "C" fn eqp_next_row(
    mut p: *mut ShellState,
    mut iEqpId: libc::c_int,
    mut pOld: *mut EQPGraphRow,
) -> *mut EQPGraphRow {
    let mut pRow: *mut EQPGraphRow = if !pOld.is_null() {
        (*pOld).pNext
    } else {
        (*p).sGraph.pRow
    };
    while !pRow.is_null() && (*pRow).iParentId != iEqpId {
        pRow = (*pRow).pNext;
    }
    return pRow;
}
unsafe extern "C" fn eqp_render_level(mut p: *mut ShellState, mut iEqpId: libc::c_int) {
    let mut pRow: *mut EQPGraphRow = 0 as *mut EQPGraphRow;
    let mut pNext: *mut EQPGraphRow = 0 as *mut EQPGraphRow;
    let mut n: i64_0 = strlen(((*p).sGraph.zPrefix).as_mut_ptr()) as i64_0;
    let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
    pRow = eqp_next_row(p, iEqpId, 0 as *mut EQPGraphRow);
    while !pRow.is_null() {
        pNext = eqp_next_row(p, iEqpId, pRow);
        z = ((*pRow).zText).as_mut_ptr();
        fprintf(
            (*p).out,
            b"%s%s%s\n\0" as *const u8 as *const libc::c_char,
            ((*p).sGraph.zPrefix).as_mut_ptr(),
            if !pNext.is_null() {
                b"|--\0" as *const u8 as *const libc::c_char
            } else {
                b"`--\0" as *const u8 as *const libc::c_char
            },
            z,
        );
        if n
            < ::std::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong as i64_0
                - 7 as libc::c_int as libc::c_longlong
        {
            memcpy(
                &mut *((*p).sGraph.zPrefix).as_mut_ptr().offset(n as isize)
                    as *mut libc::c_char as *mut libc::c_void,
                (if !pNext.is_null() {
                    b"|  \0" as *const u8 as *const libc::c_char
                } else {
                    b"   \0" as *const u8 as *const libc::c_char
                }) as *const libc::c_void,
                4 as libc::c_int as libc::c_ulong,
            );
            eqp_render_level(p, (*pRow).iEqpId);
            (*p).sGraph.zPrefix[n as usize] = 0 as libc::c_int as libc::c_char;
        }
        pRow = pNext;
    }
}
unsafe extern "C" fn eqp_render(mut p: *mut ShellState) {
    let mut pRow: *mut EQPGraphRow = (*p).sGraph.pRow;
    if !pRow.is_null() {
        if *((*pRow).zText).as_mut_ptr().offset(0 as libc::c_int as isize) as libc::c_int
            == '-' as i32
        {
            if ((*pRow).pNext).is_null() {
                eqp_reset(p);
                return;
            }
            fprintf(
                (*p).out,
                b"%s\n\0" as *const u8 as *const libc::c_char,
                ((*pRow).zText).as_mut_ptr().offset(3 as libc::c_int as isize),
            );
            let ref mut fresh330 = (*p).sGraph.pRow;
            *fresh330 = (*pRow).pNext;
            sqlite3_free(pRow as *mut libc::c_void);
        } else {
            fprintf((*p).out, b"QUERY PLAN\n\0" as *const u8 as *const libc::c_char);
        }
        (*p)
            .sGraph
            .zPrefix[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        eqp_render_level(p, 0 as libc::c_int);
        eqp_reset(p);
    }
}
unsafe extern "C" fn progress_handler(
    mut pClientData: *mut libc::c_void,
) -> libc::c_int {
    let mut p: *mut ShellState = pClientData as *mut ShellState;
    let ref mut fresh331 = (*p).nProgress;
    *fresh331 = (*fresh331).wrapping_add(1);
    if (*p).nProgress >= (*p).mxProgress
        && (*p).mxProgress > 0 as libc::c_int as libc::c_uint
    {
        fprintf(
            (*p).out,
            b"Progress limit reached (%u)\n\0" as *const u8 as *const libc::c_char,
            (*p).nProgress,
        );
        if (*p).flgProgress & 0x2 as libc::c_int as libc::c_uint != 0 {
            (*p).nProgress = 0 as libc::c_int as libc::c_uint;
        }
        if (*p).flgProgress & 0x4 as libc::c_int as libc::c_uint != 0 {
            (*p).mxProgress = 0 as libc::c_int as libc::c_uint;
        }
        return 1 as libc::c_int;
    }
    if (*p).flgProgress & 0x1 as libc::c_int as libc::c_uint
        == 0 as libc::c_int as libc::c_uint
    {
        fprintf(
            (*p).out,
            b"Progress %u\n\0" as *const u8 as *const libc::c_char,
            (*p).nProgress,
        );
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn print_dashes(mut out: *mut FILE, mut N: libc::c_int) {
    let zDash: [libc::c_char; 51] = *::std::mem::transmute::<
        &[u8; 51],
        &[libc::c_char; 51],
    >(b"--------------------------------------------------\0");
    let nDash: libc::c_int = (::std::mem::size_of::<[libc::c_char; 51]>()
        as libc::c_ulong)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_int;
    while N > nDash {
        fputs(zDash.as_ptr(), out);
        N -= nDash;
    }
    fprintf(out, b"%.*s\0" as *const u8 as *const libc::c_char, N, zDash.as_ptr());
}
unsafe extern "C" fn print_row_separator(
    mut p: *mut ShellState,
    mut nArg: libc::c_int,
    mut zSep: *const libc::c_char,
) {
    let mut i: libc::c_int = 0;
    if nArg > 0 as libc::c_int {
        fputs(zSep, (*p).out);
        print_dashes(
            (*p).out,
            *((*p).actualWidth).offset(0 as libc::c_int as isize) + 2 as libc::c_int,
        );
        i = 1 as libc::c_int;
        while i < nArg {
            fputs(zSep, (*p).out);
            print_dashes(
                (*p).out,
                *((*p).actualWidth).offset(i as isize) + 2 as libc::c_int,
            );
            i += 1;
        }
        fputs(zSep, (*p).out);
    }
    fputs(b"\n\0" as *const u8 as *const libc::c_char, (*p).out);
}
unsafe extern "C" fn shell_callback(
    mut pArg: *mut libc::c_void,
    mut nArg: libc::c_int,
    mut azArg: *mut *mut libc::c_char,
    mut azCol: *mut *mut libc::c_char,
    mut aiType: *mut libc::c_int,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut p: *mut ShellState = pArg as *mut ShellState;
    if azArg.is_null() {
        return 0 as libc::c_int;
    }
    match (*p).cMode {
        0 => {
            let mut w: libc::c_int = 5 as libc::c_int;
            if !azArg.is_null() {
                i = 0 as libc::c_int;
                while i < nArg {
                    let mut len: libc::c_int = strlen30(
                        if !(*azCol.offset(i as isize)).is_null() {
                            *azCol.offset(i as isize) as *const libc::c_char
                        } else {
                            b"\0" as *const u8 as *const libc::c_char
                        },
                    );
                    if len > w {
                        w = len;
                    }
                    i += 1;
                }
                let ref mut fresh332 = (*p).cnt;
                let fresh333 = *fresh332;
                *fresh332 = *fresh332 + 1;
                if fresh333 > 0 as libc::c_int {
                    fprintf(
                        (*p).out,
                        b"%s\0" as *const u8 as *const libc::c_char,
                        ((*p).rowSeparator).as_mut_ptr(),
                    );
                }
                i = 0 as libc::c_int;
                while i < nArg {
                    fprintf(
                        (*p).out,
                        b"%*s = %s%s\0" as *const u8 as *const libc::c_char,
                        w,
                        *azCol.offset(i as isize),
                        if !(*azArg.offset(i as isize)).is_null() {
                            *azArg.offset(i as isize)
                        } else {
                            ((*p).nullValue).as_mut_ptr()
                        },
                        ((*p).rowSeparator).as_mut_ptr(),
                    );
                    i += 1;
                }
            }
        }
        9 => {
            static mut aExplainWidth: [libc::c_int; 8] = [
                4 as libc::c_int,
                13 as libc::c_int,
                4 as libc::c_int,
                4 as libc::c_int,
                4 as libc::c_int,
                13 as libc::c_int,
                2 as libc::c_int,
                13 as libc::c_int,
            ];
            if nArg
                > (::std::mem::size_of::<[libc::c_int; 8]>() as libc::c_ulong)
                    .wrapping_div(::std::mem::size_of::<libc::c_int>() as libc::c_ulong)
                    as libc::c_int
            {
                nArg = (::std::mem::size_of::<[libc::c_int; 8]>() as libc::c_ulong)
                    .wrapping_div(::std::mem::size_of::<libc::c_int>() as libc::c_ulong)
                    as libc::c_int;
            }
            let ref mut fresh334 = (*p).cnt;
            let fresh335 = *fresh334;
            *fresh334 = *fresh334 + 1;
            if fresh335 == 0 as libc::c_int {
                i = 0 as libc::c_int;
                while i < nArg {
                    let mut w_0: libc::c_int = aExplainWidth[i as usize];
                    utf8_width_print((*p).out, w_0, *azCol.offset(i as isize));
                    fputs(
                        if i == nArg - 1 as libc::c_int {
                            b"\n\0" as *const u8 as *const libc::c_char
                        } else {
                            b"  \0" as *const u8 as *const libc::c_char
                        },
                        (*p).out,
                    );
                    i += 1;
                }
                i = 0 as libc::c_int;
                while i < nArg {
                    let mut w_1: libc::c_int = aExplainWidth[i as usize];
                    print_dashes((*p).out, w_1);
                    fputs(
                        if i == nArg - 1 as libc::c_int {
                            b"\n\0" as *const u8 as *const libc::c_char
                        } else {
                            b"  \0" as *const u8 as *const libc::c_char
                        },
                        (*p).out,
                    );
                    i += 1;
                }
            }
            if !azArg.is_null() {
                i = 0 as libc::c_int;
                while i < nArg {
                    let mut w_2: libc::c_int = aExplainWidth[i as usize];
                    if i == nArg - 1 as libc::c_int {
                        w_2 = 0 as libc::c_int;
                    }
                    if !(*azArg.offset(i as isize)).is_null()
                        && strlenChar(*azArg.offset(i as isize)) > w_2
                    {
                        w_2 = strlenChar(*azArg.offset(i as isize));
                    }
                    if i == 1 as libc::c_int && !((*p).aiIndent).is_null()
                        && !((*p).pStmt).is_null()
                    {
                        if (*p).iIndent < (*p).nIndent {
                            fprintf(
                                (*p).out,
                                b"%*.s\0" as *const u8 as *const libc::c_char,
                                *((*p).aiIndent).offset((*p).iIndent as isize),
                                b"\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        let ref mut fresh336 = (*p).iIndent;
                        *fresh336 += 1;
                    }
                    utf8_width_print(
                        (*p).out,
                        w_2,
                        if !(*azArg.offset(i as isize)).is_null() {
                            *azArg.offset(i as isize)
                        } else {
                            ((*p).nullValue).as_mut_ptr()
                        },
                    );
                    fputs(
                        if i == nArg - 1 as libc::c_int {
                            b"\n\0" as *const u8 as *const libc::c_char
                        } else {
                            b"  \0" as *const u8 as *const libc::c_char
                        },
                        (*p).out,
                    );
                    i += 1;
                }
            }
        }
        3 => {
            printSchemaLine(
                (*p).out,
                *azArg.offset(0 as libc::c_int as isize),
                b";\n\0" as *const u8 as *const libc::c_char,
            );
        }
        11 => {
            let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
            let mut j: libc::c_int = 0;
            let mut nParen: libc::c_int = 0 as libc::c_int;
            let mut cEnd: libc::c_char = 0 as libc::c_int as libc::c_char;
            let mut c: libc::c_char = 0;
            let mut nLine: libc::c_int = 0 as libc::c_int;
            if !(*azArg.offset(0 as libc::c_int as isize)).is_null() {
                if sqlite3_strlike(
                    b"CREATE VIEW%\0" as *const u8 as *const libc::c_char,
                    *azArg.offset(0 as libc::c_int as isize),
                    0 as libc::c_int as libc::c_uint,
                ) == 0 as libc::c_int
                    || sqlite3_strlike(
                        b"CREATE TRIG%\0" as *const u8 as *const libc::c_char,
                        *azArg.offset(0 as libc::c_int as isize),
                        0 as libc::c_int as libc::c_uint,
                    ) == 0 as libc::c_int
                {
                    fprintf(
                        (*p).out,
                        b"%s;\n\0" as *const u8 as *const libc::c_char,
                        *azArg.offset(0 as libc::c_int as isize),
                    );
                } else {
                    z = sqlite3_mprintf(
                        b"%s\0" as *const u8 as *const libc::c_char,
                        *azArg.offset(0 as libc::c_int as isize),
                    );
                    shell_check_oom(z as *mut libc::c_void);
                    j = 0 as libc::c_int;
                    i = 0 as libc::c_int;
                    while *(*__ctype_b_loc())
                        .offset(
                            *z.offset(i as isize) as libc::c_uchar as libc::c_int
                                as isize,
                        ) as libc::c_int
                        & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0
                    {
                        i += 1;
                    }
                    let mut current_block_58: u64;
                    loop {
                        c = *z.offset(i as isize);
                        if !(c as libc::c_int != 0 as libc::c_int) {
                            break;
                        }
                        if *(*__ctype_b_loc())
                            .offset(c as libc::c_uchar as libc::c_int as isize)
                            as libc::c_int
                            & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                            != 0
                        {
                            if *z.offset((j - 1 as libc::c_int) as isize) as libc::c_int
                                == '\r' as i32
                            {
                                *z
                                    .offset(
                                        (j - 1 as libc::c_int) as isize,
                                    ) = '\n' as i32 as libc::c_char;
                            }
                            if *(*__ctype_b_loc())
                                .offset(
                                    *z.offset((j - 1 as libc::c_int) as isize) as libc::c_uchar
                                        as libc::c_int as isize,
                                ) as libc::c_int
                                & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                                != 0
                                || *z.offset((j - 1 as libc::c_int) as isize) as libc::c_int
                                    == '(' as i32
                            {
                                current_block_58 = 13484060386966298149;
                            } else {
                                current_block_58 = 1352918242886884122;
                            }
                        } else {
                            if (c as libc::c_int == '(' as i32
                                || c as libc::c_int == ')' as i32) && j > 0 as libc::c_int
                                && *(*__ctype_b_loc())
                                    .offset(
                                        *z.offset((j - 1 as libc::c_int) as isize) as libc::c_uchar
                                            as libc::c_int as isize,
                                    ) as libc::c_int
                                    & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                                    != 0
                            {
                                j -= 1;
                            }
                            current_block_58 = 1352918242886884122;
                        }
                        match current_block_58 {
                            1352918242886884122 => {
                                let fresh337 = j;
                                j = j + 1;
                                *z.offset(fresh337 as isize) = c;
                            }
                            _ => {}
                        }
                        i += 1;
                    }
                    while j > 0 as libc::c_int
                        && *(*__ctype_b_loc())
                            .offset(
                                *z.offset((j - 1 as libc::c_int) as isize) as libc::c_uchar
                                    as libc::c_int as isize,
                            ) as libc::c_int
                            & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                            != 0
                    {
                        j -= 1;
                    }
                    *z.offset(j as isize) = 0 as libc::c_int as libc::c_char;
                    if strlen30(z) >= 79 as libc::c_int {
                        j = 0 as libc::c_int;
                        i = j;
                        loop {
                            c = *z.offset(i as isize);
                            if !(c as libc::c_int != 0 as libc::c_int) {
                                break;
                            }
                            if c as libc::c_int == cEnd as libc::c_int {
                                cEnd = 0 as libc::c_int as libc::c_char;
                            } else if c as libc::c_int == '"' as i32
                                || c as libc::c_int == '\'' as i32
                                || c as libc::c_int == '`' as i32
                            {
                                cEnd = c;
                            } else if c as libc::c_int == '[' as i32 {
                                cEnd = ']' as i32 as libc::c_char;
                            } else if c as libc::c_int == '-' as i32
                                && *z.offset((i + 1 as libc::c_int) as isize) as libc::c_int
                                    == '-' as i32
                            {
                                cEnd = '\n' as i32 as libc::c_char;
                            } else if c as libc::c_int == '(' as i32 {
                                nParen += 1;
                            } else if c as libc::c_int == ')' as i32 {
                                nParen -= 1;
                                if nLine > 0 as libc::c_int && nParen == 0 as libc::c_int
                                    && j > 0 as libc::c_int
                                {
                                    printSchemaLineN(
                                        (*p).out,
                                        z,
                                        j,
                                        b"\n\0" as *const u8 as *const libc::c_char,
                                    );
                                    j = 0 as libc::c_int;
                                }
                            }
                            let fresh338 = j;
                            j = j + 1;
                            *z.offset(fresh338 as isize) = c;
                            if nParen == 1 as libc::c_int
                                && cEnd as libc::c_int == 0 as libc::c_int
                                && (c as libc::c_int == '(' as i32
                                    || c as libc::c_int == '\n' as i32
                                    || c as libc::c_int == ',' as i32
                                        && wsToEol(
                                            z.offset(i as isize).offset(1 as libc::c_int as isize),
                                        ) == 0)
                            {
                                if c as libc::c_int == '\n' as i32 {
                                    j -= 1;
                                }
                                printSchemaLineN(
                                    (*p).out,
                                    z,
                                    j,
                                    b"\n  \0" as *const u8 as *const libc::c_char,
                                );
                                j = 0 as libc::c_int;
                                nLine += 1;
                                while *(*__ctype_b_loc())
                                    .offset(
                                        *z.offset((i + 1 as libc::c_int) as isize) as libc::c_uchar
                                            as libc::c_int as isize,
                                    ) as libc::c_int
                                    & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                                    != 0
                                {
                                    i += 1;
                                }
                            }
                            i += 1;
                        }
                        *z.offset(j as isize) = 0 as libc::c_int as libc::c_char;
                    }
                    printSchemaLine(
                        (*p).out,
                        z,
                        b";\n\0" as *const u8 as *const libc::c_char,
                    );
                    sqlite3_free(z as *mut libc::c_void);
                }
            }
        }
        2 => {
            let ref mut fresh339 = (*p).cnt;
            let fresh340 = *fresh339;
            *fresh339 = *fresh339 + 1;
            if fresh340 == 0 as libc::c_int && (*p).showHeader != 0 {
                i = 0 as libc::c_int;
                while i < nArg {
                    fprintf(
                        (*p).out,
                        b"%s%s\0" as *const u8 as *const libc::c_char,
                        *azCol.offset(i as isize),
                        if i == nArg - 1 as libc::c_int {
                            ((*p).rowSeparator).as_mut_ptr()
                        } else {
                            ((*p).colSeparator).as_mut_ptr()
                        },
                    );
                    i += 1;
                }
            }
            if !azArg.is_null() {
                i = 0 as libc::c_int;
                while i < nArg {
                    let mut z_0: *mut libc::c_char = *azArg.offset(i as isize);
                    if z_0.is_null() {
                        z_0 = ((*p).nullValue).as_mut_ptr();
                    }
                    fprintf((*p).out, b"%s\0" as *const u8 as *const libc::c_char, z_0);
                    if i < nArg - 1 as libc::c_int {
                        fprintf(
                            (*p).out,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            ((*p).colSeparator).as_mut_ptr(),
                        );
                    } else {
                        fprintf(
                            (*p).out,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            ((*p).rowSeparator).as_mut_ptr(),
                        );
                    }
                    i += 1;
                }
            }
        }
        4 => {
            let ref mut fresh341 = (*p).cnt;
            let fresh342 = *fresh341;
            *fresh341 = *fresh341 + 1;
            if fresh342 == 0 as libc::c_int && (*p).showHeader != 0 {
                fprintf((*p).out, b"<TR>\0" as *const u8 as *const libc::c_char);
                i = 0 as libc::c_int;
                while i < nArg {
                    fprintf((*p).out, b"<TH>\0" as *const u8 as *const libc::c_char);
                    output_html_string((*p).out, *azCol.offset(i as isize));
                    fprintf((*p).out, b"</TH>\n\0" as *const u8 as *const libc::c_char);
                    i += 1;
                }
                fprintf((*p).out, b"</TR>\n\0" as *const u8 as *const libc::c_char);
            }
            if !azArg.is_null() {
                fprintf((*p).out, b"<TR>\0" as *const u8 as *const libc::c_char);
                i = 0 as libc::c_int;
                while i < nArg {
                    fprintf((*p).out, b"<TD>\0" as *const u8 as *const libc::c_char);
                    output_html_string(
                        (*p).out,
                        if !(*azArg.offset(i as isize)).is_null() {
                            *azArg.offset(i as isize)
                        } else {
                            ((*p).nullValue).as_mut_ptr()
                        },
                    );
                    fprintf((*p).out, b"</TD>\n\0" as *const u8 as *const libc::c_char);
                    i += 1;
                }
                fprintf((*p).out, b"</TR>\n\0" as *const u8 as *const libc::c_char);
            }
        }
        7 => {
            let ref mut fresh343 = (*p).cnt;
            let fresh344 = *fresh343;
            *fresh343 = *fresh343 + 1;
            if fresh344 == 0 as libc::c_int && (*p).showHeader != 0 {
                i = 0 as libc::c_int;
                while i < nArg {
                    output_c_string(
                        (*p).out,
                        if !(*azCol.offset(i as isize)).is_null() {
                            *azCol.offset(i as isize) as *const libc::c_char
                        } else {
                            b"\0" as *const u8 as *const libc::c_char
                        },
                    );
                    if i < nArg - 1 as libc::c_int {
                        fprintf(
                            (*p).out,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            ((*p).colSeparator).as_mut_ptr(),
                        );
                    }
                    i += 1;
                }
                fprintf(
                    (*p).out,
                    b"%s\0" as *const u8 as *const libc::c_char,
                    ((*p).rowSeparator).as_mut_ptr(),
                );
            }
            if !azArg.is_null() {
                i = 0 as libc::c_int;
                while i < nArg {
                    output_c_string(
                        (*p).out,
                        if !(*azArg.offset(i as isize)).is_null() {
                            *azArg.offset(i as isize)
                        } else {
                            ((*p).nullValue).as_mut_ptr()
                        },
                    );
                    if i < nArg - 1 as libc::c_int {
                        fprintf(
                            (*p).out,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            ((*p).colSeparator).as_mut_ptr(),
                        );
                    }
                    i += 1;
                }
                fprintf(
                    (*p).out,
                    b"%s\0" as *const u8 as *const libc::c_char,
                    ((*p).rowSeparator).as_mut_ptr(),
                );
            }
        }
        8 => {
            let ref mut fresh345 = (*p).cnt;
            let fresh346 = *fresh345;
            *fresh345 = *fresh345 + 1;
            if fresh346 == 0 as libc::c_int && (*p).showHeader != 0 {
                i = 0 as libc::c_int;
                while i < nArg {
                    output_csv(
                        p,
                        if !(*azCol.offset(i as isize)).is_null() {
                            *azCol.offset(i as isize) as *const libc::c_char
                        } else {
                            b"\0" as *const u8 as *const libc::c_char
                        },
                        (i < nArg - 1 as libc::c_int) as libc::c_int,
                    );
                    i += 1;
                }
                fprintf(
                    (*p).out,
                    b"%s\0" as *const u8 as *const libc::c_char,
                    ((*p).rowSeparator).as_mut_ptr(),
                );
            }
            if nArg > 0 as libc::c_int {
                i = 0 as libc::c_int;
                while i < nArg {
                    output_csv(
                        p,
                        *azArg.offset(i as isize),
                        (i < nArg - 1 as libc::c_int) as libc::c_int,
                    );
                    i += 1;
                }
                fprintf(
                    (*p).out,
                    b"%s\0" as *const u8 as *const libc::c_char,
                    ((*p).rowSeparator).as_mut_ptr(),
                );
            }
        }
        5 => {
            if !azArg.is_null() {
                fprintf(
                    (*p).out,
                    b"INSERT INTO %s\0" as *const u8 as *const libc::c_char,
                    (*p).zDestTable,
                );
                if (*p).showHeader != 0 {
                    fprintf((*p).out, b"(\0" as *const u8 as *const libc::c_char);
                    i = 0 as libc::c_int;
                    while i < nArg {
                        if i > 0 as libc::c_int {
                            fprintf(
                                (*p).out,
                                b",\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        if quoteChar(*azCol.offset(i as isize)) != 0 {
                            let mut z_1: *mut libc::c_char = sqlite3_mprintf(
                                b"\"%w\"\0" as *const u8 as *const libc::c_char,
                                *azCol.offset(i as isize),
                            );
                            shell_check_oom(z_1 as *mut libc::c_void);
                            fprintf(
                                (*p).out,
                                b"%s\0" as *const u8 as *const libc::c_char,
                                z_1,
                            );
                            sqlite3_free(z_1 as *mut libc::c_void);
                        } else {
                            fprintf(
                                (*p).out,
                                b"%s\0" as *const u8 as *const libc::c_char,
                                *azCol.offset(i as isize),
                            );
                        }
                        i += 1;
                    }
                    fprintf((*p).out, b")\0" as *const u8 as *const libc::c_char);
                }
                let ref mut fresh347 = (*p).cnt;
                *fresh347 += 1;
                i = 0 as libc::c_int;
                while i < nArg {
                    fprintf(
                        (*p).out,
                        if i > 0 as libc::c_int {
                            b",\0" as *const u8 as *const libc::c_char
                        } else {
                            b" VALUES(\0" as *const u8 as *const libc::c_char
                        },
                    );
                    if (*azArg.offset(i as isize)).is_null()
                        || !aiType.is_null()
                            && *aiType.offset(i as isize) == 5 as libc::c_int
                    {
                        fprintf((*p).out, b"NULL\0" as *const u8 as *const libc::c_char);
                    } else if !aiType.is_null()
                        && *aiType.offset(i as isize) == 3 as libc::c_int
                    {
                        if (*p).shellFlgs & 0x10 as libc::c_int as libc::c_uint
                            != 0 as libc::c_int as libc::c_uint
                        {
                            output_quoted_string((*p).out, *azArg.offset(i as isize));
                        } else {
                            output_quoted_escaped_string(
                                (*p).out,
                                *azArg.offset(i as isize),
                            );
                        }
                    } else if !aiType.is_null()
                        && *aiType.offset(i as isize) == 1 as libc::c_int
                    {
                        fprintf(
                            (*p).out,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            *azArg.offset(i as isize),
                        );
                    } else if !aiType.is_null()
                        && *aiType.offset(i as isize) == 2 as libc::c_int
                    {
                        let mut z_2: [libc::c_char; 50] = [0; 50];
                        let mut r: libc::c_double = sqlite3_column_double((*p).pStmt, i);
                        let mut ur: sqlite3_uint64 = 0;
                        memcpy(
                            &mut ur as *mut sqlite3_uint64 as *mut libc::c_void,
                            &mut r as *mut libc::c_double as *const libc::c_void,
                            ::std::mem::size_of::<libc::c_double>() as libc::c_ulong,
                        );
                        if ur
                            == 0x7ff0000000000000 as libc::c_longlong
                                as libc::c_ulonglong
                        {
                            fprintf(
                                (*p).out,
                                b"1e999\0" as *const u8 as *const libc::c_char,
                            );
                        } else if ur == 0xfff0000000000000 as libc::c_ulonglong {
                            fprintf(
                                (*p).out,
                                b"-1e999\0" as *const u8 as *const libc::c_char,
                            );
                        } else {
                            let mut ir: sqlite3_int64 = r as sqlite3_int64;
                            if r == ir as libc::c_double {
                                sqlite3_snprintf(
                                    50 as libc::c_int,
                                    z_2.as_mut_ptr(),
                                    b"%lld.0\0" as *const u8 as *const libc::c_char,
                                    ir,
                                );
                            } else {
                                sqlite3_snprintf(
                                    50 as libc::c_int,
                                    z_2.as_mut_ptr(),
                                    b"%!.20g\0" as *const u8 as *const libc::c_char,
                                    r,
                                );
                            }
                            fprintf(
                                (*p).out,
                                b"%s\0" as *const u8 as *const libc::c_char,
                                z_2.as_mut_ptr(),
                            );
                        }
                    } else if !aiType.is_null()
                        && *aiType.offset(i as isize) == 4 as libc::c_int
                        && !((*p).pStmt).is_null()
                    {
                        let mut pBlob: *const libc::c_void = sqlite3_column_blob(
                            (*p).pStmt,
                            i,
                        );
                        let mut nBlob: libc::c_int = sqlite3_column_bytes((*p).pStmt, i);
                        output_hex_blob((*p).out, pBlob, nBlob);
                    } else if isNumber(*azArg.offset(i as isize), 0 as *mut libc::c_int)
                        != 0
                    {
                        fprintf(
                            (*p).out,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            *azArg.offset(i as isize),
                        );
                    } else if (*p).shellFlgs & 0x10 as libc::c_int as libc::c_uint
                        != 0 as libc::c_int as libc::c_uint
                    {
                        output_quoted_string((*p).out, *azArg.offset(i as isize));
                    } else {
                        output_quoted_escaped_string(
                            (*p).out,
                            *azArg.offset(i as isize),
                        );
                    }
                    i += 1;
                }
                fprintf((*p).out, b");\n\0" as *const u8 as *const libc::c_char);
            }
        }
        13 => {
            if !azArg.is_null() {
                if (*p).cnt == 0 as libc::c_int {
                    fputs(b"[{\0" as *const u8 as *const libc::c_char, (*p).out);
                } else {
                    fputs(b",\n{\0" as *const u8 as *const libc::c_char, (*p).out);
                }
                let ref mut fresh348 = (*p).cnt;
                *fresh348 += 1;
                i = 0 as libc::c_int;
                while i < nArg {
                    output_json_string(
                        (*p).out,
                        *azCol.offset(i as isize),
                        -(1 as libc::c_int) as i64_0,
                    );
                    putc(':' as i32, (*p).out);
                    if (*azArg.offset(i as isize)).is_null()
                        || !aiType.is_null()
                            && *aiType.offset(i as isize) == 5 as libc::c_int
                    {
                        fputs(b"null\0" as *const u8 as *const libc::c_char, (*p).out);
                    } else if !aiType.is_null()
                        && *aiType.offset(i as isize) == 2 as libc::c_int
                    {
                        let mut z_3: [libc::c_char; 50] = [0; 50];
                        let mut r_0: libc::c_double = sqlite3_column_double(
                            (*p).pStmt,
                            i,
                        );
                        let mut ur_0: sqlite3_uint64 = 0;
                        memcpy(
                            &mut ur_0 as *mut sqlite3_uint64 as *mut libc::c_void,
                            &mut r_0 as *mut libc::c_double as *const libc::c_void,
                            ::std::mem::size_of::<libc::c_double>() as libc::c_ulong,
                        );
                        if ur_0
                            == 0x7ff0000000000000 as libc::c_longlong
                                as libc::c_ulonglong
                        {
                            fprintf(
                                (*p).out,
                                b"1e999\0" as *const u8 as *const libc::c_char,
                            );
                        } else if ur_0 == 0xfff0000000000000 as libc::c_ulonglong {
                            fprintf(
                                (*p).out,
                                b"-1e999\0" as *const u8 as *const libc::c_char,
                            );
                        } else {
                            sqlite3_snprintf(
                                50 as libc::c_int,
                                z_3.as_mut_ptr(),
                                b"%!.20g\0" as *const u8 as *const libc::c_char,
                                r_0,
                            );
                            fprintf(
                                (*p).out,
                                b"%s\0" as *const u8 as *const libc::c_char,
                                z_3.as_mut_ptr(),
                            );
                        }
                    } else if !aiType.is_null()
                        && *aiType.offset(i as isize) == 4 as libc::c_int
                        && !((*p).pStmt).is_null()
                    {
                        let mut pBlob_0: *const libc::c_void = sqlite3_column_blob(
                            (*p).pStmt,
                            i,
                        );
                        let mut nBlob_0: libc::c_int = sqlite3_column_bytes(
                            (*p).pStmt,
                            i,
                        );
                        output_json_string(
                            (*p).out,
                            pBlob_0 as *const libc::c_char,
                            nBlob_0 as i64_0,
                        );
                    } else if !aiType.is_null()
                        && *aiType.offset(i as isize) == 3 as libc::c_int
                    {
                        output_json_string(
                            (*p).out,
                            *azArg.offset(i as isize),
                            -(1 as libc::c_int) as i64_0,
                        );
                    } else {
                        fprintf(
                            (*p).out,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            *azArg.offset(i as isize),
                        );
                    }
                    if i < nArg - 1 as libc::c_int {
                        putc(',' as i32, (*p).out);
                    }
                    i += 1;
                }
                putc('}' as i32, (*p).out);
            }
        }
        6 => {
            if !azArg.is_null() {
                if (*p).cnt == 0 as libc::c_int && (*p).showHeader != 0 {
                    i = 0 as libc::c_int;
                    while i < nArg {
                        if i > 0 as libc::c_int {
                            fputs(((*p).colSeparator).as_mut_ptr(), (*p).out);
                        }
                        output_quoted_string((*p).out, *azCol.offset(i as isize));
                        i += 1;
                    }
                    fputs(((*p).rowSeparator).as_mut_ptr(), (*p).out);
                }
                let ref mut fresh349 = (*p).cnt;
                *fresh349 += 1;
                i = 0 as libc::c_int;
                while i < nArg {
                    if i > 0 as libc::c_int {
                        fputs(((*p).colSeparator).as_mut_ptr(), (*p).out);
                    }
                    if (*azArg.offset(i as isize)).is_null()
                        || !aiType.is_null()
                            && *aiType.offset(i as isize) == 5 as libc::c_int
                    {
                        fprintf((*p).out, b"NULL\0" as *const u8 as *const libc::c_char);
                    } else if !aiType.is_null()
                        && *aiType.offset(i as isize) == 3 as libc::c_int
                    {
                        output_quoted_string((*p).out, *azArg.offset(i as isize));
                    } else if !aiType.is_null()
                        && *aiType.offset(i as isize) == 1 as libc::c_int
                    {
                        fprintf(
                            (*p).out,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            *azArg.offset(i as isize),
                        );
                    } else if !aiType.is_null()
                        && *aiType.offset(i as isize) == 2 as libc::c_int
                    {
                        let mut z_4: [libc::c_char; 50] = [0; 50];
                        let mut r_1: libc::c_double = sqlite3_column_double(
                            (*p).pStmt,
                            i,
                        );
                        sqlite3_snprintf(
                            50 as libc::c_int,
                            z_4.as_mut_ptr(),
                            b"%!.20g\0" as *const u8 as *const libc::c_char,
                            r_1,
                        );
                        fprintf(
                            (*p).out,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            z_4.as_mut_ptr(),
                        );
                    } else if !aiType.is_null()
                        && *aiType.offset(i as isize) == 4 as libc::c_int
                        && !((*p).pStmt).is_null()
                    {
                        let mut pBlob_1: *const libc::c_void = sqlite3_column_blob(
                            (*p).pStmt,
                            i,
                        );
                        let mut nBlob_1: libc::c_int = sqlite3_column_bytes(
                            (*p).pStmt,
                            i,
                        );
                        output_hex_blob((*p).out, pBlob_1, nBlob_1);
                    } else if isNumber(*azArg.offset(i as isize), 0 as *mut libc::c_int)
                        != 0
                    {
                        fprintf(
                            (*p).out,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            *azArg.offset(i as isize),
                        );
                    } else {
                        output_quoted_string((*p).out, *azArg.offset(i as isize));
                    }
                    i += 1;
                }
                fputs(((*p).rowSeparator).as_mut_ptr(), (*p).out);
            }
        }
        10 => {
            let ref mut fresh350 = (*p).cnt;
            let fresh351 = *fresh350;
            *fresh350 = *fresh350 + 1;
            if fresh351 == 0 as libc::c_int && (*p).showHeader != 0 {
                i = 0 as libc::c_int;
                while i < nArg {
                    if i > 0 as libc::c_int {
                        fprintf(
                            (*p).out,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            ((*p).colSeparator).as_mut_ptr(),
                        );
                    }
                    fprintf(
                        (*p).out,
                        b"%s\0" as *const u8 as *const libc::c_char,
                        if !(*azCol.offset(i as isize)).is_null() {
                            *azCol.offset(i as isize) as *const libc::c_char
                        } else {
                            b"\0" as *const u8 as *const libc::c_char
                        },
                    );
                    i += 1;
                }
                fprintf(
                    (*p).out,
                    b"%s\0" as *const u8 as *const libc::c_char,
                    ((*p).rowSeparator).as_mut_ptr(),
                );
            }
            if !azArg.is_null() {
                i = 0 as libc::c_int;
                while i < nArg {
                    if i > 0 as libc::c_int {
                        fprintf(
                            (*p).out,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            ((*p).colSeparator).as_mut_ptr(),
                        );
                    }
                    fprintf(
                        (*p).out,
                        b"%s\0" as *const u8 as *const libc::c_char,
                        if !(*azArg.offset(i as isize)).is_null() {
                            *azArg.offset(i as isize)
                        } else {
                            ((*p).nullValue).as_mut_ptr()
                        },
                    );
                    i += 1;
                }
                fprintf(
                    (*p).out,
                    b"%s\0" as *const u8 as *const libc::c_char,
                    ((*p).rowSeparator).as_mut_ptr(),
                );
            }
        }
        12 => {
            eqp_append(
                p,
                atoi(*azArg.offset(0 as libc::c_int as isize)),
                atoi(*azArg.offset(1 as libc::c_int as isize)),
                *azArg.offset(3 as libc::c_int as isize),
            );
        }
        17 | 18 | _ => {}
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn callback(
    mut pArg: *mut libc::c_void,
    mut nArg: libc::c_int,
    mut azArg: *mut *mut libc::c_char,
    mut azCol: *mut *mut libc::c_char,
) -> libc::c_int {
    return shell_callback(pArg, nArg, azArg, azCol, 0 as *mut libc::c_int);
}
unsafe extern "C" fn captureOutputCallback(
    mut pArg: *mut libc::c_void,
    mut nArg: libc::c_int,
    mut azArg: *mut *mut libc::c_char,
    mut az: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut p: *mut ShellText = pArg as *mut ShellText;
    let mut i: libc::c_int = 0;
    if azArg.is_null() {
        return 0 as libc::c_int;
    }
    if (*p).n != 0 {
        appendText(
            p,
            b"|\0" as *const u8 as *const libc::c_char,
            0 as libc::c_int as libc::c_char,
        );
    }
    i = 0 as libc::c_int;
    while i < nArg {
        if i != 0 {
            appendText(
                p,
                b",\0" as *const u8 as *const libc::c_char,
                0 as libc::c_int as libc::c_char,
            );
        }
        if !(*azArg.offset(i as isize)).is_null() {
            appendText(p, *azArg.offset(i as isize), 0 as libc::c_int as libc::c_char);
        }
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn createSelftestTable(mut p: *mut ShellState) {
    let mut zErrMsg: *mut libc::c_char = 0 as *mut libc::c_char;
    sqlite3_exec(
        (*p).db,
        b"SAVEPOINT selftest_init;\nCREATE TABLE IF NOT EXISTS selftest(\n  tno INTEGER PRIMARY KEY,\n  op TEXT,\n  cmd TEXT,\n  ans TEXT\n);CREATE TEMP TABLE [_shell$self](op,cmd,ans);\nINSERT INTO [_shell$self](rowid,op,cmd)\n  VALUES(coalesce((SELECT (max(tno)+100)/10 FROM selftest),10),\n         'memo','Tests generated by --init');\nINSERT INTO [_shell$self]\n  SELECT 'run',\n    'SELECT hex(sha3_query(''SELECT type,name,tbl_name,sql FROM sqlite_schema ORDER BY 2'',224))',\n    hex(sha3_query('SELECT type,name,tbl_name,sql FROM sqlite_schema ORDER BY 2',224));\nINSERT INTO [_shell$self]\n  SELECT 'run',    'SELECT hex(sha3_query(''SELECT * FROM \"' ||        printf('%w',name) || '\" NOT INDEXED'',224))',\n    hex(sha3_query(printf('SELECT * FROM \"%w\" NOT INDEXED',name),224))\n  FROM (\n    SELECT name FROM sqlite_schema\n     WHERE type='table'\n       AND name<>'selftest'\n       AND coalesce(rootpage,0)>0\n  )\n ORDER BY name;\nINSERT INTO [_shell$self]\n  VALUES('run','PRAGMA integrity_check','ok');\nINSERT INTO selftest(tno,op,cmd,ans)  SELECT rowid*10,op,cmd,ans FROM [_shell$self];\nDROP TABLE [_shell$self];\0"
            as *const u8 as *const libc::c_char,
        None,
        0 as *mut libc::c_void,
        &mut zErrMsg,
    );
    if !zErrMsg.is_null() {
        fprintf(
            stderr,
            b"SELFTEST initialization failure: %s\n\0" as *const u8
                as *const libc::c_char,
            zErrMsg,
        );
        sqlite3_free(zErrMsg as *mut libc::c_void);
    }
    sqlite3_exec(
        (*p).db,
        b"RELEASE selftest_init\0" as *const u8 as *const libc::c_char,
        None,
        0 as *mut libc::c_void,
        0 as *mut *mut libc::c_char,
    );
}
unsafe extern "C" fn set_table_name(
    mut p: *mut ShellState,
    mut zName: *const libc::c_char,
) {
    let mut i: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut cQuote: libc::c_char = 0;
    let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
    if !((*p).zDestTable).is_null() {
        free((*p).zDestTable as *mut libc::c_void);
        let ref mut fresh352 = (*p).zDestTable;
        *fresh352 = 0 as *mut libc::c_char;
    }
    if zName.is_null() {
        return;
    }
    cQuote = quoteChar(zName);
    n = strlen30(zName);
    if cQuote != 0 {
        n += n + 2 as libc::c_int;
    }
    let ref mut fresh353 = (*p).zDestTable;
    *fresh353 = malloc((n + 1 as libc::c_int) as libc::c_ulong) as *mut libc::c_char;
    z = *fresh353;
    shell_check_oom(z as *mut libc::c_void);
    n = 0 as libc::c_int;
    if cQuote != 0 {
        let fresh354 = n;
        n = n + 1;
        *z.offset(fresh354 as isize) = cQuote;
    }
    i = 0 as libc::c_int;
    while *zName.offset(i as isize) != 0 {
        let fresh355 = n;
        n = n + 1;
        *z.offset(fresh355 as isize) = *zName.offset(i as isize);
        if *zName.offset(i as isize) as libc::c_int == cQuote as libc::c_int {
            let fresh356 = n;
            n = n + 1;
            *z.offset(fresh356 as isize) = cQuote;
        }
        i += 1;
    }
    if cQuote != 0 {
        let fresh357 = n;
        n = n + 1;
        *z.offset(fresh357 as isize) = cQuote;
    }
    *z.offset(n as isize) = 0 as libc::c_int as libc::c_char;
}
unsafe extern "C" fn shell_error_context(
    mut zSql: *const libc::c_char,
    mut db: *mut sqlite3,
) -> *mut libc::c_char {
    let mut iOffset: libc::c_int = 0;
    let mut len: size_t = 0;
    let mut zCode: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zMsg: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut i: libc::c_int = 0;
    if db.is_null() || zSql.is_null()
        || {
            iOffset = sqlite3_error_offset(db);
            iOffset < 0 as libc::c_int
        }
    {
        return sqlite3_mprintf(b"\0" as *const u8 as *const libc::c_char);
    }
    while iOffset > 50 as libc::c_int {
        iOffset -= 1;
        zSql = zSql.offset(1);
        while *zSql.offset(0 as libc::c_int as isize) as libc::c_int
            & 0xc0 as libc::c_int == 0x80 as libc::c_int
        {
            zSql = zSql.offset(1);
            iOffset -= 1;
        }
    }
    len = strlen(zSql);
    if len > 78 as libc::c_int as libc::c_ulong {
        len = 78 as libc::c_int as size_t;
        while *zSql.offset(len as isize) as libc::c_int & 0xc0 as libc::c_int
            == 0x80 as libc::c_int
        {
            len = len.wrapping_sub(1);
        }
    }
    zCode = sqlite3_mprintf(b"%.*s\0" as *const u8 as *const libc::c_char, len, zSql);
    shell_check_oom(zCode as *mut libc::c_void);
    i = 0 as libc::c_int;
    while *zCode.offset(i as isize) != 0 {
        if *(*__ctype_b_loc())
            .offset(*zSql.offset(i as isize) as libc::c_uchar as libc::c_int as isize)
            as libc::c_int & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
            != 0
        {
            *zCode.offset(i as isize) = ' ' as i32 as libc::c_char;
        }
        i += 1;
    }
    if iOffset < 25 as libc::c_int {
        zMsg = sqlite3_mprintf(
            b"\n  %z\n  %*s^--- error here\0" as *const u8 as *const libc::c_char,
            zCode,
            iOffset,
            b"\0" as *const u8 as *const libc::c_char,
        );
    } else {
        zMsg = sqlite3_mprintf(
            b"\n  %z\n  %*serror here ---^\0" as *const u8 as *const libc::c_char,
            zCode,
            iOffset - 14 as libc::c_int,
            b"\0" as *const u8 as *const libc::c_char,
        );
    }
    return zMsg;
}
unsafe extern "C" fn run_table_dump_query(
    mut p: *mut ShellState,
    mut zSelect: *const libc::c_char,
) -> libc::c_int {
    let mut pSelect: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut rc: libc::c_int = 0;
    let mut nResult: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut z: *const libc::c_char = 0 as *const libc::c_char;
    rc = sqlite3_prepare_v2(
        (*p).db,
        zSelect,
        -(1 as libc::c_int),
        &mut pSelect,
        0 as *mut *const libc::c_char,
    );
    if rc != 0 as libc::c_int || pSelect.is_null() {
        let mut zContext: *mut libc::c_char = shell_error_context(zSelect, (*p).db);
        fprintf(
            (*p).out,
            b"/**** ERROR: (%d) %s *****/\n%s\0" as *const u8 as *const libc::c_char,
            rc,
            sqlite3_errmsg((*p).db),
            zContext,
        );
        sqlite3_free(zContext as *mut libc::c_void);
        if rc & 0xff as libc::c_int != 11 as libc::c_int {
            let ref mut fresh358 = (*p).nErr;
            *fresh358 += 1;
        }
        return rc;
    }
    rc = sqlite3_step(pSelect);
    nResult = sqlite3_column_count(pSelect);
    while rc == 100 as libc::c_int {
        z = sqlite3_column_text(pSelect, 0 as libc::c_int) as *const libc::c_char;
        fprintf((*p).out, b"%s\0" as *const u8 as *const libc::c_char, z);
        i = 1 as libc::c_int;
        while i < nResult {
            fprintf(
                (*p).out,
                b",%s\0" as *const u8 as *const libc::c_char,
                sqlite3_column_text(pSelect, i),
            );
            i += 1;
        }
        if z.is_null() {
            z = b"\0" as *const u8 as *const libc::c_char;
        }
        while *z.offset(0 as libc::c_int as isize) as libc::c_int != 0
            && (*z.offset(0 as libc::c_int as isize) as libc::c_int != '-' as i32
                || *z.offset(1 as libc::c_int as isize) as libc::c_int != '-' as i32)
        {
            z = z.offset(1);
        }
        if *z.offset(0 as libc::c_int as isize) != 0 {
            fprintf((*p).out, b"\n;\n\0" as *const u8 as *const libc::c_char);
        } else {
            fprintf((*p).out, b";\n\0" as *const u8 as *const libc::c_char);
        }
        rc = sqlite3_step(pSelect);
    }
    rc = sqlite3_finalize(pSelect);
    if rc != 0 as libc::c_int {
        fprintf(
            (*p).out,
            b"/**** ERROR: (%d) %s *****/\n\0" as *const u8 as *const libc::c_char,
            rc,
            sqlite3_errmsg((*p).db),
        );
        if rc & 0xff as libc::c_int != 11 as libc::c_int {
            let ref mut fresh359 = (*p).nErr;
            *fresh359 += 1;
        }
    }
    return rc;
}
unsafe extern "C" fn save_err_msg(
    mut db: *mut sqlite3,
    mut zPhase: *const libc::c_char,
    mut rc: libc::c_int,
    mut zSql: *const libc::c_char,
) -> *mut libc::c_char {
    let mut zErr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zContext: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut pStr: *mut sqlite3_str = sqlite3_str_new(0 as *mut sqlite3);
    sqlite3_str_appendf(
        pStr,
        b"%s, %s\0" as *const u8 as *const libc::c_char,
        zPhase,
        sqlite3_errmsg(db),
    );
    if rc > 1 as libc::c_int {
        sqlite3_str_appendf(pStr, b" (%d)\0" as *const u8 as *const libc::c_char, rc);
    }
    zContext = shell_error_context(zSql, db);
    if !zContext.is_null() {
        sqlite3_str_appendall(pStr, zContext);
        sqlite3_free(zContext as *mut libc::c_void);
    }
    zErr = sqlite3_str_finish(pStr);
    shell_check_oom(zErr as *mut libc::c_void);
    return zErr;
}
unsafe extern "C" fn displayLinuxIoStats(mut out: *mut FILE) {
    let mut in_0: *mut FILE = 0 as *mut FILE;
    let mut z: [libc::c_char; 200] = [0; 200];
    sqlite3_snprintf(
        ::std::mem::size_of::<[libc::c_char; 200]>() as libc::c_ulong as libc::c_int,
        z.as_mut_ptr(),
        b"/proc/%d/io\0" as *const u8 as *const libc::c_char,
        getpid(),
    );
    in_0 = fopen(z.as_mut_ptr(), b"rb\0" as *const u8 as *const libc::c_char);
    if in_0.is_null() {
        return;
    }
    while !(fgets(
        z.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 200]>() as libc::c_ulong as libc::c_int,
        in_0,
    ))
        .is_null()
    {
        static mut aTrans: [C2RustUnnamed_18; 7] = [
            {
                let mut init = C2RustUnnamed_18 {
                    zPattern: b"rchar: \0" as *const u8 as *const libc::c_char,
                    zDesc: b"Bytes received by read():\0" as *const u8
                        as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_18 {
                    zPattern: b"wchar: \0" as *const u8 as *const libc::c_char,
                    zDesc: b"Bytes sent to write():\0" as *const u8
                        as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_18 {
                    zPattern: b"syscr: \0" as *const u8 as *const libc::c_char,
                    zDesc: b"Read() system calls:\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_18 {
                    zPattern: b"syscw: \0" as *const u8 as *const libc::c_char,
                    zDesc: b"Write() system calls:\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_18 {
                    zPattern: b"read_bytes: \0" as *const u8 as *const libc::c_char,
                    zDesc: b"Bytes read from storage:\0" as *const u8
                        as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_18 {
                    zPattern: b"write_bytes: \0" as *const u8 as *const libc::c_char,
                    zDesc: b"Bytes written to storage:\0" as *const u8
                        as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_18 {
                    zPattern: b"cancelled_write_bytes: \0" as *const u8
                        as *const libc::c_char,
                    zDesc: b"Cancelled write bytes:\0" as *const u8
                        as *const libc::c_char,
                };
                init
            },
        ];
        let mut i: libc::c_int = 0;
        i = 0 as libc::c_int;
        while i
            < (::std::mem::size_of::<[C2RustUnnamed_18; 7]>() as libc::c_ulong)
                .wrapping_div(::std::mem::size_of::<C2RustUnnamed_18>() as libc::c_ulong)
                as libc::c_int
        {
            let mut n: libc::c_int = strlen30(aTrans[i as usize].zPattern);
            if cli_strncmp(aTrans[i as usize].zPattern, z.as_mut_ptr(), n as size_t)
                == 0 as libc::c_int
            {
                fprintf(
                    out,
                    b"%-36s %s\0" as *const u8 as *const libc::c_char,
                    aTrans[i as usize].zDesc,
                    &mut *z.as_mut_ptr().offset(n as isize) as *mut libc::c_char,
                );
                break;
            } else {
                i += 1;
            }
        }
    }
    fclose(in_0);
}
unsafe extern "C" fn displayStatLine(
    mut p: *mut ShellState,
    mut zLabel: *mut libc::c_char,
    mut zFormat: *mut libc::c_char,
    mut iStatusCtrl: libc::c_int,
    mut bReset: libc::c_int,
) {
    let mut iCur: sqlite3_int64 = -(1 as libc::c_int) as sqlite3_int64;
    let mut iHiwtr: sqlite3_int64 = -(1 as libc::c_int) as sqlite3_int64;
    let mut i: libc::c_int = 0;
    let mut nPercent: libc::c_int = 0;
    let mut zLine: [libc::c_char; 200] = [0; 200];
    sqlite3_status64(iStatusCtrl, &mut iCur, &mut iHiwtr, bReset);
    i = 0 as libc::c_int;
    nPercent = 0 as libc::c_int;
    while *zFormat.offset(i as isize) != 0 {
        if *zFormat.offset(i as isize) as libc::c_int == '%' as i32 {
            nPercent += 1;
        }
        i += 1;
    }
    if nPercent > 1 as libc::c_int {
        sqlite3_snprintf(
            ::std::mem::size_of::<[libc::c_char; 200]>() as libc::c_ulong as libc::c_int,
            zLine.as_mut_ptr(),
            zFormat,
            iCur,
            iHiwtr,
        );
    } else {
        sqlite3_snprintf(
            ::std::mem::size_of::<[libc::c_char; 200]>() as libc::c_ulong as libc::c_int,
            zLine.as_mut_ptr(),
            zFormat,
            iHiwtr,
        );
    }
    fprintf(
        (*p).out,
        b"%-36s %s\n\0" as *const u8 as *const libc::c_char,
        zLabel,
        zLine.as_mut_ptr(),
    );
}
unsafe extern "C" fn display_stats(
    mut db: *mut sqlite3,
    mut pArg: *mut ShellState,
    mut bReset: libc::c_int,
) -> libc::c_int {
    let mut iCur: libc::c_int = 0;
    let mut iHiwtr: libc::c_int = 0;
    let mut out: *mut FILE = 0 as *mut FILE;
    if pArg.is_null() || ((*pArg).out).is_null() {
        return 0 as libc::c_int;
    }
    out = (*pArg).out;
    if !((*pArg).pStmt).is_null() && (*pArg).statsOn == 2 as libc::c_int as libc::c_uint
    {
        let mut nCol: libc::c_int = 0;
        let mut i: libc::c_int = 0;
        let mut x: libc::c_int = 0;
        let mut pStmt: *mut sqlite3_stmt = (*pArg).pStmt;
        let mut z: [libc::c_char; 100] = [0; 100];
        nCol = sqlite3_column_count(pStmt);
        fprintf(
            out,
            b"%-36s %d\n\0" as *const u8 as *const libc::c_char,
            b"Number of output columns:\0" as *const u8 as *const libc::c_char,
            nCol,
        );
        i = 0 as libc::c_int;
        while i < nCol {
            sqlite3_snprintf(
                ::std::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong
                    as libc::c_int,
                z.as_mut_ptr(),
                b"Column %d %nname:\0" as *const u8 as *const libc::c_char,
                i,
                &mut x as *mut libc::c_int,
            );
            fprintf(
                out,
                b"%-36s %s\n\0" as *const u8 as *const libc::c_char,
                z.as_mut_ptr(),
                sqlite3_column_name(pStmt, i),
            );
            sqlite3_snprintf(
                30 as libc::c_int,
                z.as_mut_ptr().offset(x as isize),
                b"declared type:\0" as *const u8 as *const libc::c_char,
            );
            fprintf(
                out,
                b"%-36s %s\n\0" as *const u8 as *const libc::c_char,
                z.as_mut_ptr(),
                sqlite3_column_decltype(pStmt, i),
            );
            i += 1;
        }
    }
    if (*pArg).statsOn == 3 as libc::c_int as libc::c_uint {
        if !((*pArg).pStmt).is_null() {
            iCur = sqlite3_stmt_status((*pArg).pStmt, 4 as libc::c_int, bReset);
            fprintf(
                (*pArg).out,
                b"VM-steps: %d\n\0" as *const u8 as *const libc::c_char,
                iCur,
            );
        }
        return 0 as libc::c_int;
    }
    displayStatLine(
        pArg,
        b"Memory Used:\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        b"%lld (max %lld) bytes\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        0 as libc::c_int,
        bReset,
    );
    displayStatLine(
        pArg,
        b"Number of Outstanding Allocations:\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        b"%lld (max %lld)\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        9 as libc::c_int,
        bReset,
    );
    if (*pArg).shellFlgs & 0x1 as libc::c_int as libc::c_uint != 0 {
        displayStatLine(
            pArg,
            b"Number of Pcache Pages Used:\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            b"%lld (max %lld) pages\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            1 as libc::c_int,
            bReset,
        );
    }
    displayStatLine(
        pArg,
        b"Number of Pcache Overflow Bytes:\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        b"%lld (max %lld) bytes\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        2 as libc::c_int,
        bReset,
    );
    displayStatLine(
        pArg,
        b"Largest Allocation:\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        b"%lld bytes\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        5 as libc::c_int,
        bReset,
    );
    displayStatLine(
        pArg,
        b"Largest Pcache Allocation:\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        b"%lld bytes\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        7 as libc::c_int,
        bReset,
    );
    if !db.is_null() {
        if (*pArg).shellFlgs & 0x2 as libc::c_int as libc::c_uint != 0 {
            iCur = -(1 as libc::c_int);
            iHiwtr = iCur;
            sqlite3_db_status(db, 0 as libc::c_int, &mut iCur, &mut iHiwtr, bReset);
            fprintf(
                (*pArg).out,
                b"Lookaside Slots Used:                %d (max %d)\n\0" as *const u8
                    as *const libc::c_char,
                iCur,
                iHiwtr,
            );
            sqlite3_db_status(db, 4 as libc::c_int, &mut iCur, &mut iHiwtr, bReset);
            fprintf(
                (*pArg).out,
                b"Successful lookaside attempts:       %d\n\0" as *const u8
                    as *const libc::c_char,
                iHiwtr,
            );
            sqlite3_db_status(db, 5 as libc::c_int, &mut iCur, &mut iHiwtr, bReset);
            fprintf(
                (*pArg).out,
                b"Lookaside failures due to size:      %d\n\0" as *const u8
                    as *const libc::c_char,
                iHiwtr,
            );
            sqlite3_db_status(db, 6 as libc::c_int, &mut iCur, &mut iHiwtr, bReset);
            fprintf(
                (*pArg).out,
                b"Lookaside failures due to OOM:       %d\n\0" as *const u8
                    as *const libc::c_char,
                iHiwtr,
            );
        }
        iCur = -(1 as libc::c_int);
        iHiwtr = iCur;
        sqlite3_db_status(db, 1 as libc::c_int, &mut iCur, &mut iHiwtr, bReset);
        fprintf(
            (*pArg).out,
            b"Pager Heap Usage:                    %d bytes\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
        iCur = -(1 as libc::c_int);
        iHiwtr = iCur;
        sqlite3_db_status(
            db,
            7 as libc::c_int,
            &mut iCur,
            &mut iHiwtr,
            1 as libc::c_int,
        );
        fprintf(
            (*pArg).out,
            b"Page cache hits:                     %d\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
        iCur = -(1 as libc::c_int);
        iHiwtr = iCur;
        sqlite3_db_status(
            db,
            8 as libc::c_int,
            &mut iCur,
            &mut iHiwtr,
            1 as libc::c_int,
        );
        fprintf(
            (*pArg).out,
            b"Page cache misses:                   %d\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
        iCur = -(1 as libc::c_int);
        iHiwtr = iCur;
        sqlite3_db_status(
            db,
            9 as libc::c_int,
            &mut iCur,
            &mut iHiwtr,
            1 as libc::c_int,
        );
        fprintf(
            (*pArg).out,
            b"Page cache writes:                   %d\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
        iCur = -(1 as libc::c_int);
        iHiwtr = iCur;
        sqlite3_db_status(
            db,
            12 as libc::c_int,
            &mut iCur,
            &mut iHiwtr,
            1 as libc::c_int,
        );
        fprintf(
            (*pArg).out,
            b"Page cache spills:                   %d\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
        iCur = -(1 as libc::c_int);
        iHiwtr = iCur;
        sqlite3_db_status(db, 2 as libc::c_int, &mut iCur, &mut iHiwtr, bReset);
        fprintf(
            (*pArg).out,
            b"Schema Heap Usage:                   %d bytes\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
        iCur = -(1 as libc::c_int);
        iHiwtr = iCur;
        sqlite3_db_status(db, 3 as libc::c_int, &mut iCur, &mut iHiwtr, bReset);
        fprintf(
            (*pArg).out,
            b"Statement Heap/Lookaside Usage:      %d bytes\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
    }
    if !((*pArg).pStmt).is_null() {
        let mut iHit: libc::c_int = 0;
        let mut iMiss: libc::c_int = 0;
        iCur = sqlite3_stmt_status((*pArg).pStmt, 1 as libc::c_int, bReset);
        fprintf(
            (*pArg).out,
            b"Fullscan Steps:                      %d\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
        iCur = sqlite3_stmt_status((*pArg).pStmt, 2 as libc::c_int, bReset);
        fprintf(
            (*pArg).out,
            b"Sort Operations:                     %d\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
        iCur = sqlite3_stmt_status((*pArg).pStmt, 3 as libc::c_int, bReset);
        fprintf(
            (*pArg).out,
            b"Autoindex Inserts:                   %d\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
        iHit = sqlite3_stmt_status((*pArg).pStmt, 8 as libc::c_int, bReset);
        iMiss = sqlite3_stmt_status((*pArg).pStmt, 7 as libc::c_int, bReset);
        if iHit != 0 || iMiss != 0 {
            fprintf(
                (*pArg).out,
                b"Bloom filter bypass taken:           %d/%d\n\0" as *const u8
                    as *const libc::c_char,
                iHit,
                iHit + iMiss,
            );
        }
        iCur = sqlite3_stmt_status((*pArg).pStmt, 4 as libc::c_int, bReset);
        fprintf(
            (*pArg).out,
            b"Virtual Machine Steps:               %d\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
        iCur = sqlite3_stmt_status((*pArg).pStmt, 5 as libc::c_int, bReset);
        fprintf(
            (*pArg).out,
            b"Reprepare operations:                %d\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
        iCur = sqlite3_stmt_status((*pArg).pStmt, 6 as libc::c_int, bReset);
        fprintf(
            (*pArg).out,
            b"Number of times run:                 %d\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
        iCur = sqlite3_stmt_status((*pArg).pStmt, 99 as libc::c_int, bReset);
        fprintf(
            (*pArg).out,
            b"Memory used by prepared stmt:        %d\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
    }
    displayLinuxIoStats((*pArg).out);
    return 0 as libc::c_int;
}
unsafe extern "C" fn display_scanstats(mut db: *mut sqlite3, mut pArg: *mut ShellState) {}
unsafe extern "C" fn str_in_array(
    mut zStr: *const libc::c_char,
    mut azArray: *mut *const libc::c_char,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while !(*azArray.offset(i as isize)).is_null() {
        if 0 as libc::c_int == cli_strcmp(zStr, *azArray.offset(i as isize)) {
            return 1 as libc::c_int;
        }
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn explain_data_prepare(
    mut p: *mut ShellState,
    mut pSql: *mut sqlite3_stmt,
) {
    let mut zSql: *const libc::c_char = 0 as *const libc::c_char;
    let mut z: *const libc::c_char = 0 as *const libc::c_char;
    let mut abYield: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut nAlloc: libc::c_int = 0 as libc::c_int;
    let mut iOp: libc::c_int = 0;
    let mut azNext: [*const libc::c_char; 7] = [
        b"Next\0" as *const u8 as *const libc::c_char,
        b"Prev\0" as *const u8 as *const libc::c_char,
        b"VPrev\0" as *const u8 as *const libc::c_char,
        b"VNext\0" as *const u8 as *const libc::c_char,
        b"SorterNext\0" as *const u8 as *const libc::c_char,
        b"Return\0" as *const u8 as *const libc::c_char,
        0 as *const libc::c_char,
    ];
    let mut azYield: [*const libc::c_char; 6] = [
        b"Yield\0" as *const u8 as *const libc::c_char,
        b"SeekLT\0" as *const u8 as *const libc::c_char,
        b"SeekGT\0" as *const u8 as *const libc::c_char,
        b"RowSetRead\0" as *const u8 as *const libc::c_char,
        b"Rewind\0" as *const u8 as *const libc::c_char,
        0 as *const libc::c_char,
    ];
    let mut azGoto: [*const libc::c_char; 2] = [
        b"Goto\0" as *const u8 as *const libc::c_char,
        0 as *const libc::c_char,
    ];
    if sqlite3_column_count(pSql) != 8 as libc::c_int {
        (*p).cMode = (*p).mode;
        return;
    }
    zSql = sqlite3_sql(pSql);
    if zSql.is_null() {
        return;
    }
    z = zSql;
    while *z as libc::c_int == ' ' as i32 || *z as libc::c_int == '\t' as i32
        || *z as libc::c_int == '\n' as i32 || *z as libc::c_int == '\u{c}' as i32
        || *z as libc::c_int == '\r' as i32
    {
        z = z.offset(1);
    }
    if sqlite3_strnicmp(
        z,
        b"explain\0" as *const u8 as *const libc::c_char,
        7 as libc::c_int,
    ) != 0
    {
        (*p).cMode = (*p).mode;
        return;
    }
    iOp = 0 as libc::c_int;
    while 100 as libc::c_int == sqlite3_step(pSql) {
        let mut i: libc::c_int = 0;
        let mut iAddr: libc::c_int = sqlite3_column_int(pSql, 0 as libc::c_int);
        let mut zOp: *const libc::c_char = sqlite3_column_text(pSql, 1 as libc::c_int)
            as *const libc::c_char;
        let mut p2: libc::c_int = sqlite3_column_int(pSql, 3 as libc::c_int);
        let mut p2op: libc::c_int = p2 + (iOp - iAddr);
        if iOp >= nAlloc {
            if iOp == 0 as libc::c_int {
                static mut explainCols: [*const libc::c_char; 8] = [
                    b"addr\0" as *const u8 as *const libc::c_char,
                    b"opcode\0" as *const u8 as *const libc::c_char,
                    b"p1\0" as *const u8 as *const libc::c_char,
                    b"p2\0" as *const u8 as *const libc::c_char,
                    b"p3\0" as *const u8 as *const libc::c_char,
                    b"p4\0" as *const u8 as *const libc::c_char,
                    b"p5\0" as *const u8 as *const libc::c_char,
                    b"comment\0" as *const u8 as *const libc::c_char,
                ];
                let mut jj: libc::c_int = 0;
                jj = 0 as libc::c_int;
                while jj
                    < (::std::mem::size_of::<[*const libc::c_char; 8]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::std::mem::size_of::<*const libc::c_char>() as libc::c_ulong,
                        ) as libc::c_int
                {
                    if cli_strcmp(
                        sqlite3_column_name(pSql, jj),
                        explainCols[jj as usize],
                    ) != 0 as libc::c_int
                    {
                        (*p).cMode = (*p).mode;
                        sqlite3_reset(pSql);
                        return;
                    }
                    jj += 1;
                }
            }
            nAlloc += 100 as libc::c_int;
            let ref mut fresh360 = (*p).aiIndent;
            *fresh360 = sqlite3_realloc64(
                (*p).aiIndent as *mut libc::c_void,
                (nAlloc as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<libc::c_int>() as libc::c_ulong)
                    as sqlite3_uint64,
            ) as *mut libc::c_int;
            shell_check_oom((*p).aiIndent as *mut libc::c_void);
            abYield = sqlite3_realloc64(
                abYield as *mut libc::c_void,
                (nAlloc as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<libc::c_int>() as libc::c_ulong)
                    as sqlite3_uint64,
            ) as *mut libc::c_int;
            shell_check_oom(abYield as *mut libc::c_void);
        }
        *abYield.offset(iOp as isize) = str_in_array(zOp, azYield.as_mut_ptr());
        *((*p).aiIndent).offset(iOp as isize) = 0 as libc::c_int;
        (*p).nIndent = iOp + 1 as libc::c_int;
        if str_in_array(zOp, azNext.as_mut_ptr()) != 0 && p2op > 0 as libc::c_int {
            i = p2op;
            while i < iOp {
                *((*p).aiIndent).offset(i as isize) += 2 as libc::c_int;
                i += 1;
            }
        }
        if str_in_array(zOp, azGoto.as_mut_ptr()) != 0 && p2op < (*p).nIndent
            && (*abYield.offset(p2op as isize) != 0
                || sqlite3_column_int(pSql, 2 as libc::c_int) != 0)
        {
            i = p2op;
            while i < iOp {
                *((*p).aiIndent).offset(i as isize) += 2 as libc::c_int;
                i += 1;
            }
        }
        iOp += 1;
    }
    (*p).iIndent = 0 as libc::c_int;
    sqlite3_free(abYield as *mut libc::c_void);
    sqlite3_reset(pSql);
}
unsafe extern "C" fn explain_data_delete(mut p: *mut ShellState) {
    sqlite3_free((*p).aiIndent as *mut libc::c_void);
    let ref mut fresh361 = (*p).aiIndent;
    *fresh361 = 0 as *mut libc::c_int;
    (*p).nIndent = 0 as libc::c_int;
    (*p).iIndent = 0 as libc::c_int;
}
static mut savedSelectTrace: libc::c_uint = 0;
static mut savedWhereTrace: libc::c_uint = 0;
unsafe extern "C" fn disable_debug_trace_modes() {
    let mut zero: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    sqlite3_test_control(
        31 as libc::c_int,
        0 as libc::c_int,
        &mut savedSelectTrace as *mut libc::c_uint,
    );
    sqlite3_test_control(
        31 as libc::c_int,
        1 as libc::c_int,
        &mut zero as *mut libc::c_uint,
    );
    sqlite3_test_control(
        31 as libc::c_int,
        2 as libc::c_int,
        &mut savedWhereTrace as *mut libc::c_uint,
    );
    sqlite3_test_control(
        31 as libc::c_int,
        3 as libc::c_int,
        &mut zero as *mut libc::c_uint,
    );
}
unsafe extern "C" fn restore_debug_trace_modes() {
    sqlite3_test_control(
        31 as libc::c_int,
        1 as libc::c_int,
        &mut savedSelectTrace as *mut libc::c_uint,
    );
    sqlite3_test_control(
        31 as libc::c_int,
        3 as libc::c_int,
        &mut savedWhereTrace as *mut libc::c_uint,
    );
}
unsafe extern "C" fn bind_table_init(mut p: *mut ShellState) {
    let mut wrSchema: libc::c_int = 0 as libc::c_int;
    let mut defensiveMode: libc::c_int = 0 as libc::c_int;
    sqlite3_db_config(
        (*p).db,
        1010 as libc::c_int,
        -(1 as libc::c_int),
        &mut defensiveMode as *mut libc::c_int,
    );
    sqlite3_db_config((*p).db, 1010 as libc::c_int, 0 as libc::c_int, 0 as libc::c_int);
    sqlite3_db_config(
        (*p).db,
        1011 as libc::c_int,
        -(1 as libc::c_int),
        &mut wrSchema as *mut libc::c_int,
    );
    sqlite3_db_config((*p).db, 1011 as libc::c_int, 1 as libc::c_int, 0 as libc::c_int);
    sqlite3_exec(
        (*p).db,
        b"CREATE TABLE IF NOT EXISTS temp.sqlite_parameters(\n  key TEXT PRIMARY KEY,\n  value\n) WITHOUT ROWID;\0"
            as *const u8 as *const libc::c_char,
        None,
        0 as *mut libc::c_void,
        0 as *mut *mut libc::c_char,
    );
    sqlite3_db_config((*p).db, 1011 as libc::c_int, wrSchema, 0 as libc::c_int);
    sqlite3_db_config((*p).db, 1010 as libc::c_int, defensiveMode, 0 as libc::c_int);
}
unsafe extern "C" fn bind_prepared_stmt(
    mut pArg: *mut ShellState,
    mut pStmt: *mut sqlite3_stmt,
) {
    let mut nVar: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    let mut pQ: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    nVar = sqlite3_bind_parameter_count(pStmt);
    if nVar == 0 as libc::c_int {
        return;
    }
    if sqlite3_table_column_metadata(
        (*pArg).db,
        b"TEMP\0" as *const u8 as *const libc::c_char,
        b"sqlite_parameters\0" as *const u8 as *const libc::c_char,
        b"key\0" as *const u8 as *const libc::c_char,
        0 as *mut *const libc::c_char,
        0 as *mut *const libc::c_char,
        0 as *mut libc::c_int,
        0 as *mut libc::c_int,
        0 as *mut libc::c_int,
    ) != 0 as libc::c_int
    {
        return;
    }
    rc = sqlite3_prepare_v2(
        (*pArg).db,
        b"SELECT value FROM temp.sqlite_parameters WHERE key=?1\0" as *const u8
            as *const libc::c_char,
        -(1 as libc::c_int),
        &mut pQ,
        0 as *mut *const libc::c_char,
    );
    if rc != 0 || pQ.is_null() {
        return;
    }
    i = 1 as libc::c_int;
    while i <= nVar {
        let mut zNum: [libc::c_char; 30] = [0; 30];
        let mut zVar: *const libc::c_char = sqlite3_bind_parameter_name(pStmt, i);
        if zVar.is_null() {
            sqlite3_snprintf(
                ::std::mem::size_of::<[libc::c_char; 30]>() as libc::c_ulong
                    as libc::c_int,
                zNum.as_mut_ptr(),
                b"?%d\0" as *const u8 as *const libc::c_char,
                i,
            );
            zVar = zNum.as_mut_ptr();
        }
        sqlite3_bind_text(pQ, 1 as libc::c_int, zVar, -(1 as libc::c_int), None);
        if sqlite3_step(pQ) == 100 as libc::c_int {
            sqlite3_bind_value(pStmt, i, sqlite3_column_value(pQ, 0 as libc::c_int));
        } else {
            sqlite3_bind_null(pStmt, i);
        }
        sqlite3_reset(pQ);
        i += 1;
    }
    sqlite3_finalize(pQ);
}
unsafe extern "C" fn print_box_line(mut out: *mut FILE, mut N: libc::c_int) {
    let zDash: [libc::c_char; 61] = *::std::mem::transmute::<
        &[u8; 61],
        &[libc::c_char; 61],
    >(
        b"\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\0",
    );
    let nDash: libc::c_int = (::std::mem::size_of::<[libc::c_char; 61]>()
        as libc::c_ulong)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_int;
    N *= 3 as libc::c_int;
    while N > nDash {
        fprintf(out, zDash.as_ptr());
        N -= nDash;
    }
    fprintf(out, b"%.*s\0" as *const u8 as *const libc::c_char, N, zDash.as_ptr());
}
unsafe extern "C" fn print_box_row_separator(
    mut p: *mut ShellState,
    mut nArg: libc::c_int,
    mut zSep1: *const libc::c_char,
    mut zSep2: *const libc::c_char,
    mut zSep3: *const libc::c_char,
) {
    let mut i: libc::c_int = 0;
    if nArg > 0 as libc::c_int {
        fprintf((*p).out, b"%s\0" as *const u8 as *const libc::c_char, zSep1);
        print_box_line(
            (*p).out,
            *((*p).actualWidth).offset(0 as libc::c_int as isize) + 2 as libc::c_int,
        );
        i = 1 as libc::c_int;
        while i < nArg {
            fprintf((*p).out, b"%s\0" as *const u8 as *const libc::c_char, zSep2);
            print_box_line(
                (*p).out,
                *((*p).actualWidth).offset(i as isize) + 2 as libc::c_int,
            );
            i += 1;
        }
        fprintf((*p).out, b"%s\0" as *const u8 as *const libc::c_char, zSep3);
    }
    fputs(b"\n\0" as *const u8 as *const libc::c_char, (*p).out);
}
unsafe extern "C" fn translateForDisplayAndDup(
    mut z: *const libc::c_uchar,
    mut pzTail: *mut *const libc::c_uchar,
    mut mxWidth: libc::c_int,
    mut bWordWrap: u8_0,
) -> *mut libc::c_char {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut k: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut zOut: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    if z.is_null() {
        *pzTail = 0 as *const libc::c_uchar;
        return 0 as *mut libc::c_char;
    }
    if mxWidth < 0 as libc::c_int {
        mxWidth = -mxWidth;
    }
    if mxWidth == 0 as libc::c_int {
        mxWidth = 1000000 as libc::c_int;
    }
    n = 0 as libc::c_int;
    j = n;
    i = j;
    while n < mxWidth {
        if *z.offset(i as isize) as libc::c_int >= ' ' as i32 {
            n += 1;
            loop {
                i += 1;
                j += 1;
                if !(*z.offset(i as isize) as libc::c_int & 0xc0 as libc::c_int
                    == 0x80 as libc::c_int)
                {
                    break;
                }
            }
        } else {
            if !(*z.offset(i as isize) as libc::c_int == '\t' as i32) {
                break;
            }
            loop {
                n += 1;
                j += 1;
                if !(n & 7 as libc::c_int != 0 as libc::c_int && n < mxWidth) {
                    break;
                }
            }
            i += 1;
        }
    }
    if n >= mxWidth && bWordWrap as libc::c_int != 0 {
        k = i;
        while k > i / 2 as libc::c_int {
            if *(*__ctype_b_loc())
                .offset(
                    *z.offset((k - 1 as libc::c_int) as isize) as libc::c_int as isize,
                ) as libc::c_int
                & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0
            {
                break;
            }
            k -= 1;
        }
        if k <= i / 2 as libc::c_int {
            k = i;
            while k > i / 2 as libc::c_int {
                if *(*__ctype_b_loc())
                    .offset(
                        *z.offset((k - 1 as libc::c_int) as isize) as libc::c_int
                            as isize,
                    ) as libc::c_int
                    & _ISalnum as libc::c_int as libc::c_ushort as libc::c_int
                    != *(*__ctype_b_loc())
                        .offset(*z.offset(k as isize) as libc::c_int as isize)
                        as libc::c_int
                        & _ISalnum as libc::c_int as libc::c_ushort as libc::c_int
                    && *z.offset(k as isize) as libc::c_int & 0xc0 as libc::c_int
                        != 0x80 as libc::c_int
                {
                    break;
                }
                k -= 1;
            }
        }
        if k <= i / 2 as libc::c_int {
            k = i;
        } else {
            i = k;
            while *z.offset(i as isize) as libc::c_int == ' ' as i32 {
                i += 1;
            }
        }
    } else {
        k = i;
    }
    if n >= mxWidth && *z.offset(i as isize) as libc::c_int >= ' ' as i32 {
        *pzTail = &*z.offset(i as isize) as *const libc::c_uchar;
    } else if *z.offset(i as isize) as libc::c_int == '\r' as i32
        && *z.offset((i + 1 as libc::c_int) as isize) as libc::c_int == '\n' as i32
    {
        *pzTail = if *z.offset((i + 2 as libc::c_int) as isize) as libc::c_int != 0 {
            &*z.offset((i + 2 as libc::c_int) as isize) as *const libc::c_uchar
        } else {
            0 as *const libc::c_uchar
        };
    } else if *z.offset(i as isize) as libc::c_int == 0 as libc::c_int
        || *z.offset((i + 1 as libc::c_int) as isize) as libc::c_int == 0 as libc::c_int
    {
        *pzTail = 0 as *const libc::c_uchar;
    } else {
        *pzTail = &*z.offset((i + 1 as libc::c_int) as isize) as *const libc::c_uchar;
    }
    zOut = malloc((j + 1 as libc::c_int) as libc::c_ulong) as *mut libc::c_uchar;
    shell_check_oom(zOut as *mut libc::c_void);
    n = 0 as libc::c_int;
    j = n;
    i = j;
    while i < k {
        if *z.offset(i as isize) as libc::c_int >= ' ' as i32 {
            n += 1;
            loop {
                let fresh362 = i;
                i = i + 1;
                let fresh363 = j;
                j = j + 1;
                *zOut.offset(fresh363 as isize) = *z.offset(fresh362 as isize);
                if !(*z.offset(i as isize) as libc::c_int & 0xc0 as libc::c_int
                    == 0x80 as libc::c_int)
                {
                    break;
                }
            }
        } else {
            if !(*z.offset(i as isize) as libc::c_int == '\t' as i32) {
                break;
            }
            loop {
                n += 1;
                let fresh364 = j;
                j = j + 1;
                *zOut.offset(fresh364 as isize) = ' ' as i32 as libc::c_uchar;
                if !(n & 7 as libc::c_int != 0 as libc::c_int && n < mxWidth) {
                    break;
                }
            }
            i += 1;
        }
    }
    *zOut.offset(j as isize) = 0 as libc::c_int as libc::c_uchar;
    return zOut as *mut libc::c_char;
}
unsafe extern "C" fn quoted_column(
    mut pStmt: *mut sqlite3_stmt,
    mut i: libc::c_int,
) -> *mut libc::c_char {
    match sqlite3_column_type(pStmt, i) {
        5 => return sqlite3_mprintf(b"NULL\0" as *const u8 as *const libc::c_char),
        1 | 2 => {
            return sqlite3_mprintf(
                b"%s\0" as *const u8 as *const libc::c_char,
                sqlite3_column_text(pStmt, i),
            );
        }
        3 => {
            return sqlite3_mprintf(
                b"%Q\0" as *const u8 as *const libc::c_char,
                sqlite3_column_text(pStmt, i),
            );
        }
        4 => {
            let mut j: libc::c_int = 0;
            let mut pStr: *mut sqlite3_str = sqlite3_str_new(0 as *mut sqlite3);
            let mut a: *const libc::c_uchar = sqlite3_column_blob(pStmt, i)
                as *const libc::c_uchar;
            let mut n: libc::c_int = sqlite3_column_bytes(pStmt, i);
            sqlite3_str_append(
                pStr,
                b"x'\0" as *const u8 as *const libc::c_char,
                2 as libc::c_int,
            );
            j = 0 as libc::c_int;
            while j < n {
                sqlite3_str_appendf(
                    pStr,
                    b"%02x\0" as *const u8 as *const libc::c_char,
                    *a.offset(j as isize) as libc::c_int,
                );
                j += 1;
            }
            sqlite3_str_append(
                pStr,
                b"'\0" as *const u8 as *const libc::c_char,
                1 as libc::c_int,
            );
            return sqlite3_str_finish(pStr);
        }
        _ => {}
    }
    return 0 as *mut libc::c_char;
}
unsafe extern "C" fn exec_prepared_stmt_columnar(
    mut p: *mut ShellState,
    mut pStmt: *mut sqlite3_stmt,
) {
    let mut current_block: u64;
    let mut nRow: sqlite3_int64 = 0 as libc::c_int as sqlite3_int64;
    let mut nColumn: libc::c_int = 0 as libc::c_int;
    let mut azData: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
    let mut nAlloc: sqlite3_int64 = 0 as libc::c_int as sqlite3_int64;
    let mut abRowDiv: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut uz: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut z: *const libc::c_char = 0 as *const libc::c_char;
    let mut azQuoted: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
    let mut rc: libc::c_int = 0;
    let mut i: sqlite3_int64 = 0;
    let mut nData: sqlite3_int64 = 0;
    let mut j: libc::c_int = 0;
    let mut nTotal: libc::c_int = 0;
    let mut w: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut colSep: *const libc::c_char = 0 as *const libc::c_char;
    let mut rowSep: *const libc::c_char = 0 as *const libc::c_char;
    let mut azNextLine: *mut *const libc::c_uchar = 0 as *mut *const libc::c_uchar;
    let mut bNextLine: libc::c_int = 0 as libc::c_int;
    let mut bMultiLineRowExists: libc::c_int = 0 as libc::c_int;
    let mut bw: libc::c_int = (*p).cmOpts.bWordWrap as libc::c_int;
    let mut zEmpty: *const libc::c_char = b"\0" as *const u8 as *const libc::c_char;
    let mut zShowNull: *const libc::c_char = ((*p).nullValue).as_mut_ptr();
    rc = sqlite3_step(pStmt);
    if rc != 100 as libc::c_int {
        return;
    }
    nColumn = sqlite3_column_count(pStmt);
    nAlloc = (nColumn * 4 as libc::c_int) as sqlite3_int64;
    if nAlloc <= 0 as libc::c_int as libc::c_longlong {
        nAlloc = 1 as libc::c_int as sqlite3_int64;
    }
    azData = sqlite3_malloc64(
        (nAlloc as libc::c_ulonglong)
            .wrapping_mul(
                ::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong
                    as libc::c_ulonglong,
            ),
    ) as *mut *mut libc::c_char;
    shell_check_oom(azData as *mut libc::c_void);
    azNextLine = sqlite3_malloc64(
        (nColumn as libc::c_ulong)
            .wrapping_mul(::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong)
            as sqlite3_uint64,
    ) as *mut *const libc::c_uchar;
    shell_check_oom(azNextLine as *mut libc::c_void);
    memset(
        azNextLine as *mut libc::c_void,
        0 as libc::c_int,
        (nColumn as libc::c_ulong)
            .wrapping_mul(::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong),
    );
    if (*p).cmOpts.bQuote != 0 {
        azQuoted = sqlite3_malloc64(
            (nColumn as libc::c_ulong)
                .wrapping_mul(
                    ::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong,
                ) as sqlite3_uint64,
        ) as *mut *mut libc::c_char;
        shell_check_oom(azQuoted as *mut libc::c_void);
        memset(
            azQuoted as *mut libc::c_void,
            0 as libc::c_int,
            (nColumn as libc::c_ulong)
                .wrapping_mul(
                    ::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong,
                ),
        );
    }
    abRowDiv = sqlite3_malloc64((nAlloc / nColumn as libc::c_longlong) as sqlite3_uint64)
        as *mut libc::c_char;
    shell_check_oom(abRowDiv as *mut libc::c_void);
    if nColumn > (*p).nWidth {
        let ref mut fresh365 = (*p).colWidth;
        *fresh365 = realloc(
            (*p).colWidth as *mut libc::c_void,
            (((nColumn + 1 as libc::c_int) * 2 as libc::c_int) as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<libc::c_int>() as libc::c_ulong),
        ) as *mut libc::c_int;
        shell_check_oom((*p).colWidth as *mut libc::c_void);
        i = (*p).nWidth as sqlite3_int64;
        while i < nColumn as libc::c_longlong {
            *((*p).colWidth).offset(i as isize) = 0 as libc::c_int;
            i += 1;
        }
        (*p).nWidth = nColumn;
        let ref mut fresh366 = (*p).actualWidth;
        *fresh366 = &mut *((*p).colWidth).offset(nColumn as isize) as *mut libc::c_int;
    }
    memset(
        (*p).actualWidth as *mut libc::c_void,
        0 as libc::c_int,
        (nColumn as libc::c_ulong)
            .wrapping_mul(::std::mem::size_of::<libc::c_int>() as libc::c_ulong),
    );
    i = 0 as libc::c_int as sqlite3_int64;
    while i < nColumn as libc::c_longlong {
        w = *((*p).colWidth).offset(i as isize);
        if w < 0 as libc::c_int {
            w = -w;
        }
        *((*p).actualWidth).offset(i as isize) = w;
        i += 1;
    }
    i = 0 as libc::c_int as sqlite3_int64;
    while i < nColumn as libc::c_longlong {
        let mut zNotUsed: *const libc::c_uchar = 0 as *const libc::c_uchar;
        let mut wx: libc::c_int = *((*p).colWidth).offset(i as isize);
        if wx == 0 as libc::c_int {
            wx = (*p).cmOpts.iWrap;
        }
        if wx < 0 as libc::c_int {
            wx = -wx;
        }
        uz = sqlite3_column_name(pStmt, i as libc::c_int) as *const libc::c_uchar;
        let ref mut fresh367 = *azData.offset(i as isize);
        *fresh367 = translateForDisplayAndDup(uz, &mut zNotUsed, wx, bw as u8_0);
        i += 1;
    }
    loop {
        let mut useNextLine: libc::c_int = bNextLine;
        bNextLine = 0 as libc::c_int;
        if (nRow + 2 as libc::c_int as libc::c_longlong) * nColumn as libc::c_longlong
            >= nAlloc
        {
            nAlloc *= 2 as libc::c_int as libc::c_longlong;
            azData = sqlite3_realloc64(
                azData as *mut libc::c_void,
                (nAlloc as libc::c_ulonglong)
                    .wrapping_mul(
                        ::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong
                            as libc::c_ulonglong,
                    ),
            ) as *mut *mut libc::c_char;
            shell_check_oom(azData as *mut libc::c_void);
            abRowDiv = sqlite3_realloc64(
                abRowDiv as *mut libc::c_void,
                (nAlloc / nColumn as libc::c_longlong) as sqlite3_uint64,
            ) as *mut libc::c_char;
            shell_check_oom(abRowDiv as *mut libc::c_void);
        }
        *abRowDiv.offset(nRow as isize) = 1 as libc::c_int as libc::c_char;
        nRow += 1;
        i = 0 as libc::c_int as sqlite3_int64;
        while i < nColumn as libc::c_longlong {
            let mut wx_0: libc::c_int = *((*p).colWidth).offset(i as isize);
            if wx_0 == 0 as libc::c_int {
                wx_0 = (*p).cmOpts.iWrap;
            }
            if wx_0 < 0 as libc::c_int {
                wx_0 = -wx_0;
            }
            if useNextLine != 0 {
                uz = *azNextLine.offset(i as isize);
                if uz.is_null() {
                    uz = zEmpty as *mut u8_0;
                }
            } else if (*p).cmOpts.bQuote != 0 {
                sqlite3_free(*azQuoted.offset(i as isize) as *mut libc::c_void);
                let ref mut fresh368 = *azQuoted.offset(i as isize);
                *fresh368 = quoted_column(pStmt, i as libc::c_int);
                uz = *azQuoted.offset(i as isize) as *const libc::c_uchar;
            } else {
                uz = sqlite3_column_text(pStmt, i as libc::c_int);
                if uz.is_null() {
                    uz = zShowNull as *mut u8_0;
                }
            }
            let ref mut fresh369 = *azData
                .offset((nRow * nColumn as libc::c_longlong + i) as isize);
            *fresh369 = translateForDisplayAndDup(
                uz,
                &mut *azNextLine.offset(i as isize),
                wx_0,
                bw as u8_0,
            );
            if !(*azNextLine.offset(i as isize)).is_null() {
                bNextLine = 1 as libc::c_int;
                *abRowDiv
                    .offset(
                        (nRow - 1 as libc::c_int as libc::c_longlong) as isize,
                    ) = 0 as libc::c_int as libc::c_char;
                bMultiLineRowExists = 1 as libc::c_int;
            }
            i += 1;
        }
        if !(bNextLine != 0 || sqlite3_step(pStmt) == 100 as libc::c_int) {
            break;
        }
    }
    nTotal = (nColumn as libc::c_longlong
        * (nRow + 1 as libc::c_int as libc::c_longlong)) as libc::c_int;
    i = 0 as libc::c_int as sqlite3_int64;
    while i < nTotal as libc::c_longlong {
        z = *azData.offset(i as isize);
        if z.is_null() {
            z = zEmpty as *mut libc::c_char;
        }
        n = strlenChar(z);
        j = (i % nColumn as libc::c_longlong) as libc::c_int;
        if n > *((*p).actualWidth).offset(j as isize) {
            *((*p).actualWidth).offset(j as isize) = n;
        }
        i += 1;
    }
    if !(seenInterrupt != 0) {
        if !(nColumn == 0 as libc::c_int) {
            match (*p).cMode {
                1 => {
                    colSep = b"  \0" as *const u8 as *const libc::c_char;
                    rowSep = b"\n\0" as *const u8 as *const libc::c_char;
                    if (*p).showHeader != 0 {
                        i = 0 as libc::c_int as sqlite3_int64;
                        while i < nColumn as libc::c_longlong {
                            w = *((*p).actualWidth).offset(i as isize);
                            if *((*p).colWidth).offset(i as isize) < 0 as libc::c_int {
                                w = -w;
                            }
                            utf8_width_print((*p).out, w, *azData.offset(i as isize));
                            fputs(
                                if i == (nColumn - 1 as libc::c_int) as libc::c_longlong {
                                    b"\n\0" as *const u8 as *const libc::c_char
                                } else {
                                    b"  \0" as *const u8 as *const libc::c_char
                                },
                                (*p).out,
                            );
                            i += 1;
                        }
                        i = 0 as libc::c_int as sqlite3_int64;
                        while i < nColumn as libc::c_longlong {
                            print_dashes(
                                (*p).out,
                                *((*p).actualWidth).offset(i as isize),
                            );
                            fputs(
                                if i == (nColumn - 1 as libc::c_int) as libc::c_longlong {
                                    b"\n\0" as *const u8 as *const libc::c_char
                                } else {
                                    b"  \0" as *const u8 as *const libc::c_char
                                },
                                (*p).out,
                            );
                            i += 1;
                        }
                    }
                }
                15 => {
                    colSep = b" | \0" as *const u8 as *const libc::c_char;
                    rowSep = b" |\n\0" as *const u8 as *const libc::c_char;
                    print_row_separator(
                        p,
                        nColumn,
                        b"+\0" as *const u8 as *const libc::c_char,
                    );
                    fputs(b"| \0" as *const u8 as *const libc::c_char, (*p).out);
                    i = 0 as libc::c_int as sqlite3_int64;
                    while i < nColumn as libc::c_longlong {
                        w = *((*p).actualWidth).offset(i as isize);
                        n = strlenChar(*azData.offset(i as isize));
                        fprintf(
                            (*p).out,
                            b"%*s%s%*s\0" as *const u8 as *const libc::c_char,
                            (w - n) / 2 as libc::c_int,
                            b"\0" as *const u8 as *const libc::c_char,
                            *azData.offset(i as isize),
                            (w - n + 1 as libc::c_int) / 2 as libc::c_int,
                            b"\0" as *const u8 as *const libc::c_char,
                        );
                        fputs(
                            if i == (nColumn - 1 as libc::c_int) as libc::c_longlong {
                                b" |\n\0" as *const u8 as *const libc::c_char
                            } else {
                                b" | \0" as *const u8 as *const libc::c_char
                            },
                            (*p).out,
                        );
                        i += 1;
                    }
                    print_row_separator(
                        p,
                        nColumn,
                        b"+\0" as *const u8 as *const libc::c_char,
                    );
                }
                14 => {
                    colSep = b" | \0" as *const u8 as *const libc::c_char;
                    rowSep = b" |\n\0" as *const u8 as *const libc::c_char;
                    fputs(b"| \0" as *const u8 as *const libc::c_char, (*p).out);
                    i = 0 as libc::c_int as sqlite3_int64;
                    while i < nColumn as libc::c_longlong {
                        w = *((*p).actualWidth).offset(i as isize);
                        n = strlenChar(*azData.offset(i as isize));
                        fprintf(
                            (*p).out,
                            b"%*s%s%*s\0" as *const u8 as *const libc::c_char,
                            (w - n) / 2 as libc::c_int,
                            b"\0" as *const u8 as *const libc::c_char,
                            *azData.offset(i as isize),
                            (w - n + 1 as libc::c_int) / 2 as libc::c_int,
                            b"\0" as *const u8 as *const libc::c_char,
                        );
                        fputs(
                            if i == (nColumn - 1 as libc::c_int) as libc::c_longlong {
                                b" |\n\0" as *const u8 as *const libc::c_char
                            } else {
                                b" | \0" as *const u8 as *const libc::c_char
                            },
                            (*p).out,
                        );
                        i += 1;
                    }
                    print_row_separator(
                        p,
                        nColumn,
                        b"|\0" as *const u8 as *const libc::c_char,
                    );
                }
                16 => {
                    colSep = b" \xE2\x94\x82 \0" as *const u8 as *const libc::c_char;
                    rowSep = b" \xE2\x94\x82\n\0" as *const u8 as *const libc::c_char;
                    print_box_row_separator(
                        p,
                        nColumn,
                        b"\xE2\x94\x8C\0" as *const u8 as *const libc::c_char,
                        b"\xE2\x94\xAC\0" as *const u8 as *const libc::c_char,
                        b"\xE2\x94\x90\0" as *const u8 as *const libc::c_char,
                    );
                    fprintf(
                        (*p).out,
                        b"\xE2\x94\x82 \0" as *const u8 as *const libc::c_char,
                    );
                    i = 0 as libc::c_int as sqlite3_int64;
                    while i < nColumn as libc::c_longlong {
                        w = *((*p).actualWidth).offset(i as isize);
                        n = strlenChar(*azData.offset(i as isize));
                        fprintf(
                            (*p).out,
                            b"%*s%s%*s%s\0" as *const u8 as *const libc::c_char,
                            (w - n) / 2 as libc::c_int,
                            b"\0" as *const u8 as *const libc::c_char,
                            *azData.offset(i as isize),
                            (w - n + 1 as libc::c_int) / 2 as libc::c_int,
                            b"\0" as *const u8 as *const libc::c_char,
                            if i == (nColumn - 1 as libc::c_int) as libc::c_longlong {
                                b" \xE2\x94\x82\n\0" as *const u8 as *const libc::c_char
                            } else {
                                b" \xE2\x94\x82 \0" as *const u8 as *const libc::c_char
                            },
                        );
                        i += 1;
                    }
                    print_box_row_separator(
                        p,
                        nColumn,
                        b"\xE2\x94\x9C\0" as *const u8 as *const libc::c_char,
                        b"\xE2\x94\xBC\0" as *const u8 as *const libc::c_char,
                        b"\xE2\x94\xA4\0" as *const u8 as *const libc::c_char,
                    );
                }
                _ => {}
            }
            i = nColumn as sqlite3_int64;
            j = 0 as libc::c_int;
            loop {
                if !(i < nTotal as libc::c_longlong) {
                    current_block = 16107425721173356396;
                    break;
                }
                if j == 0 as libc::c_int && (*p).cMode != 1 as libc::c_int {
                    fprintf(
                        (*p).out,
                        b"%s\0" as *const u8 as *const libc::c_char,
                        if (*p).cMode == 16 as libc::c_int {
                            b"\xE2\x94\x82 \0" as *const u8 as *const libc::c_char
                        } else {
                            b"| \0" as *const u8 as *const libc::c_char
                        },
                    );
                }
                z = *azData.offset(i as isize);
                if z.is_null() {
                    z = ((*p).nullValue).as_mut_ptr();
                }
                w = *((*p).actualWidth).offset(j as isize);
                if *((*p).colWidth).offset(j as isize) < 0 as libc::c_int {
                    w = -w;
                }
                utf8_width_print((*p).out, w, z);
                if j == nColumn - 1 as libc::c_int {
                    fprintf(
                        (*p).out,
                        b"%s\0" as *const u8 as *const libc::c_char,
                        rowSep,
                    );
                    if bMultiLineRowExists != 0
                        && *abRowDiv
                            .offset(
                                (i / nColumn as libc::c_longlong
                                    - 1 as libc::c_int as libc::c_longlong) as isize,
                            ) as libc::c_int != 0
                        && (i + 1 as libc::c_int as libc::c_longlong)
                            < nTotal as libc::c_longlong
                    {
                        if (*p).cMode == 15 as libc::c_int {
                            print_row_separator(
                                p,
                                nColumn,
                                b"+\0" as *const u8 as *const libc::c_char,
                            );
                        } else if (*p).cMode == 16 as libc::c_int {
                            print_box_row_separator(
                                p,
                                nColumn,
                                b"\xE2\x94\x9C\0" as *const u8 as *const libc::c_char,
                                b"\xE2\x94\xBC\0" as *const u8 as *const libc::c_char,
                                b"\xE2\x94\xA4\0" as *const u8 as *const libc::c_char,
                            );
                        } else if (*p).cMode == 1 as libc::c_int {
                            fprintf(
                                (*p).out,
                                b"\n\0" as *const u8 as *const libc::c_char,
                            );
                        }
                    }
                    j = -(1 as libc::c_int);
                    if seenInterrupt != 0 {
                        current_block = 1573929073115242669;
                        break;
                    }
                } else {
                    fprintf(
                        (*p).out,
                        b"%s\0" as *const u8 as *const libc::c_char,
                        colSep,
                    );
                }
                i += 1;
                j += 1;
            }
            match current_block {
                1573929073115242669 => {}
                _ => {
                    if (*p).cMode == 15 as libc::c_int {
                        print_row_separator(
                            p,
                            nColumn,
                            b"+\0" as *const u8 as *const libc::c_char,
                        );
                    } else if (*p).cMode == 16 as libc::c_int {
                        print_box_row_separator(
                            p,
                            nColumn,
                            b"\xE2\x94\x94\0" as *const u8 as *const libc::c_char,
                            b"\xE2\x94\xB4\0" as *const u8 as *const libc::c_char,
                            b"\xE2\x94\x98\0" as *const u8 as *const libc::c_char,
                        );
                    }
                }
            }
        }
    }
    if seenInterrupt != 0 {
        fprintf((*p).out, b"Interrupt\n\0" as *const u8 as *const libc::c_char);
    }
    nData = (nRow + 1 as libc::c_int as libc::c_longlong) * nColumn as libc::c_longlong;
    i = 0 as libc::c_int as sqlite3_int64;
    while i < nData {
        z = *azData.offset(i as isize);
        if z != zEmpty && z != zShowNull {
            free(*azData.offset(i as isize) as *mut libc::c_void);
        }
        i += 1;
    }
    sqlite3_free(azData as *mut libc::c_void);
    sqlite3_free(azNextLine as *mut libc::c_void);
    sqlite3_free(abRowDiv as *mut libc::c_void);
    if !azQuoted.is_null() {
        i = 0 as libc::c_int as sqlite3_int64;
        while i < nColumn as libc::c_longlong {
            sqlite3_free(*azQuoted.offset(i as isize) as *mut libc::c_void);
            i += 1;
        }
        sqlite3_free(azQuoted as *mut libc::c_void);
    }
}
unsafe extern "C" fn exec_prepared_stmt(
    mut pArg: *mut ShellState,
    mut pStmt: *mut sqlite3_stmt,
) {
    let mut rc: libc::c_int = 0;
    let mut nRow: sqlite3_uint64 = 0 as libc::c_int as sqlite3_uint64;
    if (*pArg).cMode == 1 as libc::c_int || (*pArg).cMode == 15 as libc::c_int
        || (*pArg).cMode == 16 as libc::c_int || (*pArg).cMode == 14 as libc::c_int
    {
        exec_prepared_stmt_columnar(pArg, pStmt);
        return;
    }
    rc = sqlite3_step(pStmt);
    if 100 as libc::c_int == rc {
        let mut nCol: libc::c_int = sqlite3_column_count(pStmt);
        let mut pData: *mut libc::c_void = sqlite3_malloc64(
            ((3 as libc::c_int * nCol) as libc::c_ulong)
                .wrapping_mul(
                    ::std::mem::size_of::<*const libc::c_char>() as libc::c_ulong,
                )
                .wrapping_add(1 as libc::c_int as libc::c_ulong) as sqlite3_uint64,
        );
        if pData.is_null() {
            shell_out_of_memory();
        } else {
            let mut azCols: *mut *mut libc::c_char = pData as *mut *mut libc::c_char;
            let mut azVals: *mut *mut libc::c_char = &mut *azCols.offset(nCol as isize)
                as *mut *mut libc::c_char;
            let mut aiTypes: *mut libc::c_int = &mut *azVals.offset(nCol as isize)
                as *mut *mut libc::c_char as *mut libc::c_int;
            let mut i: libc::c_int = 0;
            let mut x: libc::c_int = 0;
            i = 0 as libc::c_int;
            while i < nCol {
                let ref mut fresh370 = *azCols.offset(i as isize);
                *fresh370 = sqlite3_column_name(pStmt, i) as *mut libc::c_char;
                i += 1;
            }
            loop {
                nRow = nRow.wrapping_add(1);
                i = 0 as libc::c_int;
                while i < nCol {
                    x = sqlite3_column_type(pStmt, i);
                    *aiTypes.offset(i as isize) = x;
                    if x == 4 as libc::c_int && !pArg.is_null()
                        && ((*pArg).cMode == 5 as libc::c_int
                            || (*pArg).cMode == 6 as libc::c_int)
                    {
                        let ref mut fresh371 = *azVals.offset(i as isize);
                        *fresh371 = b"\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char;
                    } else {
                        let ref mut fresh372 = *azVals.offset(i as isize);
                        *fresh372 = sqlite3_column_text(pStmt, i) as *mut libc::c_char;
                    }
                    if (*azVals.offset(i as isize)).is_null()
                        && *aiTypes.offset(i as isize) != 5 as libc::c_int
                    {
                        rc = 7 as libc::c_int;
                        break;
                    } else {
                        i += 1;
                    }
                }
                if 100 as libc::c_int == rc {
                    if shell_callback(
                        pArg as *mut libc::c_void,
                        nCol,
                        azVals,
                        azCols,
                        aiTypes,
                    ) != 0
                    {
                        rc = 4 as libc::c_int;
                    } else {
                        rc = sqlite3_step(pStmt);
                    }
                }
                if !(100 as libc::c_int == rc) {
                    break;
                }
            }
            sqlite3_free(pData);
            if (*pArg).cMode == 13 as libc::c_int {
                fputs(b"]\n\0" as *const u8 as *const libc::c_char, (*pArg).out);
            } else if (*pArg).cMode == 17 as libc::c_int {
                let mut zBuf: [libc::c_char; 200] = [0; 200];
                sqlite3_snprintf(
                    ::std::mem::size_of::<[libc::c_char; 200]>() as libc::c_ulong
                        as libc::c_int,
                    zBuf.as_mut_ptr(),
                    b"%llu row%s\n\0" as *const u8 as *const libc::c_char,
                    nRow,
                    if nRow != 1 as libc::c_int as libc::c_ulonglong {
                        b"s\0" as *const u8 as *const libc::c_char
                    } else {
                        b"\0" as *const u8 as *const libc::c_char
                    },
                );
                printf(b"%s\0" as *const u8 as *const libc::c_char, zBuf.as_mut_ptr());
            }
        }
    }
}
unsafe extern "C" fn expertHandleSQL(
    mut pState: *mut ShellState,
    mut zSql: *const libc::c_char,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    return sqlite3_expert_sql((*pState).expert.pExpert, zSql, pzErr);
}
unsafe extern "C" fn expertFinish(
    mut pState: *mut ShellState,
    mut bCancel: libc::c_int,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut p: *mut sqlite3expert = (*pState).expert.pExpert;
    if bCancel == 0 as libc::c_int {
        let mut out: *mut FILE = (*pState).out;
        let mut bVerbose: libc::c_int = (*pState).expert.bVerbose;
        rc = sqlite3_expert_analyze(p, pzErr);
        if rc == 0 as libc::c_int {
            let mut nQuery: libc::c_int = sqlite3_expert_count(p);
            let mut i: libc::c_int = 0;
            if bVerbose != 0 {
                let mut zCand: *const libc::c_char = sqlite3_expert_report(
                    p,
                    0 as libc::c_int,
                    4 as libc::c_int,
                );
                fprintf(
                    out,
                    b"-- Candidates -----------------------------\n\0" as *const u8
                        as *const libc::c_char,
                );
                fprintf(out, b"%s\n\0" as *const u8 as *const libc::c_char, zCand);
            }
            i = 0 as libc::c_int;
            while i < nQuery {
                let mut zSql: *const libc::c_char = sqlite3_expert_report(
                    p,
                    i,
                    1 as libc::c_int,
                );
                let mut zIdx: *const libc::c_char = sqlite3_expert_report(
                    p,
                    i,
                    2 as libc::c_int,
                );
                let mut zEQP: *const libc::c_char = sqlite3_expert_report(
                    p,
                    i,
                    3 as libc::c_int,
                );
                if zIdx.is_null() {
                    zIdx = b"(no new indexes)\n\0" as *const u8 as *const libc::c_char;
                }
                if bVerbose != 0 {
                    fprintf(
                        out,
                        b"-- Query %d --------------------------------\n\0" as *const u8
                            as *const libc::c_char,
                        i + 1 as libc::c_int,
                    );
                    fprintf(out, b"%s\n\n\0" as *const u8 as *const libc::c_char, zSql);
                }
                fprintf(out, b"%s\n\0" as *const u8 as *const libc::c_char, zIdx);
                fprintf(out, b"%s\n\0" as *const u8 as *const libc::c_char, zEQP);
                i += 1;
            }
        }
    }
    sqlite3_expert_destroy(p);
    let ref mut fresh373 = (*pState).expert.pExpert;
    *fresh373 = 0 as *mut sqlite3expert;
    return rc;
}
unsafe extern "C" fn expertDotCommand(
    mut pState: *mut ShellState,
    mut azArg: *mut *mut libc::c_char,
    mut nArg: libc::c_int,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut zErr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut i: libc::c_int = 0;
    let mut iSample: libc::c_int = 0 as libc::c_int;
    memset(
        &mut (*pState).expert as *mut ExpertInfo as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<ExpertInfo>() as libc::c_ulong,
    );
    i = 1 as libc::c_int;
    while rc == 0 as libc::c_int && i < nArg {
        let mut z: *mut libc::c_char = *azArg.offset(i as isize);
        let mut n: libc::c_int = 0;
        if *z.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
            && *z.offset(1 as libc::c_int as isize) as libc::c_int == '-' as i32
        {
            z = z.offset(1);
        }
        n = strlen30(z);
        if n >= 2 as libc::c_int
            && 0 as libc::c_int
                == cli_strncmp(
                    z,
                    b"-verbose\0" as *const u8 as *const libc::c_char,
                    n as size_t,
                )
        {
            (*pState).expert.bVerbose = 1 as libc::c_int;
        } else if n >= 2 as libc::c_int
            && 0 as libc::c_int
                == cli_strncmp(
                    z,
                    b"-sample\0" as *const u8 as *const libc::c_char,
                    n as size_t,
                )
        {
            if i == nArg - 1 as libc::c_int {
                fprintf(
                    stderr,
                    b"option requires an argument: %s\n\0" as *const u8
                        as *const libc::c_char,
                    z,
                );
                rc = 1 as libc::c_int;
            } else {
                i += 1;
                iSample = integerValue(*azArg.offset(i as isize)) as libc::c_int;
                if iSample < 0 as libc::c_int || iSample > 100 as libc::c_int {
                    fprintf(
                        stderr,
                        b"value out of range: %s\n\0" as *const u8
                            as *const libc::c_char,
                        *azArg.offset(i as isize),
                    );
                    rc = 1 as libc::c_int;
                }
            }
        } else {
            fprintf(
                stderr,
                b"unknown option: %s\n\0" as *const u8 as *const libc::c_char,
                z,
            );
            rc = 1 as libc::c_int;
        }
        i += 1;
    }
    if rc == 0 as libc::c_int {
        let ref mut fresh374 = (*pState).expert.pExpert;
        *fresh374 = sqlite3_expert_new((*pState).db, &mut zErr);
        if ((*pState).expert.pExpert).is_null() {
            fprintf(
                stderr,
                b"sqlite3_expert_new: %s\n\0" as *const u8 as *const libc::c_char,
                if !zErr.is_null() {
                    zErr as *const libc::c_char
                } else {
                    b"out of memory\0" as *const u8 as *const libc::c_char
                },
            );
            rc = 1 as libc::c_int;
        } else {
            sqlite3_expert_config((*pState).expert.pExpert, 1 as libc::c_int, iSample);
        }
    }
    sqlite3_free(zErr as *mut libc::c_void);
    return rc;
}
unsafe extern "C" fn shell_exec(
    mut pArg: *mut ShellState,
    mut zSql: *const libc::c_char,
    mut pzErrMsg: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut rc2: libc::c_int = 0;
    let mut zLeftover: *const libc::c_char = 0 as *const libc::c_char;
    let mut db: *mut sqlite3 = (*pArg).db;
    if !pzErrMsg.is_null() {
        *pzErrMsg = 0 as *mut libc::c_char;
    }
    if !((*pArg).expert.pExpert).is_null() {
        rc = expertHandleSQL(pArg, zSql, pzErrMsg);
        return expertFinish(pArg, (rc != 0 as libc::c_int) as libc::c_int, pzErrMsg);
    }
    while *zSql.offset(0 as libc::c_int as isize) as libc::c_int != 0
        && 0 as libc::c_int == rc
    {
        static mut zStmtSql: *const libc::c_char = 0 as *const libc::c_char;
        rc = sqlite3_prepare_v2(
            db,
            zSql,
            -(1 as libc::c_int),
            &mut pStmt,
            &mut zLeftover,
        );
        if 0 as libc::c_int != rc {
            if !pzErrMsg.is_null() {
                *pzErrMsg = save_err_msg(
                    db,
                    b"in prepare\0" as *const u8 as *const libc::c_char,
                    rc,
                    zSql,
                );
            }
        } else if pStmt.is_null() {
            zSql = zLeftover;
            while *(*__ctype_b_loc())
                .offset(
                    *zSql.offset(0 as libc::c_int as isize) as libc::c_uchar
                        as libc::c_int as isize,
                ) as libc::c_int
                & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0
            {
                zSql = zSql.offset(1);
            }
        } else {
            zStmtSql = sqlite3_sql(pStmt);
            if zStmtSql.is_null() {
                zStmtSql = b"\0" as *const u8 as *const libc::c_char;
            }
            while *(*__ctype_b_loc())
                .offset(
                    *zStmtSql.offset(0 as libc::c_int as isize) as libc::c_uchar
                        as libc::c_int as isize,
                ) as libc::c_int
                & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0
            {
                zStmtSql = zStmtSql.offset(1);
            }
            if !pArg.is_null() {
                let ref mut fresh375 = (*pArg).pStmt;
                *fresh375 = pStmt;
                (*pArg).cnt = 0 as libc::c_int;
            }
            if !pArg.is_null() && (*pArg).autoEQP as libc::c_int != 0
                && sqlite3_stmt_isexplain(pStmt) == 0 as libc::c_int
            {
                let mut pExplain: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
                let mut zEQP: *mut libc::c_char = 0 as *mut libc::c_char;
                let mut triggerEQP: libc::c_int = 0 as libc::c_int;
                disable_debug_trace_modes();
                sqlite3_db_config(
                    db,
                    1008 as libc::c_int,
                    -(1 as libc::c_int),
                    &mut triggerEQP as *mut libc::c_int,
                );
                if (*pArg).autoEQP as libc::c_int >= 2 as libc::c_int {
                    sqlite3_db_config(
                        db,
                        1008 as libc::c_int,
                        1 as libc::c_int,
                        0 as libc::c_int,
                    );
                }
                zEQP = sqlite3_mprintf(
                    b"EXPLAIN QUERY PLAN %s\0" as *const u8 as *const libc::c_char,
                    zStmtSql,
                );
                shell_check_oom(zEQP as *mut libc::c_void);
                rc = sqlite3_prepare_v2(
                    db,
                    zEQP,
                    -(1 as libc::c_int),
                    &mut pExplain,
                    0 as *mut *const libc::c_char,
                );
                if rc == 0 as libc::c_int {
                    while sqlite3_step(pExplain) == 100 as libc::c_int {
                        let mut zEQPLine: *const libc::c_char = sqlite3_column_text(
                            pExplain,
                            3 as libc::c_int,
                        ) as *const libc::c_char;
                        let mut iEqpId: libc::c_int = sqlite3_column_int(
                            pExplain,
                            0 as libc::c_int,
                        );
                        let mut iParentId: libc::c_int = sqlite3_column_int(
                            pExplain,
                            1 as libc::c_int,
                        );
                        if zEQPLine.is_null() {
                            zEQPLine = b"\0" as *const u8 as *const libc::c_char;
                        }
                        if *zEQPLine.offset(0 as libc::c_int as isize) as libc::c_int
                            == '-' as i32
                        {
                            eqp_render(pArg);
                        }
                        eqp_append(pArg, iEqpId, iParentId, zEQPLine);
                    }
                    eqp_render(pArg);
                }
                sqlite3_finalize(pExplain);
                sqlite3_free(zEQP as *mut libc::c_void);
                if (*pArg).autoEQP as libc::c_int >= 3 as libc::c_int {
                    zEQP = sqlite3_mprintf(
                        b"EXPLAIN %s\0" as *const u8 as *const libc::c_char,
                        zStmtSql,
                    );
                    shell_check_oom(zEQP as *mut libc::c_void);
                    rc = sqlite3_prepare_v2(
                        db,
                        zEQP,
                        -(1 as libc::c_int),
                        &mut pExplain,
                        0 as *mut *const libc::c_char,
                    );
                    if rc == 0 as libc::c_int {
                        (*pArg).cMode = 9 as libc::c_int;
                        explain_data_prepare(pArg, pExplain);
                        exec_prepared_stmt(pArg, pExplain);
                        explain_data_delete(pArg);
                    }
                    sqlite3_finalize(pExplain);
                    sqlite3_free(zEQP as *mut libc::c_void);
                }
                if (*pArg).autoEQP as libc::c_int >= 2 as libc::c_int
                    && triggerEQP == 0 as libc::c_int
                {
                    sqlite3_db_config(
                        db,
                        1008 as libc::c_int,
                        0 as libc::c_int,
                        0 as libc::c_int,
                    );
                    sqlite3_finalize(pStmt);
                    sqlite3_prepare_v2(
                        db,
                        zSql,
                        -(1 as libc::c_int),
                        &mut pStmt,
                        0 as *mut *const libc::c_char,
                    );
                    if !pArg.is_null() {
                        let ref mut fresh376 = (*pArg).pStmt;
                        *fresh376 = pStmt;
                    }
                }
                restore_debug_trace_modes();
            }
            if !pArg.is_null() {
                (*pArg).cMode = (*pArg).mode;
                if (*pArg).autoExplain != 0 {
                    if sqlite3_stmt_isexplain(pStmt) == 1 as libc::c_int {
                        (*pArg).cMode = 9 as libc::c_int;
                    }
                    if sqlite3_stmt_isexplain(pStmt) == 2 as libc::c_int {
                        (*pArg).cMode = 12 as libc::c_int;
                    }
                }
                if (*pArg).cMode == 9 as libc::c_int {
                    explain_data_prepare(pArg, pStmt);
                }
            }
            bind_prepared_stmt(pArg, pStmt);
            exec_prepared_stmt(pArg, pStmt);
            explain_data_delete(pArg);
            eqp_render(pArg);
            if !pArg.is_null() && (*pArg).statsOn != 0 {
                display_stats(db, pArg, 0 as libc::c_int);
            }
            if !pArg.is_null() && (*pArg).scanstatsOn as libc::c_int != 0 {
                display_scanstats(db, pArg);
            }
            rc2 = sqlite3_finalize(pStmt);
            if rc != 7 as libc::c_int {
                rc = rc2;
            }
            if rc == 0 as libc::c_int {
                zSql = zLeftover;
                while *(*__ctype_b_loc())
                    .offset(
                        *zSql.offset(0 as libc::c_int as isize) as libc::c_uchar
                            as libc::c_int as isize,
                    ) as libc::c_int
                    & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0
                {
                    zSql = zSql.offset(1);
                }
            } else if !pzErrMsg.is_null() {
                *pzErrMsg = save_err_msg(
                    db,
                    b"stepping\0" as *const u8 as *const libc::c_char,
                    rc,
                    0 as *const libc::c_char,
                );
            }
            if !pArg.is_null() {
                let ref mut fresh377 = (*pArg).pStmt;
                *fresh377 = 0 as *mut sqlite3_stmt;
            }
        }
    }
    return rc;
}
unsafe extern "C" fn freeColumnList(mut azCol: *mut *mut libc::c_char) {
    let mut i: libc::c_int = 0;
    i = 1 as libc::c_int;
    while !(*azCol.offset(i as isize)).is_null() {
        sqlite3_free(*azCol.offset(i as isize) as *mut libc::c_void);
        i += 1;
    }
    sqlite3_free(azCol as *mut libc::c_void);
}
unsafe extern "C" fn tableColumnList(
    mut p: *mut ShellState,
    mut zTab: *const libc::c_char,
) -> *mut *mut libc::c_char {
    let mut azCol: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut nCol: libc::c_int = 0 as libc::c_int;
    let mut nAlloc: libc::c_int = 0 as libc::c_int;
    let mut nPK: libc::c_int = 0 as libc::c_int;
    let mut isIPK: libc::c_int = 0 as libc::c_int;
    let mut preserveRowid: libc::c_int = ((*p).shellFlgs
        & 0x8 as libc::c_int as libc::c_uint != 0 as libc::c_int as libc::c_uint)
        as libc::c_int;
    let mut rc: libc::c_int = 0;
    zSql = sqlite3_mprintf(
        b"PRAGMA table_info=%Q\0" as *const u8 as *const libc::c_char,
        zTab,
    );
    shell_check_oom(zSql as *mut libc::c_void);
    rc = sqlite3_prepare_v2(
        (*p).db,
        zSql,
        -(1 as libc::c_int),
        &mut pStmt,
        0 as *mut *const libc::c_char,
    );
    sqlite3_free(zSql as *mut libc::c_void);
    if rc != 0 {
        return 0 as *mut *mut libc::c_char;
    }
    while sqlite3_step(pStmt) == 100 as libc::c_int {
        if nCol >= nAlloc - 2 as libc::c_int {
            nAlloc = nAlloc * 2 as libc::c_int + nCol + 10 as libc::c_int;
            azCol = sqlite3_realloc(
                azCol as *mut libc::c_void,
                (nAlloc as libc::c_ulong)
                    .wrapping_mul(
                        ::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong,
                    ) as libc::c_int,
            ) as *mut *mut libc::c_char;
            shell_check_oom(azCol as *mut libc::c_void);
        }
        nCol += 1;
        let ref mut fresh378 = *azCol.offset(nCol as isize);
        *fresh378 = sqlite3_mprintf(
            b"%s\0" as *const u8 as *const libc::c_char,
            sqlite3_column_text(pStmt, 1 as libc::c_int),
        );
        shell_check_oom(*azCol.offset(nCol as isize) as *mut libc::c_void);
        if sqlite3_column_int(pStmt, 5 as libc::c_int) != 0 {
            nPK += 1;
            if nPK == 1 as libc::c_int
                && sqlite3_stricmp(
                    sqlite3_column_text(pStmt, 2 as libc::c_int) as *const libc::c_char,
                    b"INTEGER\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                isIPK = 1 as libc::c_int;
            } else {
                isIPK = 0 as libc::c_int;
            }
        }
    }
    sqlite3_finalize(pStmt);
    if azCol.is_null() {
        return 0 as *mut *mut libc::c_char;
    }
    let ref mut fresh379 = *azCol.offset(0 as libc::c_int as isize);
    *fresh379 = 0 as *mut libc::c_char;
    let ref mut fresh380 = *azCol.offset((nCol + 1 as libc::c_int) as isize);
    *fresh380 = 0 as *mut libc::c_char;
    if preserveRowid != 0 && isIPK != 0 {
        zSql = sqlite3_mprintf(
            b"SELECT 1 FROM pragma_index_list(%Q) WHERE origin='pk'\0" as *const u8
                as *const libc::c_char,
            zTab,
        );
        shell_check_oom(zSql as *mut libc::c_void);
        rc = sqlite3_prepare_v2(
            (*p).db,
            zSql,
            -(1 as libc::c_int),
            &mut pStmt,
            0 as *mut *const libc::c_char,
        );
        sqlite3_free(zSql as *mut libc::c_void);
        if rc != 0 {
            freeColumnList(azCol);
            return 0 as *mut *mut libc::c_char;
        }
        rc = sqlite3_step(pStmt);
        sqlite3_finalize(pStmt);
        preserveRowid = (rc == 100 as libc::c_int) as libc::c_int;
    }
    if preserveRowid != 0 {
        static mut azRowid: [*mut libc::c_char; 3] = [
            b"rowid\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            b"_rowid_\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            b"oid\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        ];
        let mut i: libc::c_int = 0;
        let mut j: libc::c_int = 0;
        j = 0 as libc::c_int;
        while j < 3 as libc::c_int {
            i = 1 as libc::c_int;
            while i <= nCol {
                if sqlite3_stricmp(azRowid[j as usize], *azCol.offset(i as isize))
                    == 0 as libc::c_int
                {
                    break;
                }
                i += 1;
            }
            if i > nCol {
                rc = sqlite3_table_column_metadata(
                    (*p).db,
                    0 as *const libc::c_char,
                    zTab,
                    azRowid[j as usize],
                    0 as *mut *const libc::c_char,
                    0 as *mut *const libc::c_char,
                    0 as *mut libc::c_int,
                    0 as *mut libc::c_int,
                    0 as *mut libc::c_int,
                );
                if rc == 0 as libc::c_int {
                    let ref mut fresh381 = *azCol.offset(0 as libc::c_int as isize);
                    *fresh381 = azRowid[j as usize];
                }
                break;
            } else {
                j += 1;
            }
        }
    }
    return azCol;
}
unsafe extern "C" fn toggleSelectOrder(mut db: *mut sqlite3) {
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut iSetting: libc::c_int = 0 as libc::c_int;
    let mut zStmt: [libc::c_char; 100] = [0; 100];
    sqlite3_prepare_v2(
        db,
        b"PRAGMA reverse_unordered_selects\0" as *const u8 as *const libc::c_char,
        -(1 as libc::c_int),
        &mut pStmt,
        0 as *mut *const libc::c_char,
    );
    if sqlite3_step(pStmt) == 100 as libc::c_int {
        iSetting = sqlite3_column_int(pStmt, 0 as libc::c_int);
    }
    sqlite3_finalize(pStmt);
    sqlite3_snprintf(
        ::std::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong as libc::c_int,
        zStmt.as_mut_ptr(),
        b"PRAGMA reverse_unordered_selects(%d)\0" as *const u8 as *const libc::c_char,
        (iSetting == 0) as libc::c_int,
    );
    sqlite3_exec(
        db,
        zStmt.as_mut_ptr(),
        None,
        0 as *mut libc::c_void,
        0 as *mut *mut libc::c_char,
    );
}
unsafe extern "C" fn dump_callback(
    mut pArg: *mut libc::c_void,
    mut nArg: libc::c_int,
    mut azArg: *mut *mut libc::c_char,
    mut azNotUsed: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    let mut zTable: *const libc::c_char = 0 as *const libc::c_char;
    let mut zType: *const libc::c_char = 0 as *const libc::c_char;
    let mut zSql: *const libc::c_char = 0 as *const libc::c_char;
    let mut p: *mut ShellState = pArg as *mut ShellState;
    let mut dataOnly: libc::c_int = 0;
    let mut noSys: libc::c_int = 0;
    if nArg != 3 as libc::c_int || azArg.is_null() {
        return 0 as libc::c_int;
    }
    zTable = *azArg.offset(0 as libc::c_int as isize);
    zType = *azArg.offset(1 as libc::c_int as isize);
    zSql = *azArg.offset(2 as libc::c_int as isize);
    if zTable.is_null() {
        return 0 as libc::c_int;
    }
    if zType.is_null() {
        return 0 as libc::c_int;
    }
    dataOnly = ((*p).shellFlgs & 0x100 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint) as libc::c_int;
    noSys = ((*p).shellFlgs & 0x200 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint) as libc::c_int;
    if cli_strcmp(zTable, b"sqlite_sequence\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int && noSys == 0
    {
        if dataOnly == 0 {
            fprintf(
                (*p).out,
                b"DELETE FROM sqlite_sequence;\n\0" as *const u8 as *const libc::c_char,
            );
        }
    } else if sqlite3_strglob(
        b"sqlite_stat?\0" as *const u8 as *const libc::c_char,
        zTable,
    ) == 0 as libc::c_int && noSys == 0
    {
        if dataOnly == 0 {
            fprintf(
                (*p).out,
                b"ANALYZE sqlite_schema;\n\0" as *const u8 as *const libc::c_char,
            );
        }
    } else if cli_strncmp(
        zTable,
        b"sqlite_\0" as *const u8 as *const libc::c_char,
        7 as libc::c_int as size_t,
    ) == 0 as libc::c_int
    {
        return 0 as libc::c_int
    } else {
        if !(dataOnly != 0) {
            if cli_strncmp(
                zSql,
                b"CREATE VIRTUAL TABLE\0" as *const u8 as *const libc::c_char,
                20 as libc::c_int as size_t,
            ) == 0 as libc::c_int
            {
                let mut zIns: *mut libc::c_char = 0 as *mut libc::c_char;
                if (*p).writableSchema == 0 {
                    fprintf(
                        (*p).out,
                        b"PRAGMA writable_schema=ON;\n\0" as *const u8
                            as *const libc::c_char,
                    );
                    (*p).writableSchema = 1 as libc::c_int;
                }
                zIns = sqlite3_mprintf(
                    b"INSERT INTO sqlite_schema(type,name,tbl_name,rootpage,sql)VALUES('table','%q','%q',0,'%q');\0"
                        as *const u8 as *const libc::c_char,
                    zTable,
                    zTable,
                    zSql,
                );
                shell_check_oom(zIns as *mut libc::c_void);
                fprintf((*p).out, b"%s\n\0" as *const u8 as *const libc::c_char, zIns);
                sqlite3_free(zIns as *mut libc::c_void);
                return 0 as libc::c_int;
            } else {
                printSchemaLine(
                    (*p).out,
                    zSql,
                    b";\n\0" as *const u8 as *const libc::c_char,
                );
            }
        }
    }
    if cli_strcmp(zType, b"table\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        let mut sSelect: ShellText = ShellText {
            z: 0 as *mut libc::c_char,
            n: 0,
            nAlloc: 0,
        };
        let mut sTable: ShellText = ShellText {
            z: 0 as *mut libc::c_char,
            n: 0,
            nAlloc: 0,
        };
        let mut azCol: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
        let mut i: libc::c_int = 0;
        let mut savedDestTable: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut savedMode: libc::c_int = 0;
        azCol = tableColumnList(p, zTable);
        if azCol.is_null() {
            let ref mut fresh382 = (*p).nErr;
            *fresh382 += 1;
            return 0 as libc::c_int;
        }
        initText(&mut sTable);
        appendText(&mut sTable, zTable, quoteChar(zTable));
        if !(*azCol.offset(0 as libc::c_int as isize)).is_null() {
            appendText(
                &mut sTable,
                b"(\0" as *const u8 as *const libc::c_char,
                0 as libc::c_int as libc::c_char,
            );
            appendText(
                &mut sTable,
                *azCol.offset(0 as libc::c_int as isize),
                0 as libc::c_int as libc::c_char,
            );
            i = 1 as libc::c_int;
            while !(*azCol.offset(i as isize)).is_null() {
                appendText(
                    &mut sTable,
                    b",\0" as *const u8 as *const libc::c_char,
                    0 as libc::c_int as libc::c_char,
                );
                appendText(
                    &mut sTable,
                    *azCol.offset(i as isize),
                    quoteChar(*azCol.offset(i as isize)),
                );
                i += 1;
            }
            appendText(
                &mut sTable,
                b")\0" as *const u8 as *const libc::c_char,
                0 as libc::c_int as libc::c_char,
            );
        }
        initText(&mut sSelect);
        appendText(
            &mut sSelect,
            b"SELECT \0" as *const u8 as *const libc::c_char,
            0 as libc::c_int as libc::c_char,
        );
        if !(*azCol.offset(0 as libc::c_int as isize)).is_null() {
            appendText(
                &mut sSelect,
                *azCol.offset(0 as libc::c_int as isize),
                0 as libc::c_int as libc::c_char,
            );
            appendText(
                &mut sSelect,
                b",\0" as *const u8 as *const libc::c_char,
                0 as libc::c_int as libc::c_char,
            );
        }
        i = 1 as libc::c_int;
        while !(*azCol.offset(i as isize)).is_null() {
            appendText(
                &mut sSelect,
                *azCol.offset(i as isize),
                quoteChar(*azCol.offset(i as isize)),
            );
            if !(*azCol.offset((i + 1 as libc::c_int) as isize)).is_null() {
                appendText(
                    &mut sSelect,
                    b",\0" as *const u8 as *const libc::c_char,
                    0 as libc::c_int as libc::c_char,
                );
            }
            i += 1;
        }
        freeColumnList(azCol);
        appendText(
            &mut sSelect,
            b" FROM \0" as *const u8 as *const libc::c_char,
            0 as libc::c_int as libc::c_char,
        );
        appendText(&mut sSelect, zTable, quoteChar(zTable));
        savedDestTable = (*p).zDestTable;
        savedMode = (*p).mode;
        let ref mut fresh383 = (*p).zDestTable;
        *fresh383 = sTable.z;
        let ref mut fresh384 = (*p).cMode;
        *fresh384 = 5 as libc::c_int;
        (*p).mode = *fresh384;
        rc = shell_exec(p, sSelect.z, 0 as *mut *mut libc::c_char);
        if rc & 0xff as libc::c_int == 11 as libc::c_int {
            fprintf(
                (*p).out,
                b"/****** CORRUPTION ERROR *******/\n\0" as *const u8
                    as *const libc::c_char,
            );
            toggleSelectOrder((*p).db);
            shell_exec(p, sSelect.z, 0 as *mut *mut libc::c_char);
            toggleSelectOrder((*p).db);
        }
        let ref mut fresh385 = (*p).zDestTable;
        *fresh385 = savedDestTable;
        (*p).mode = savedMode;
        freeText(&mut sTable);
        freeText(&mut sSelect);
        if rc != 0 {
            let ref mut fresh386 = (*p).nErr;
            *fresh386 += 1;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn run_schema_dump_query(
    mut p: *mut ShellState,
    mut zQuery: *const libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    let mut zErr: *mut libc::c_char = 0 as *mut libc::c_char;
    rc = sqlite3_exec(
        (*p).db,
        zQuery,
        Some(
            dump_callback
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    libc::c_int,
                    *mut *mut libc::c_char,
                    *mut *mut libc::c_char,
                ) -> libc::c_int,
        ),
        p as *mut libc::c_void,
        &mut zErr,
    );
    if rc == 11 as libc::c_int {
        let mut zQ2: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut len: libc::c_int = strlen30(zQuery);
        fprintf(
            (*p).out,
            b"/****** CORRUPTION ERROR *******/\n\0" as *const u8 as *const libc::c_char,
        );
        if !zErr.is_null() {
            fprintf(
                (*p).out,
                b"/****** %s ******/\n\0" as *const u8 as *const libc::c_char,
                zErr,
            );
            sqlite3_free(zErr as *mut libc::c_void);
            zErr = 0 as *mut libc::c_char;
        }
        zQ2 = malloc((len + 100 as libc::c_int) as libc::c_ulong) as *mut libc::c_char;
        if zQ2.is_null() {
            return rc;
        }
        sqlite3_snprintf(
            len + 100 as libc::c_int,
            zQ2,
            b"%s ORDER BY rowid DESC\0" as *const u8 as *const libc::c_char,
            zQuery,
        );
        rc = sqlite3_exec(
            (*p).db,
            zQ2,
            Some(
                dump_callback
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        libc::c_int,
                        *mut *mut libc::c_char,
                        *mut *mut libc::c_char,
                    ) -> libc::c_int,
            ),
            p as *mut libc::c_void,
            &mut zErr,
        );
        if rc != 0 {
            fprintf(
                (*p).out,
                b"/****** ERROR: %s ******/\n\0" as *const u8 as *const libc::c_char,
                zErr,
            );
        } else {
            rc = 11 as libc::c_int;
        }
        sqlite3_free(zErr as *mut libc::c_void);
        free(zQ2 as *mut libc::c_void);
    }
    return rc;
}
static mut azHelp: [*const libc::c_char; 202] = [
    b".archive ...             Manage SQL archives\0" as *const u8
        as *const libc::c_char,
    b"   Each command must have exactly one of the following options:\0" as *const u8
        as *const libc::c_char,
    b"     -c, --create               Create a new archive\0" as *const u8
        as *const libc::c_char,
    b"     -u, --update               Add or update files with changed mtime\0"
        as *const u8 as *const libc::c_char,
    b"     -i, --insert               Like -u but always add even if unchanged\0"
        as *const u8 as *const libc::c_char,
    b"     -r, --remove               Remove files from archive\0" as *const u8
        as *const libc::c_char,
    b"     -t, --list                 List contents of archive\0" as *const u8
        as *const libc::c_char,
    b"     -x, --extract              Extract files from archive\0" as *const u8
        as *const libc::c_char,
    b"   Optional arguments:\0" as *const u8 as *const libc::c_char,
    b"     -v, --verbose              Print each filename as it is processed\0"
        as *const u8 as *const libc::c_char,
    b"     -f FILE, --file FILE       Use archive FILE (default is current db)\0"
        as *const u8 as *const libc::c_char,
    b"     -a FILE, --append FILE     Open FILE using the apndvfs VFS\0" as *const u8
        as *const libc::c_char,
    b"     -C DIR, --directory DIR    Read/extract files from directory DIR\0"
        as *const u8 as *const libc::c_char,
    b"     -g, --glob                 Use glob matching for names in archive\0"
        as *const u8 as *const libc::c_char,
    b"     -n, --dryrun               Show the SQL that would have occurred\0"
        as *const u8 as *const libc::c_char,
    b"   Examples:\0" as *const u8 as *const libc::c_char,
    b"     .ar -cf ARCHIVE foo bar  # Create ARCHIVE from files foo and bar\0"
        as *const u8 as *const libc::c_char,
    b"     .ar -tf ARCHIVE          # List members of ARCHIVE\0" as *const u8
        as *const libc::c_char,
    b"     .ar -xvf ARCHIVE         # Verbosely extract files from ARCHIVE\0"
        as *const u8 as *const libc::c_char,
    b"   See also:\0" as *const u8 as *const libc::c_char,
    b"      http://sqlite.org/cli.html#sqlite_archive_support\0" as *const u8
        as *const libc::c_char,
    b".auth ON|OFF             Show authorizer callbacks\0" as *const u8
        as *const libc::c_char,
    b".backup ?DB? FILE        Backup DB (default \"main\") to FILE\0" as *const u8
        as *const libc::c_char,
    b"   Options:\0" as *const u8 as *const libc::c_char,
    b"       --append            Use the appendvfs\0" as *const u8
        as *const libc::c_char,
    b"       --async             Write to FILE without journal and fsync()\0"
        as *const u8 as *const libc::c_char,
    b".bail on|off             Stop after hitting an error.  Default OFF\0" as *const u8
        as *const libc::c_char,
    b".binary on|off           Turn binary output on or off.  Default OFF\0" as *const u8
        as *const libc::c_char,
    b".cd DIRECTORY            Change the working directory to DIRECTORY\0" as *const u8
        as *const libc::c_char,
    b".changes on|off          Show number of rows changed by SQL\0" as *const u8
        as *const libc::c_char,
    b".check GLOB              Fail if output since .testcase does not match\0"
        as *const u8 as *const libc::c_char,
    b".clone NEWDB             Clone data into NEWDB from the existing database\0"
        as *const u8 as *const libc::c_char,
    b".connection [close] [#]  Open or close an auxiliary database connection\0"
        as *const u8 as *const libc::c_char,
    b".databases               List names and files of attached databases\0" as *const u8
        as *const libc::c_char,
    b".dbconfig ?op? ?val?     List or change sqlite3_db_config() options\0" as *const u8
        as *const libc::c_char,
    b".dbinfo ?DB?             Show status information about the database\0" as *const u8
        as *const libc::c_char,
    b".dump ?OBJECTS?          Render database content as SQL\0" as *const u8
        as *const libc::c_char,
    b"   Options:\0" as *const u8 as *const libc::c_char,
    b"     --data-only            Output only INSERT statements\0" as *const u8
        as *const libc::c_char,
    b"     --newlines             Allow unescaped newline characters in output\0"
        as *const u8 as *const libc::c_char,
    b"     --nosys                Omit system tables (ex: \"sqlite_stat1\")\0"
        as *const u8 as *const libc::c_char,
    b"     --preserve-rowids      Include ROWID values in the output\0" as *const u8
        as *const libc::c_char,
    b"   OBJECTS is a LIKE pattern for tables, indexes, triggers or views to dump\0"
        as *const u8 as *const libc::c_char,
    b"   Additional LIKE patterns can be given in subsequent arguments\0" as *const u8
        as *const libc::c_char,
    b".echo on|off             Turn command echo on or off\0" as *const u8
        as *const libc::c_char,
    b".eqp on|off|full|...     Enable or disable automatic EXPLAIN QUERY PLAN\0"
        as *const u8 as *const libc::c_char,
    b"   Other Modes:\0" as *const u8 as *const libc::c_char,
    b"      trigger               Like \"full\" but also show trigger bytecode\0"
        as *const u8 as *const libc::c_char,
    b".excel                   Display the output of next command in spreadsheet\0"
        as *const u8 as *const libc::c_char,
    b"   --bom                   Put a UTF8 byte-order mark on intermediate file\0"
        as *const u8 as *const libc::c_char,
    b".exit ?CODE?             Exit this program with return-code CODE\0" as *const u8
        as *const libc::c_char,
    b".expert                  EXPERIMENTAL. Suggest indexes for queries\0" as *const u8
        as *const libc::c_char,
    b".explain ?on|off|auto?   Change the EXPLAIN formatting mode.  Default: auto\0"
        as *const u8 as *const libc::c_char,
    b".filectrl CMD ...        Run various sqlite3_file_control() operations\0"
        as *const u8 as *const libc::c_char,
    b"   --schema SCHEMA         Use SCHEMA instead of \"main\"\0" as *const u8
        as *const libc::c_char,
    b"   --help                  Show CMD details\0" as *const u8 as *const libc::c_char,
    b".fullschema ?--indent?   Show schema and the content of sqlite_stat tables\0"
        as *const u8 as *const libc::c_char,
    b".headers on|off          Turn display of headers on or off\0" as *const u8
        as *const libc::c_char,
    b".help ?-all? ?PATTERN?   Show help text for PATTERN\0" as *const u8
        as *const libc::c_char,
    b".import FILE TABLE       Import data from FILE into TABLE\0" as *const u8
        as *const libc::c_char,
    b"   Options:\0" as *const u8 as *const libc::c_char,
    b"     --ascii               Use \\037 and \\036 as column and row separators\0"
        as *const u8 as *const libc::c_char,
    b"     --csv                 Use , and \\n as column and row separators\0"
        as *const u8 as *const libc::c_char,
    b"     --skip N              Skip the first N rows of input\0" as *const u8
        as *const libc::c_char,
    b"     --schema S            Target table to be S.TABLE\0" as *const u8
        as *const libc::c_char,
    b"     -v                    \"Verbose\" - increase auxiliary output\0" as *const u8
        as *const libc::c_char,
    b"   Notes:\0" as *const u8 as *const libc::c_char,
    b"     *  If TABLE does not exist, it is created.  The first row of input\0"
        as *const u8 as *const libc::c_char,
    b"        determines the column names.\0" as *const u8 as *const libc::c_char,
    b"     *  If neither --csv or --ascii are used, the input mode is derived\0"
        as *const u8 as *const libc::c_char,
    b"        from the \".mode\" output mode\0" as *const u8 as *const libc::c_char,
    b"     *  If FILE begins with \"|\" then it is a command that generates the\0"
        as *const u8 as *const libc::c_char,
    b"        input text.\0" as *const u8 as *const libc::c_char,
    b".imposter INDEX TABLE    Create imposter table TABLE on index INDEX\0" as *const u8
        as *const libc::c_char,
    b".indexes ?TABLE?         Show names of indexes\0" as *const u8
        as *const libc::c_char,
    b"                           If TABLE is specified, only show indexes for\0"
        as *const u8 as *const libc::c_char,
    b"                           tables matching TABLE using the LIKE operator.\0"
        as *const u8 as *const libc::c_char,
    b".limit ?LIMIT? ?VAL?     Display or change the value of an SQLITE_LIMIT\0"
        as *const u8 as *const libc::c_char,
    b".lint OPTIONS            Report potential schema issues.\0" as *const u8
        as *const libc::c_char,
    b"     Options:\0" as *const u8 as *const libc::c_char,
    b"        fkey-indexes     Find missing foreign key indexes\0" as *const u8
        as *const libc::c_char,
    b".load FILE ?ENTRY?       Load an extension library\0" as *const u8
        as *const libc::c_char,
    b".log FILE|off            Turn logging on or off.  FILE can be stderr/stdout\0"
        as *const u8 as *const libc::c_char,
    b".mode MODE ?OPTIONS?     Set output mode\0" as *const u8 as *const libc::c_char,
    b"   MODE is one of:\0" as *const u8 as *const libc::c_char,
    b"     ascii       Columns/rows delimited by 0x1F and 0x1E\0" as *const u8
        as *const libc::c_char,
    b"     box         Tables using unicode box-drawing characters\0" as *const u8
        as *const libc::c_char,
    b"     csv         Comma-separated values\0" as *const u8 as *const libc::c_char,
    b"     column      Output in columns.  (See .width)\0" as *const u8
        as *const libc::c_char,
    b"     html        HTML <table> code\0" as *const u8 as *const libc::c_char,
    b"     insert      SQL insert statements for TABLE\0" as *const u8
        as *const libc::c_char,
    b"     json        Results in a JSON array\0" as *const u8 as *const libc::c_char,
    b"     line        One value per line\0" as *const u8 as *const libc::c_char,
    b"     list        Values delimited by \"|\"\0" as *const u8 as *const libc::c_char,
    b"     markdown    Markdown table format\0" as *const u8 as *const libc::c_char,
    b"     qbox        Shorthand for \"box --wrap 60 --quote\"\0" as *const u8
        as *const libc::c_char,
    b"     quote       Escape answers as for SQL\0" as *const u8 as *const libc::c_char,
    b"     table       ASCII-art table\0" as *const u8 as *const libc::c_char,
    b"     tabs        Tab-separated values\0" as *const u8 as *const libc::c_char,
    b"     tcl         TCL list elements\0" as *const u8 as *const libc::c_char,
    b"   OPTIONS: (for columnar modes or insert mode):\0" as *const u8
        as *const libc::c_char,
    b"     --wrap N       Wrap output lines to no longer than N characters\0"
        as *const u8 as *const libc::c_char,
    b"     --wordwrap B   Wrap or not at word boundaries per B (on/off)\0" as *const u8
        as *const libc::c_char,
    b"     --ww           Shorthand for \"--wordwrap 1\"\0" as *const u8
        as *const libc::c_char,
    b"     --quote        Quote output text as SQL literals\0" as *const u8
        as *const libc::c_char,
    b"     --noquote      Do not quote output text\0" as *const u8
        as *const libc::c_char,
    b"     TABLE          The name of SQL table used for \"insert\" mode\0" as *const u8
        as *const libc::c_char,
    b".nonce STRING            Suspend safe mode for one command if nonce matches\0"
        as *const u8 as *const libc::c_char,
    b".nullvalue STRING        Use STRING in place of NULL values\0" as *const u8
        as *const libc::c_char,
    b".once ?OPTIONS? ?FILE?   Output for the next SQL command only to FILE\0"
        as *const u8 as *const libc::c_char,
    b"     If FILE begins with '|' then open as a pipe\0" as *const u8
        as *const libc::c_char,
    b"       --bom  Put a UTF8 byte-order mark at the beginning\0" as *const u8
        as *const libc::c_char,
    b"       -e     Send output to the system text editor\0" as *const u8
        as *const libc::c_char,
    b"       -x     Send output as CSV to a spreadsheet (same as \".excel\")\0"
        as *const u8 as *const libc::c_char,
    b".open ?OPTIONS? ?FILE?   Close existing database and reopen FILE\0" as *const u8
        as *const libc::c_char,
    b"     Options:\0" as *const u8 as *const libc::c_char,
    b"        --append        Use appendvfs to append database to the end of FILE\0"
        as *const u8 as *const libc::c_char,
    b"        --deserialize   Load into memory using sqlite3_deserialize()\0"
        as *const u8 as *const libc::c_char,
    b"        --hexdb         Load the output of \"dbtotxt\" as an in-memory db\0"
        as *const u8 as *const libc::c_char,
    b"        --maxsize N     Maximum size for --hexdb or --deserialized database\0"
        as *const u8 as *const libc::c_char,
    b"        --new           Initialize FILE to an empty database\0" as *const u8
        as *const libc::c_char,
    b"        --nofollow      Do not follow symbolic links\0" as *const u8
        as *const libc::c_char,
    b"        --readonly      Open FILE readonly\0" as *const u8 as *const libc::c_char,
    b"        --zip           FILE is a ZIP archive\0" as *const u8
        as *const libc::c_char,
    b".output ?FILE?           Send output to FILE or stdout if FILE is omitted\0"
        as *const u8 as *const libc::c_char,
    b"   If FILE begins with '|' then open it as a pipe.\0" as *const u8
        as *const libc::c_char,
    b"   Options:\0" as *const u8 as *const libc::c_char,
    b"     --bom                 Prefix output with a UTF8 byte-order mark\0"
        as *const u8 as *const libc::c_char,
    b"     -e                    Send output to the system text editor\0" as *const u8
        as *const libc::c_char,
    b"     -x                    Send output as CSV to a spreadsheet\0" as *const u8
        as *const libc::c_char,
    b".parameter CMD ...       Manage SQL parameter bindings\0" as *const u8
        as *const libc::c_char,
    b"   clear                   Erase all bindings\0" as *const u8
        as *const libc::c_char,
    b"   init                    Initialize the TEMP table that holds bindings\0"
        as *const u8 as *const libc::c_char,
    b"   list                    List the current parameter bindings\0" as *const u8
        as *const libc::c_char,
    b"   set PARAMETER VALUE     Given SQL parameter PARAMETER a value of VALUE\0"
        as *const u8 as *const libc::c_char,
    b"                           PARAMETER should start with one of: $ : @ ?\0"
        as *const u8 as *const libc::c_char,
    b"   unset PARAMETER         Remove PARAMETER from the binding table\0" as *const u8
        as *const libc::c_char,
    b".print STRING...         Print literal STRING\0" as *const u8
        as *const libc::c_char,
    b".progress N              Invoke progress handler after every N opcodes\0"
        as *const u8 as *const libc::c_char,
    b"   --limit N                 Interrupt after N progress callbacks\0" as *const u8
        as *const libc::c_char,
    b"   --once                    Do no more than one progress interrupt\0" as *const u8
        as *const libc::c_char,
    b"   --quiet|-q                No output except at interrupts\0" as *const u8
        as *const libc::c_char,
    b"   --reset                   Reset the count for each input and interrupt\0"
        as *const u8 as *const libc::c_char,
    b".prompt MAIN CONTINUE    Replace the standard prompts\0" as *const u8
        as *const libc::c_char,
    b".quit                    Exit this program\0" as *const u8 as *const libc::c_char,
    b".read FILE               Read input from FILE or command output\0" as *const u8
        as *const libc::c_char,
    b"    If FILE begins with \"|\", it is a command that generates the input.\0"
        as *const u8 as *const libc::c_char,
    b".recover                 Recover as much data as possible from corrupt db.\0"
        as *const u8 as *const libc::c_char,
    b"   --ignore-freelist        Ignore pages that appear to be on db freelist\0"
        as *const u8 as *const libc::c_char,
    b"   --lost-and-found TABLE   Alternative name for the lost-and-found table\0"
        as *const u8 as *const libc::c_char,
    b"   --no-rowids              Do not attempt to recover rowid values\0" as *const u8
        as *const libc::c_char,
    b"                            that are not also INTEGER PRIMARY KEYs\0" as *const u8
        as *const libc::c_char,
    b".restore ?DB? FILE       Restore content of DB (default \"main\") from FILE\0"
        as *const u8 as *const libc::c_char,
    b".save ?OPTIONS? FILE     Write database to FILE (an alias for .backup ...)\0"
        as *const u8 as *const libc::c_char,
    b".scanstats on|off        Turn sqlite3_stmt_scanstatus() metrics on or off\0"
        as *const u8 as *const libc::c_char,
    b".schema ?PATTERN?        Show the CREATE statements matching PATTERN\0"
        as *const u8 as *const libc::c_char,
    b"   Options:\0" as *const u8 as *const libc::c_char,
    b"      --indent             Try to pretty-print the schema\0" as *const u8
        as *const libc::c_char,
    b"      --nosys              Omit objects whose names start with \"sqlite_\"\0"
        as *const u8 as *const libc::c_char,
    b".selftest ?OPTIONS?      Run tests defined in the SELFTEST table\0" as *const u8
        as *const libc::c_char,
    b"    Options:\0" as *const u8 as *const libc::c_char,
    b"       --init               Create a new SELFTEST table\0" as *const u8
        as *const libc::c_char,
    b"       -v                   Verbose output\0" as *const u8 as *const libc::c_char,
    b".separator COL ?ROW?     Change the column and row separators\0" as *const u8
        as *const libc::c_char,
    b".sha3sum ...             Compute a SHA3 hash of database content\0" as *const u8
        as *const libc::c_char,
    b"    Options:\0" as *const u8 as *const libc::c_char,
    b"      --schema              Also hash the sqlite_schema table\0" as *const u8
        as *const libc::c_char,
    b"      --sha3-224            Use the sha3-224 algorithm\0" as *const u8
        as *const libc::c_char,
    b"      --sha3-256            Use the sha3-256 algorithm (default)\0" as *const u8
        as *const libc::c_char,
    b"      --sha3-384            Use the sha3-384 algorithm\0" as *const u8
        as *const libc::c_char,
    b"      --sha3-512            Use the sha3-512 algorithm\0" as *const u8
        as *const libc::c_char,
    b"    Any other argument is a LIKE pattern for tables to hash\0" as *const u8
        as *const libc::c_char,
    b".shell CMD ARGS...       Run CMD ARGS... in a system shell\0" as *const u8
        as *const libc::c_char,
    b".show                    Show the current values for various settings\0"
        as *const u8 as *const libc::c_char,
    b".stats ?ARG?             Show stats or turn stats on or off\0" as *const u8
        as *const libc::c_char,
    b"   off                      Turn off automatic stat display\0" as *const u8
        as *const libc::c_char,
    b"   on                       Turn on automatic stat display\0" as *const u8
        as *const libc::c_char,
    b"   stmt                     Show statement stats\0" as *const u8
        as *const libc::c_char,
    b"   vmstep                   Show the virtual machine step count only\0"
        as *const u8 as *const libc::c_char,
    b".system CMD ARGS...      Run CMD ARGS... in a system shell\0" as *const u8
        as *const libc::c_char,
    b".tables ?TABLE?          List names of tables matching LIKE pattern TABLE\0"
        as *const u8 as *const libc::c_char,
    b".testcase NAME           Begin redirecting output to 'testcase-out.txt'\0"
        as *const u8 as *const libc::c_char,
    b".testctrl CMD ...        Run various sqlite3_test_control() operations\0"
        as *const u8 as *const libc::c_char,
    b"                           Run \".testctrl\" with no arguments for details\0"
        as *const u8 as *const libc::c_char,
    b".timeout MS              Try opening locked tables for MS milliseconds\0"
        as *const u8 as *const libc::c_char,
    b".timer on|off            Turn SQL timer on or off\0" as *const u8
        as *const libc::c_char,
    b".trace ?OPTIONS?         Output each SQL statement as it is run\0" as *const u8
        as *const libc::c_char,
    b"    FILE                    Send output to FILE\0" as *const u8
        as *const libc::c_char,
    b"    stdout                  Send output to stdout\0" as *const u8
        as *const libc::c_char,
    b"    stderr                  Send output to stderr\0" as *const u8
        as *const libc::c_char,
    b"    off                     Disable tracing\0" as *const u8 as *const libc::c_char,
    b"    --expanded              Expand query parameters\0" as *const u8
        as *const libc::c_char,
    b"    --plain                 Show SQL as it is input\0" as *const u8
        as *const libc::c_char,
    b"    --stmt                  Trace statement execution (SQLITE_TRACE_STMT)\0"
        as *const u8 as *const libc::c_char,
    b"    --profile               Profile statements (SQLITE_TRACE_PROFILE)\0"
        as *const u8 as *const libc::c_char,
    b"    --row                   Trace each row (SQLITE_TRACE_ROW)\0" as *const u8
        as *const libc::c_char,
    b"    --close                 Trace connection close (SQLITE_TRACE_CLOSE)\0"
        as *const u8 as *const libc::c_char,
    b".vfsinfo ?AUX?           Information about the top-level VFS\0" as *const u8
        as *const libc::c_char,
    b".vfslist                 List all available VFSes\0" as *const u8
        as *const libc::c_char,
    b".vfsname ?AUX?           Print the name of the VFS stack\0" as *const u8
        as *const libc::c_char,
    b".width NUM1 NUM2 ...     Set minimum column widths for columnar output\0"
        as *const u8 as *const libc::c_char,
    b"     Negative values right-justify\0" as *const u8 as *const libc::c_char,
];
unsafe extern "C" fn showHelp(
    mut out: *mut FILE,
    mut zPattern: *const libc::c_char,
) -> libc::c_int {
    let mut i: libc::c_int = 0 as libc::c_int;
    let mut j: libc::c_int = 0 as libc::c_int;
    let mut n: libc::c_int = 0 as libc::c_int;
    let mut zPat: *mut libc::c_char = 0 as *mut libc::c_char;
    if zPattern.is_null()
        || *zPattern.offset(0 as libc::c_int as isize) as libc::c_int == '0' as i32
        || cli_strcmp(zPattern, b"-a\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        || cli_strcmp(zPattern, b"-all\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        || cli_strcmp(zPattern, b"--all\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
    {
        if zPattern.is_null() {
            zPattern = b"\0" as *const u8 as *const libc::c_char;
        }
        i = 0 as libc::c_int;
        while i
            < (::std::mem::size_of::<[*const libc::c_char; 202]>() as libc::c_ulong)
                .wrapping_div(
                    ::std::mem::size_of::<*const libc::c_char>() as libc::c_ulong,
                ) as libc::c_int
        {
            if *(azHelp[i as usize]).offset(0 as libc::c_int as isize) as libc::c_int
                == '.' as i32
                || *zPattern.offset(0 as libc::c_int as isize) as libc::c_int != 0
            {
                fprintf(
                    out,
                    b"%s\n\0" as *const u8 as *const libc::c_char,
                    azHelp[i as usize],
                );
                n += 1;
            }
            i += 1;
        }
    } else {
        zPat = sqlite3_mprintf(b".%s*\0" as *const u8 as *const libc::c_char, zPattern);
        shell_check_oom(zPat as *mut libc::c_void);
        i = 0 as libc::c_int;
        while i
            < (::std::mem::size_of::<[*const libc::c_char; 202]>() as libc::c_ulong)
                .wrapping_div(
                    ::std::mem::size_of::<*const libc::c_char>() as libc::c_ulong,
                ) as libc::c_int
        {
            if sqlite3_strglob(zPat, azHelp[i as usize]) == 0 as libc::c_int {
                fprintf(
                    out,
                    b"%s\n\0" as *const u8 as *const libc::c_char,
                    azHelp[i as usize],
                );
                j = i + 1 as libc::c_int;
                n += 1;
            }
            i += 1;
        }
        sqlite3_free(zPat as *mut libc::c_void);
        if n != 0 {
            if n == 1 as libc::c_int {
                while j
                    < (::std::mem::size_of::<[*const libc::c_char; 202]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::std::mem::size_of::<*const libc::c_char>() as libc::c_ulong,
                        ) as libc::c_int - 1 as libc::c_int
                    && *(azHelp[j as usize]).offset(0 as libc::c_int as isize)
                        as libc::c_int != '.' as i32
                {
                    fprintf(
                        out,
                        b"%s\n\0" as *const u8 as *const libc::c_char,
                        azHelp[j as usize],
                    );
                    j += 1;
                }
            }
            return n;
        }
        zPat = sqlite3_mprintf(
            b"%%%s%%\0" as *const u8 as *const libc::c_char,
            zPattern,
        );
        shell_check_oom(zPat as *mut libc::c_void);
        i = 0 as libc::c_int;
        while i
            < (::std::mem::size_of::<[*const libc::c_char; 202]>() as libc::c_ulong)
                .wrapping_div(
                    ::std::mem::size_of::<*const libc::c_char>() as libc::c_ulong,
                ) as libc::c_int
        {
            if *(azHelp[i as usize]).offset(0 as libc::c_int as isize) as libc::c_int
                == '.' as i32
            {
                j = i;
            }
            if sqlite3_strlike(
                zPat,
                azHelp[i as usize],
                0 as libc::c_int as libc::c_uint,
            ) == 0 as libc::c_int
            {
                fprintf(
                    out,
                    b"%s\n\0" as *const u8 as *const libc::c_char,
                    azHelp[j as usize],
                );
                while j
                    < (::std::mem::size_of::<[*const libc::c_char; 202]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::std::mem::size_of::<*const libc::c_char>() as libc::c_ulong,
                        ) as libc::c_int - 1 as libc::c_int
                    && *(azHelp[(j + 1 as libc::c_int) as usize])
                        .offset(0 as libc::c_int as isize) as libc::c_int != '.' as i32
                {
                    j += 1;
                    fprintf(
                        out,
                        b"%s\n\0" as *const u8 as *const libc::c_char,
                        azHelp[j as usize],
                    );
                }
                i = j;
                n += 1;
            }
            i += 1;
        }
        sqlite3_free(zPat as *mut libc::c_void);
    }
    return n;
}
unsafe extern "C" fn readFile(
    mut zName: *const libc::c_char,
    mut pnByte: *mut libc::c_int,
) -> *mut libc::c_char {
    let mut in_0: *mut FILE = fopen(zName, b"rb\0" as *const u8 as *const libc::c_char);
    let mut nIn: libc::c_long = 0;
    let mut nRead: size_t = 0;
    let mut pBuf: *mut libc::c_char = 0 as *mut libc::c_char;
    if in_0.is_null() {
        return 0 as *mut libc::c_char;
    }
    fseek(in_0, 0 as libc::c_int as libc::c_long, 2 as libc::c_int);
    nIn = ftell(in_0);
    rewind(in_0);
    pBuf = sqlite3_malloc64((nIn + 1 as libc::c_int as libc::c_long) as sqlite3_uint64)
        as *mut libc::c_char;
    if pBuf.is_null() {
        fclose(in_0);
        return 0 as *mut libc::c_char;
    }
    nRead = fread(
        pBuf as *mut libc::c_void,
        nIn as libc::c_ulong,
        1 as libc::c_int as libc::c_ulong,
        in_0,
    );
    fclose(in_0);
    if nRead != 1 as libc::c_int as libc::c_ulong {
        sqlite3_free(pBuf as *mut libc::c_void);
        return 0 as *mut libc::c_char;
    }
    *pBuf.offset(nIn as isize) = 0 as libc::c_int as libc::c_char;
    if !pnByte.is_null() {
        *pnByte = nIn as libc::c_int;
    }
    return pBuf;
}
#[no_mangle]
pub unsafe extern "C" fn deduceDatabaseType(
    mut zName: *const libc::c_char,
    mut dfltZip: libc::c_int,
) -> libc::c_int {
    let mut f: *mut FILE = fopen(zName, b"rb\0" as *const u8 as *const libc::c_char);
    let mut n: size_t = 0;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut zBuf: [libc::c_char; 100] = [0; 100];
    if f.is_null() {
        if dfltZip != 0
            && sqlite3_strlike(
                b"%.zip\0" as *const u8 as *const libc::c_char,
                zName,
                0 as libc::c_int as libc::c_uint,
            ) == 0 as libc::c_int
        {
            return 3 as libc::c_int
        } else {
            return 1 as libc::c_int
        }
    }
    n = fread(
        zBuf.as_mut_ptr() as *mut libc::c_void,
        16 as libc::c_int as libc::c_ulong,
        1 as libc::c_int as libc::c_ulong,
        f,
    );
    if n == 1 as libc::c_int as libc::c_ulong
        && memcmp(
            zBuf.as_mut_ptr() as *const libc::c_void,
            b"SQLite format 3\0" as *const u8 as *const libc::c_char
                as *const libc::c_void,
            16 as libc::c_int as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        fclose(f);
        return 1 as libc::c_int;
    }
    fseek(f, -(25 as libc::c_int) as libc::c_long, 2 as libc::c_int);
    n = fread(
        zBuf.as_mut_ptr() as *mut libc::c_void,
        25 as libc::c_int as libc::c_ulong,
        1 as libc::c_int as libc::c_ulong,
        f,
    );
    if n == 1 as libc::c_int as libc::c_ulong
        && memcmp(
            zBuf.as_mut_ptr() as *const libc::c_void,
            b"Start-Of-SQLite3-\0" as *const u8 as *const libc::c_char
                as *const libc::c_void,
            17 as libc::c_int as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        rc = 2 as libc::c_int;
    } else {
        fseek(f, -(22 as libc::c_int) as libc::c_long, 2 as libc::c_int);
        n = fread(
            zBuf.as_mut_ptr() as *mut libc::c_void,
            22 as libc::c_int as libc::c_ulong,
            1 as libc::c_int as libc::c_ulong,
            f,
        );
        if n == 1 as libc::c_int as libc::c_ulong
            && zBuf[0 as libc::c_int as usize] as libc::c_int == 0x50 as libc::c_int
            && zBuf[1 as libc::c_int as usize] as libc::c_int == 0x4b as libc::c_int
            && zBuf[2 as libc::c_int as usize] as libc::c_int == 0x5 as libc::c_int
            && zBuf[3 as libc::c_int as usize] as libc::c_int == 0x6 as libc::c_int
        {
            rc = 3 as libc::c_int;
        } else if n == 0 as libc::c_int as libc::c_ulong && dfltZip != 0
            && sqlite3_strlike(
                b"%.zip\0" as *const u8 as *const libc::c_char,
                zName,
                0 as libc::c_int as libc::c_uint,
            ) == 0 as libc::c_int
        {
            rc = 3 as libc::c_int;
        }
    }
    fclose(f);
    return rc;
}
unsafe extern "C" fn readHexDb(
    mut p: *mut ShellState,
    mut pnData: *mut libc::c_int,
) -> *mut libc::c_uchar {
    let mut a: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut nLine: libc::c_int = 0;
    let mut n: libc::c_int = 0 as libc::c_int;
    let mut pgsz: libc::c_int = 0 as libc::c_int;
    let mut iOffset: libc::c_int = 0 as libc::c_int;
    let mut j: libc::c_int = 0;
    let mut k: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    let mut in_0: *mut FILE = 0 as *mut FILE;
    let mut zDbFilename: *const libc::c_char = (*(*p).pAuxDb).zDbFilename;
    let mut x: [libc::c_uint; 16] = [0; 16];
    let mut zLine: [libc::c_char; 1000] = [0; 1000];
    if !zDbFilename.is_null() {
        in_0 = fopen(zDbFilename, b"r\0" as *const u8 as *const libc::c_char);
        if in_0.is_null() {
            fprintf(
                stderr,
                b"cannot open \"%s\" for reading\n\0" as *const u8
                    as *const libc::c_char,
                zDbFilename,
            );
            return 0 as *mut libc::c_uchar;
        }
        nLine = 0 as libc::c_int;
    } else {
        in_0 = (*p).in_0;
        nLine = (*p).lineno;
        if in_0.is_null() {
            in_0 = stdin;
        }
    }
    *pnData = 0 as libc::c_int;
    nLine += 1;
    if !(fgets(
        zLine.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 1000]>() as libc::c_ulong as libc::c_int,
        in_0,
    ))
        .is_null()
    {
        rc = sscanf(
            zLine.as_mut_ptr(),
            b"| size %d pagesize %d\0" as *const u8 as *const libc::c_char,
            &mut n as *mut libc::c_int,
            &mut pgsz as *mut libc::c_int,
        );
        if !(rc != 2 as libc::c_int) {
            if !(n < 0 as libc::c_int) {
                if !(pgsz < 512 as libc::c_int || pgsz > 65536 as libc::c_int
                    || pgsz & pgsz - 1 as libc::c_int != 0 as libc::c_int)
                {
                    n = n + pgsz - 1 as libc::c_int & !(pgsz - 1 as libc::c_int);
                    a = sqlite3_malloc(if n != 0 { n } else { 1 as libc::c_int })
                        as *mut libc::c_uchar;
                    shell_check_oom(a as *mut libc::c_void);
                    memset(a as *mut libc::c_void, 0 as libc::c_int, n as libc::c_ulong);
                    if pgsz < 512 as libc::c_int || pgsz > 65536 as libc::c_int
                        || pgsz & pgsz - 1 as libc::c_int != 0 as libc::c_int
                    {
                        fprintf(
                            stderr,
                            b"invalid pagesize\n\0" as *const u8 as *const libc::c_char,
                        );
                    } else {
                        nLine += 1;
                        while !(fgets(
                            zLine.as_mut_ptr(),
                            ::std::mem::size_of::<[libc::c_char; 1000]>()
                                as libc::c_ulong as libc::c_int,
                            in_0,
                        ))
                            .is_null()
                        {
                            rc = sscanf(
                                zLine.as_mut_ptr(),
                                b"| page %d offset %d\0" as *const u8
                                    as *const libc::c_char,
                                &mut j as *mut libc::c_int,
                                &mut k as *mut libc::c_int,
                            );
                            if rc == 2 as libc::c_int {
                                iOffset = k;
                            } else {
                                if cli_strncmp(
                                    zLine.as_mut_ptr(),
                                    b"| end \0" as *const u8 as *const libc::c_char,
                                    6 as libc::c_int as size_t,
                                ) == 0 as libc::c_int
                                {
                                    break;
                                }
                                rc = sscanf(
                                    zLine.as_mut_ptr(),
                                    b"| %d: %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x\0"
                                        as *const u8 as *const libc::c_char,
                                    &mut j as *mut libc::c_int,
                                    &mut *x.as_mut_ptr().offset(0 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(1 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(2 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(3 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(4 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(5 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(6 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(7 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(8 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(9 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(10 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(11 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(12 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(13 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(14 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(15 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                );
                                if rc == 17 as libc::c_int {
                                    k = iOffset + j;
                                    if k + 16 as libc::c_int <= n && k >= 0 as libc::c_int {
                                        let mut ii: libc::c_int = 0;
                                        ii = 0 as libc::c_int;
                                        while ii < 16 as libc::c_int {
                                            *a
                                                .offset(
                                                    (k + ii) as isize,
                                                ) = (x[ii as usize] & 0xff as libc::c_int as libc::c_uint)
                                                as libc::c_uchar;
                                            ii += 1;
                                        }
                                    }
                                }
                            }
                            nLine += 1;
                        }
                        *pnData = n;
                        if in_0 != (*p).in_0 {
                            fclose(in_0);
                        } else {
                            (*p).lineno = nLine;
                        }
                        return a;
                    }
                }
            }
        }
    }
    if in_0 != (*p).in_0 {
        fclose(in_0);
    } else {
        while !(fgets(
            zLine.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 1000]>() as libc::c_ulong
                as libc::c_int,
            (*p).in_0,
        ))
            .is_null()
        {
            nLine += 1;
            if cli_strncmp(
                zLine.as_mut_ptr(),
                b"| end \0" as *const u8 as *const libc::c_char,
                6 as libc::c_int as size_t,
            ) == 0 as libc::c_int
            {
                break;
            }
        }
        (*p).lineno = nLine;
    }
    sqlite3_free(a as *mut libc::c_void);
    fprintf(
        stderr,
        b"Error on line %d of --hexdb input\n\0" as *const u8 as *const libc::c_char,
        nLine,
    );
    return 0 as *mut libc::c_uchar;
}
unsafe extern "C" fn shellInt32(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut pBlob: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut nBlob: libc::c_int = 0;
    let mut iInt: libc::c_int = 0;
    nBlob = sqlite3_value_bytes(*argv.offset(0 as libc::c_int as isize));
    pBlob = sqlite3_value_blob(*argv.offset(0 as libc::c_int as isize))
        as *const libc::c_uchar;
    iInt = sqlite3_value_int(*argv.offset(1 as libc::c_int as isize));
    if iInt >= 0 as libc::c_int && (iInt + 1 as libc::c_int) * 4 as libc::c_int <= nBlob
    {
        let mut a: *const libc::c_uchar = &*pBlob
            .offset((iInt * 4 as libc::c_int) as isize) as *const libc::c_uchar;
        let mut iVal: sqlite3_int64 = ((*a.offset(0 as libc::c_int as isize)
            as sqlite3_int64) << 24 as libc::c_int)
            + ((*a.offset(1 as libc::c_int as isize) as sqlite3_int64)
                << 16 as libc::c_int)
            + ((*a.offset(2 as libc::c_int as isize) as sqlite3_int64)
                << 8 as libc::c_int)
            + ((*a.offset(3 as libc::c_int as isize) as sqlite3_int64)
                << 0 as libc::c_int);
        sqlite3_result_int64(context, iVal);
    }
}
unsafe extern "C" fn shellIdQuote(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut zName: *const libc::c_char = sqlite3_value_text(
        *argv.offset(0 as libc::c_int as isize),
    ) as *const libc::c_char;
    if !zName.is_null() {
        let mut z: *mut libc::c_char = sqlite3_mprintf(
            b"\"%w\"\0" as *const u8 as *const libc::c_char,
            zName,
        );
        sqlite3_result_text(
            context,
            z,
            -(1 as libc::c_int),
            Some(sqlite3_free as unsafe extern "C" fn(*mut libc::c_void) -> ()),
        );
    }
}
unsafe extern "C" fn shellUSleepFunc(
    mut context: *mut sqlite3_context,
    mut argcUnused: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut sleep: libc::c_int = sqlite3_value_int(
        *argv.offset(0 as libc::c_int as isize),
    );
    sqlite3_sleep(sleep / 1000 as libc::c_int);
    sqlite3_result_int(context, sleep);
}
unsafe extern "C" fn shellEscapeCrnl(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut zText: *const libc::c_char = sqlite3_value_text(
        *argv.offset(0 as libc::c_int as isize),
    ) as *const libc::c_char;
    if !zText.is_null()
        && *zText.offset(0 as libc::c_int as isize) as libc::c_int == '\'' as i32
    {
        let mut nText: i64_0 = sqlite3_value_bytes(
            *argv.offset(0 as libc::c_int as isize),
        ) as i64_0;
        let mut i: i64_0 = 0;
        let mut zBuf1: [libc::c_char; 20] = [0; 20];
        let mut zBuf2: [libc::c_char; 20] = [0; 20];
        let mut zNL: *const libc::c_char = 0 as *const libc::c_char;
        let mut zCR: *const libc::c_char = 0 as *const libc::c_char;
        let mut nCR: i64_0 = 0 as libc::c_int as i64_0;
        let mut nNL: i64_0 = 0 as libc::c_int as i64_0;
        i = 0 as libc::c_int as i64_0;
        while *zText.offset(i as isize) != 0 {
            if zNL.is_null() && *zText.offset(i as isize) as libc::c_int == '\n' as i32 {
                zNL = unused_string(
                    zText,
                    b"\\n\0" as *const u8 as *const libc::c_char,
                    b"\\012\0" as *const u8 as *const libc::c_char,
                    zBuf1.as_mut_ptr(),
                );
                nNL = strlen(zNL) as i64_0;
            }
            if zCR.is_null() && *zText.offset(i as isize) as libc::c_int == '\r' as i32 {
                zCR = unused_string(
                    zText,
                    b"\\r\0" as *const u8 as *const libc::c_char,
                    b"\\015\0" as *const u8 as *const libc::c_char,
                    zBuf2.as_mut_ptr(),
                );
                nCR = strlen(zCR) as i64_0;
            }
            i += 1;
        }
        if !zNL.is_null() || !zCR.is_null() {
            let mut iOut: i64_0 = 0 as libc::c_int as i64_0;
            let mut nMax: i64_0 = if nNL > nCR { nNL } else { nCR };
            let mut nAlloc: i64_0 = nMax * nText
                + (nMax + 64 as libc::c_int as libc::c_longlong)
                    * 2 as libc::c_int as libc::c_longlong;
            let mut zOut: *mut libc::c_char = sqlite3_malloc64(nAlloc as sqlite3_uint64)
                as *mut libc::c_char;
            if zOut.is_null() {
                sqlite3_result_error_nomem(context);
                return;
            }
            if !zNL.is_null() && !zCR.is_null() {
                memcpy(
                    &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                        as *mut libc::c_void,
                    b"replace(replace(\0" as *const u8 as *const libc::c_char
                        as *const libc::c_void,
                    16 as libc::c_int as libc::c_ulong,
                );
                iOut += 16 as libc::c_int as libc::c_longlong;
            } else {
                memcpy(
                    &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                        as *mut libc::c_void,
                    b"replace(\0" as *const u8 as *const libc::c_char
                        as *const libc::c_void,
                    8 as libc::c_int as libc::c_ulong,
                );
                iOut += 8 as libc::c_int as libc::c_longlong;
            }
            i = 0 as libc::c_int as i64_0;
            while *zText.offset(i as isize) != 0 {
                if *zText.offset(i as isize) as libc::c_int == '\n' as i32 {
                    memcpy(
                        &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                            as *mut libc::c_void,
                        zNL as *const libc::c_void,
                        nNL as libc::c_ulong,
                    );
                    iOut += nNL;
                } else if *zText.offset(i as isize) as libc::c_int == '\r' as i32 {
                    memcpy(
                        &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                            as *mut libc::c_void,
                        zCR as *const libc::c_void,
                        nCR as libc::c_ulong,
                    );
                    iOut += nCR;
                } else {
                    *zOut.offset(iOut as isize) = *zText.offset(i as isize);
                    iOut += 1;
                }
                i += 1;
            }
            if !zNL.is_null() {
                memcpy(
                    &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                        as *mut libc::c_void,
                    b",'\0" as *const u8 as *const libc::c_char as *const libc::c_void,
                    2 as libc::c_int as libc::c_ulong,
                );
                iOut += 2 as libc::c_int as libc::c_longlong;
                memcpy(
                    &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                        as *mut libc::c_void,
                    zNL as *const libc::c_void,
                    nNL as libc::c_ulong,
                );
                iOut += nNL;
                memcpy(
                    &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                        as *mut libc::c_void,
                    b"', char(10))\0" as *const u8 as *const libc::c_char
                        as *const libc::c_void,
                    12 as libc::c_int as libc::c_ulong,
                );
                iOut += 12 as libc::c_int as libc::c_longlong;
            }
            if !zCR.is_null() {
                memcpy(
                    &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                        as *mut libc::c_void,
                    b",'\0" as *const u8 as *const libc::c_char as *const libc::c_void,
                    2 as libc::c_int as libc::c_ulong,
                );
                iOut += 2 as libc::c_int as libc::c_longlong;
                memcpy(
                    &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                        as *mut libc::c_void,
                    zCR as *const libc::c_void,
                    nCR as libc::c_ulong,
                );
                iOut += nCR;
                memcpy(
                    &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                        as *mut libc::c_void,
                    b"', char(13))\0" as *const u8 as *const libc::c_char
                        as *const libc::c_void,
                    12 as libc::c_int as libc::c_ulong,
                );
                iOut += 12 as libc::c_int as libc::c_longlong;
            }
            sqlite3_result_text(
                context,
                zOut,
                iOut as libc::c_int,
                ::std::mem::transmute::<
                    libc::intptr_t,
                    sqlite3_destructor_type,
                >(-(1 as libc::c_int) as libc::intptr_t),
            );
            sqlite3_free(zOut as *mut libc::c_void);
            return;
        }
    }
    sqlite3_result_value(context, *argv.offset(0 as libc::c_int as isize));
}
unsafe extern "C" fn open_db(mut p: *mut ShellState, mut openFlags: libc::c_int) {
    if ((*p).db).is_null() {
        let mut zDbFilename: *const libc::c_char = (*(*p).pAuxDb).zDbFilename;
        if (*p).openMode as libc::c_int == 0 as libc::c_int {
            if zDbFilename.is_null()
                || *zDbFilename.offset(0 as libc::c_int as isize) as libc::c_int
                    == 0 as libc::c_int
            {
                (*p).openMode = 1 as libc::c_int as u8_0;
            } else {
                (*p)
                    .openMode = deduceDatabaseType(
                    zDbFilename,
                    (openFlags & 0x2 as libc::c_int != 0 as libc::c_int) as libc::c_int,
                ) as u8_0;
            }
        }
        match (*p).openMode as libc::c_int {
            2 => {
                sqlite3_open_v2(
                    zDbFilename,
                    &mut (*p).db,
                    0x2 as libc::c_int | 0x4 as libc::c_int | (*p).openFlags,
                    b"apndvfs\0" as *const u8 as *const libc::c_char,
                );
            }
            6 | 5 => {
                sqlite3_open(0 as *const libc::c_char, &mut (*p).db);
            }
            3 => {
                sqlite3_open(
                    b":memory:\0" as *const u8 as *const libc::c_char,
                    &mut (*p).db,
                );
            }
            4 => {
                sqlite3_open_v2(
                    zDbFilename,
                    &mut (*p).db,
                    0x1 as libc::c_int | (*p).openFlags,
                    0 as *const libc::c_char,
                );
            }
            0 | 1 => {
                sqlite3_open_v2(
                    zDbFilename,
                    &mut (*p).db,
                    0x2 as libc::c_int | 0x4 as libc::c_int | (*p).openFlags,
                    0 as *const libc::c_char,
                );
            }
            _ => {}
        }
        globalDb = (*p).db;
        if ((*p).db).is_null() || 0 as libc::c_int != sqlite3_errcode((*p).db) {
            fprintf(
                stderr,
                b"Error: unable to open database \"%s\": %s\n\0" as *const u8
                    as *const libc::c_char,
                zDbFilename,
                sqlite3_errmsg((*p).db),
            );
            if openFlags & 0x1 as libc::c_int != 0 {
                sqlite3_open(
                    b":memory:\0" as *const u8 as *const libc::c_char,
                    &mut (*p).db,
                );
                return;
            }
            exit(1 as libc::c_int);
        }
        sqlite3_enable_load_extension((*p).db, 1 as libc::c_int);
        sqlite3_shathree_init(
            (*p).db,
            0 as *mut *mut libc::c_char,
            0 as *const sqlite3_api_routines,
        );
        sqlite3_uint_init(
            (*p).db,
            0 as *mut *mut libc::c_char,
            0 as *const sqlite3_api_routines,
        );
        sqlite3_decimal_init(
            (*p).db,
            0 as *mut *mut libc::c_char,
            0 as *const sqlite3_api_routines,
        );
        sqlite3_regexp_init(
            (*p).db,
            0 as *mut *mut libc::c_char,
            0 as *const sqlite3_api_routines,
        );
        sqlite3_ieee_init(
            (*p).db,
            0 as *mut *mut libc::c_char,
            0 as *const sqlite3_api_routines,
        );
        sqlite3_series_init(
            (*p).db,
            0 as *mut *mut libc::c_char,
            0 as *const sqlite3_api_routines,
        );
        sqlite3_fileio_init(
            (*p).db,
            0 as *mut *mut libc::c_char,
            0 as *const sqlite3_api_routines,
        );
        sqlite3_completion_init(
            (*p).db,
            0 as *mut *mut libc::c_char,
            0 as *const sqlite3_api_routines,
        );
        sqlite3_dbdata_init(
            (*p).db,
            0 as *mut *mut libc::c_char,
            0 as *const sqlite3_api_routines,
        );
        if (*p).bSafeModePersist == 0 {
            sqlite3_zipfile_init(
                (*p).db,
                0 as *mut *mut libc::c_char,
                0 as *const sqlite3_api_routines,
            );
            sqlite3_sqlar_init(
                (*p).db,
                0 as *mut *mut libc::c_char,
                0 as *const sqlite3_api_routines,
            );
        }
        sqlite3_create_function(
            (*p).db,
            b"shell_add_schema\0" as *const u8 as *const libc::c_char,
            3 as libc::c_int,
            1 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                shellAddSchemaName
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
        sqlite3_create_function(
            (*p).db,
            b"shell_module_schema\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            1 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                shellModuleSchema
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
        sqlite3_create_function(
            (*p).db,
            b"shell_putsnl\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            1 as libc::c_int,
            p as *mut libc::c_void,
            Some(
                shellPutsFunc
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
        sqlite3_create_function(
            (*p).db,
            b"shell_escape_crnl\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            1 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                shellEscapeCrnl
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
        sqlite3_create_function(
            (*p).db,
            b"shell_int32\0" as *const u8 as *const libc::c_char,
            2 as libc::c_int,
            1 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                shellInt32
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
        sqlite3_create_function(
            (*p).db,
            b"shell_idquote\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            1 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                shellIdQuote
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
        sqlite3_create_function(
            (*p).db,
            b"usleep\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            1 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                shellUSleepFunc
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
        sqlite3_create_function(
            (*p).db,
            b"edit\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            1 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                editFunc
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
        sqlite3_create_function(
            (*p).db,
            b"edit\0" as *const u8 as *const libc::c_char,
            2 as libc::c_int,
            1 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                editFunc
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
        if (*p).openMode as libc::c_int == 3 as libc::c_int {
            let mut zSql: *mut libc::c_char = sqlite3_mprintf(
                b"CREATE VIRTUAL TABLE zip USING zipfile(%Q);\0" as *const u8
                    as *const libc::c_char,
                zDbFilename,
            );
            shell_check_oom(zSql as *mut libc::c_void);
            sqlite3_exec(
                (*p).db,
                zSql,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
            sqlite3_free(zSql as *mut libc::c_void);
        } else if (*p).openMode as libc::c_int == 5 as libc::c_int
            || (*p).openMode as libc::c_int == 6 as libc::c_int
        {
            let mut rc: libc::c_int = 0;
            let mut nData: libc::c_int = 0 as libc::c_int;
            let mut aData: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
            if (*p).openMode as libc::c_int == 5 as libc::c_int {
                aData = readFile(zDbFilename, &mut nData) as *mut libc::c_uchar;
            } else {
                aData = readHexDb(p, &mut nData);
                if aData.is_null() {
                    return;
                }
            }
            rc = sqlite3_deserialize(
                (*p).db,
                b"main\0" as *const u8 as *const libc::c_char,
                aData,
                nData as sqlite3_int64,
                nData as sqlite3_int64,
                (2 as libc::c_int | 1 as libc::c_int) as libc::c_uint,
            );
            if rc != 0 {
                fprintf(
                    stderr,
                    b"Error: sqlite3_deserialize() returns %d\n\0" as *const u8
                        as *const libc::c_char,
                    rc,
                );
            }
            if (*p).szMax > 0 as libc::c_int as libc::c_longlong {
                sqlite3_file_control(
                    (*p).db,
                    b"main\0" as *const u8 as *const libc::c_char,
                    36 as libc::c_int,
                    &mut (*p).szMax as *mut sqlite3_int64 as *mut libc::c_void,
                );
            }
        }
    }
    if (*p).bSafeModePersist as libc::c_int != 0 && !((*p).db).is_null() {
        sqlite3_set_authorizer(
            (*p).db,
            Some(
                safeModeAuth
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        libc::c_int,
                        *const libc::c_char,
                        *const libc::c_char,
                        *const libc::c_char,
                        *const libc::c_char,
                    ) -> libc::c_int,
            ),
            p as *mut libc::c_void,
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn close_db(mut db: *mut sqlite3) {
    let mut rc: libc::c_int = sqlite3_close(db);
    if rc != 0 {
        fprintf(
            stderr,
            b"Error: sqlite3_close() returns %d: %s\n\0" as *const u8
                as *const libc::c_char,
            rc,
            sqlite3_errmsg(db),
        );
    }
}
unsafe extern "C" fn readline_completion_generator(
    mut text: *const libc::c_char,
    mut state: libc::c_int,
) -> *mut libc::c_char {
    static mut pStmt: *mut sqlite3_stmt = 0 as *const sqlite3_stmt as *mut sqlite3_stmt;
    let mut zRet: *mut libc::c_char = 0 as *mut libc::c_char;
    if state == 0 as libc::c_int {
        let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
        sqlite3_finalize(pStmt);
        zSql = sqlite3_mprintf(
            b"SELECT DISTINCT candidate COLLATE nocase  FROM completion(%Q) ORDER BY 1\0"
                as *const u8 as *const libc::c_char,
            text,
        );
        shell_check_oom(zSql as *mut libc::c_void);
        sqlite3_prepare_v2(
            globalDb,
            zSql,
            -(1 as libc::c_int),
            &mut pStmt,
            0 as *mut *const libc::c_char,
        );
        sqlite3_free(zSql as *mut libc::c_void);
    }
    if sqlite3_step(pStmt) == 100 as libc::c_int {
        let mut z: *const libc::c_char = sqlite3_column_text(pStmt, 0 as libc::c_int)
            as *const libc::c_char;
        zRet = if !z.is_null() { strdup(z) } else { 0 as *mut libc::c_char };
    } else {
        sqlite3_finalize(pStmt);
        pStmt = 0 as *mut sqlite3_stmt;
        zRet = 0 as *mut libc::c_char;
    }
    return zRet;
}
unsafe extern "C" fn readline_completion(
    mut zText: *const libc::c_char,
    mut iStart: libc::c_int,
    mut iEnd: libc::c_int,
) -> *mut *mut libc::c_char {
    rl_attempted_completion_over = 1 as libc::c_int;
    return rl_completion_matches(
        zText,
        Some(
            readline_completion_generator
                as unsafe extern "C" fn(
                    *const libc::c_char,
                    libc::c_int,
                ) -> *mut libc::c_char,
        ),
    );
}
unsafe extern "C" fn resolve_backslashes(mut z: *mut libc::c_char) {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut c: libc::c_char = 0;
    while *z as libc::c_int != 0 && *z as libc::c_int != '\\' as i32 {
        z = z.offset(1);
    }
    j = 0 as libc::c_int;
    i = j;
    loop {
        c = *z.offset(i as isize);
        if !(c as libc::c_int != 0 as libc::c_int) {
            break;
        }
        if c as libc::c_int == '\\' as i32
            && *z.offset((i + 1 as libc::c_int) as isize) as libc::c_int
                != 0 as libc::c_int
        {
            i += 1;
            c = *z.offset(i as isize);
            if c as libc::c_int == 'a' as i32 {
                c = '\u{7}' as i32 as libc::c_char;
            } else if c as libc::c_int == 'b' as i32 {
                c = '\u{8}' as i32 as libc::c_char;
            } else if c as libc::c_int == 't' as i32 {
                c = '\t' as i32 as libc::c_char;
            } else if c as libc::c_int == 'n' as i32 {
                c = '\n' as i32 as libc::c_char;
            } else if c as libc::c_int == 'v' as i32 {
                c = '\u{b}' as i32 as libc::c_char;
            } else if c as libc::c_int == 'f' as i32 {
                c = '\u{c}' as i32 as libc::c_char;
            } else if c as libc::c_int == 'r' as i32 {
                c = '\r' as i32 as libc::c_char;
            } else if c as libc::c_int == '"' as i32 {
                c = '"' as i32 as libc::c_char;
            } else if c as libc::c_int == '\'' as i32 {
                c = '\'' as i32 as libc::c_char;
            } else if c as libc::c_int == '\\' as i32 {
                c = '\\' as i32 as libc::c_char;
            } else if c as libc::c_int >= '0' as i32 && c as libc::c_int <= '7' as i32 {
                c = (c as libc::c_int - '0' as i32) as libc::c_char;
                if *z.offset((i + 1 as libc::c_int) as isize) as libc::c_int
                    >= '0' as i32
                    && *z.offset((i + 1 as libc::c_int) as isize) as libc::c_int
                        <= '7' as i32
                {
                    i += 1;
                    c = (((c as libc::c_int) << 3 as libc::c_int)
                        + *z.offset(i as isize) as libc::c_int - '0' as i32)
                        as libc::c_char;
                    if *z.offset((i + 1 as libc::c_int) as isize) as libc::c_int
                        >= '0' as i32
                        && *z.offset((i + 1 as libc::c_int) as isize) as libc::c_int
                            <= '7' as i32
                    {
                        i += 1;
                        c = (((c as libc::c_int) << 3 as libc::c_int)
                            + *z.offset(i as isize) as libc::c_int - '0' as i32)
                            as libc::c_char;
                    }
                }
            }
        }
        *z.offset(j as isize) = c;
        i += 1;
        j += 1;
    }
    if j < i {
        *z.offset(j as isize) = 0 as libc::c_int as libc::c_char;
    }
}
unsafe extern "C" fn booleanValue(mut zArg: *const libc::c_char) -> libc::c_int {
    let mut i: libc::c_int = 0;
    if *zArg.offset(0 as libc::c_int as isize) as libc::c_int == '0' as i32
        && *zArg.offset(1 as libc::c_int as isize) as libc::c_int == 'x' as i32
    {
        i = 2 as libc::c_int;
        while hexDigitValue(*zArg.offset(i as isize)) >= 0 as libc::c_int {
            i += 1;
        }
    } else {
        i = 0 as libc::c_int;
        while *zArg.offset(i as isize) as libc::c_int >= '0' as i32
            && *zArg.offset(i as isize) as libc::c_int <= '9' as i32
        {
            i += 1;
        }
    }
    if i > 0 as libc::c_int
        && *zArg.offset(i as isize) as libc::c_int == 0 as libc::c_int
    {
        return (integerValue(zArg) & 0xffffffff as libc::c_uint as libc::c_longlong)
            as libc::c_int;
    }
    if sqlite3_stricmp(zArg, b"on\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
        || sqlite3_stricmp(zArg, b"yes\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
    {
        return 1 as libc::c_int;
    }
    if sqlite3_stricmp(zArg, b"off\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
        || sqlite3_stricmp(zArg, b"no\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
    {
        return 0 as libc::c_int;
    }
    fprintf(
        stderr,
        b"ERROR: Not a boolean value: \"%s\". Assuming \"no\".\n\0" as *const u8
            as *const libc::c_char,
        zArg,
    );
    return 0 as libc::c_int;
}
unsafe extern "C" fn setOrClearFlag(
    mut p: *mut ShellState,
    mut mFlag: libc::c_uint,
    mut zArg: *const libc::c_char,
) {
    if booleanValue(zArg) != 0 {
        (*p).shellFlgs |= mFlag;
    } else {
        (*p).shellFlgs &= !mFlag;
    };
}
unsafe extern "C" fn output_file_close(mut f: *mut FILE) {
    if !f.is_null() && f != stdout && f != stderr {
        fclose(f);
    }
}
unsafe extern "C" fn output_file_open(
    mut zFile: *const libc::c_char,
    mut bTextMode: libc::c_int,
) -> *mut FILE {
    let mut f: *mut FILE = 0 as *mut FILE;
    if cli_strcmp(zFile, b"stdout\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        f = stdout;
    } else if cli_strcmp(zFile, b"stderr\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        f = stderr;
    } else if cli_strcmp(zFile, b"off\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        f = 0 as *mut FILE;
    } else {
        f = fopen(
            zFile,
            if bTextMode != 0 {
                b"w\0" as *const u8 as *const libc::c_char
            } else {
                b"wb\0" as *const u8 as *const libc::c_char
            },
        );
        if f.is_null() {
            fprintf(
                stderr,
                b"Error: cannot open \"%s\"\n\0" as *const u8 as *const libc::c_char,
                zFile,
            );
        }
    }
    return f;
}
unsafe extern "C" fn sql_trace_callback(
    mut mType: libc::c_uint,
    mut pArg: *mut libc::c_void,
    mut pP: *mut libc::c_void,
    mut pX: *mut libc::c_void,
) -> libc::c_int {
    let mut p: *mut ShellState = pArg as *mut ShellState;
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut zSql: *const libc::c_char = 0 as *const libc::c_char;
    let mut nSql: i64_0 = 0;
    if ((*p).traceOut).is_null() {
        return 0 as libc::c_int;
    }
    if mType == 0x8 as libc::c_int as libc::c_uint {
        fprintf(
            (*p).traceOut,
            b"-- closing database connection\n\0" as *const u8 as *const libc::c_char,
        );
        return 0 as libc::c_int;
    }
    if mType != 0x4 as libc::c_int as libc::c_uint
        && *(pX as *const libc::c_char).offset(0 as libc::c_int as isize) as libc::c_int
            == '-' as i32
    {
        zSql = pX as *const libc::c_char;
    } else {
        pStmt = pP as *mut sqlite3_stmt;
        match (*p).eTraceType as libc::c_int {
            1 => {
                zSql = sqlite3_expanded_sql(pStmt);
            }
            _ => {
                zSql = sqlite3_sql(pStmt);
            }
        }
    }
    if zSql.is_null() {
        return 0 as libc::c_int;
    }
    nSql = strlen(zSql) as i64_0;
    if nSql > 1000000000 as libc::c_int as libc::c_longlong {
        nSql = 1000000000 as libc::c_int as i64_0;
    }
    while nSql > 0 as libc::c_int as libc::c_longlong
        && *zSql.offset((nSql - 1 as libc::c_int as libc::c_longlong) as isize)
            as libc::c_int == ';' as i32
    {
        nSql -= 1;
    }
    match mType {
        4 | 1 => {
            fprintf(
                (*p).traceOut,
                b"%.*s;\n\0" as *const u8 as *const libc::c_char,
                nSql as libc::c_int,
                zSql,
            );
        }
        2 => {
            let mut nNanosec: sqlite3_int64 = *(pX as *mut sqlite3_int64);
            fprintf(
                (*p).traceOut,
                b"%.*s; -- %lld ns\n\0" as *const u8 as *const libc::c_char,
                nSql as libc::c_int,
                zSql,
                nNanosec,
            );
        }
        _ => {}
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn test_breakpoint() {
    static mut nCall: libc::c_int = 0 as libc::c_int;
    nCall += 1;
}
unsafe extern "C" fn import_cleanup(mut p: *mut ImportCtx) {
    if !((*p).in_0).is_null() && ((*p).xCloser).is_some() {
        ((*p).xCloser).expect("non-null function pointer")((*p).in_0);
        let ref mut fresh387 = (*p).in_0;
        *fresh387 = 0 as *mut FILE;
    }
    sqlite3_free((*p).z as *mut libc::c_void);
    let ref mut fresh388 = (*p).z;
    *fresh388 = 0 as *mut libc::c_char;
}
unsafe extern "C" fn import_append_char(mut p: *mut ImportCtx, mut c: libc::c_int) {
    if (*p).n + 1 as libc::c_int >= (*p).nAlloc {
        (*p).nAlloc += (*p).nAlloc + 100 as libc::c_int;
        let ref mut fresh389 = (*p).z;
        *fresh389 = sqlite3_realloc64(
            (*p).z as *mut libc::c_void,
            (*p).nAlloc as sqlite3_uint64,
        ) as *mut libc::c_char;
        shell_check_oom((*p).z as *mut libc::c_void);
    }
    let ref mut fresh390 = (*p).n;
    let fresh391 = *fresh390;
    *fresh390 = *fresh390 + 1;
    *((*p).z).offset(fresh391 as isize) = c as libc::c_char;
}
unsafe extern "C" fn csv_read_one_field(mut p: *mut ImportCtx) -> *mut libc::c_char {
    let mut c: libc::c_int = 0;
    let mut cSep: libc::c_int = (*p).cColSep;
    let mut rSep: libc::c_int = (*p).cRowSep;
    (*p).n = 0 as libc::c_int;
    c = fgetc((*p).in_0);
    if c == -(1 as libc::c_int) || seenInterrupt != 0 {
        (*p).cTerm = -(1 as libc::c_int);
        return 0 as *mut libc::c_char;
    }
    if c == '"' as i32 {
        let mut pc: libc::c_int = 0;
        let mut ppc: libc::c_int = 0;
        let mut startLine: libc::c_int = (*p).nLine;
        let mut cQuote: libc::c_int = c;
        ppc = 0 as libc::c_int;
        pc = ppc;
        loop {
            c = fgetc((*p).in_0);
            if c == rSep {
                let ref mut fresh392 = (*p).nLine;
                *fresh392 += 1;
            }
            if c == cQuote {
                if pc == cQuote {
                    pc = 0 as libc::c_int;
                    continue;
                }
            }
            if c == cSep && pc == cQuote || c == rSep && pc == cQuote
                || c == rSep && pc == '\r' as i32 && ppc == cQuote
                || c == -(1 as libc::c_int) && pc == cQuote
            {
                loop {
                    let ref mut fresh393 = (*p).n;
                    *fresh393 -= 1;
                    if !(*((*p).z).offset((*p).n as isize) as libc::c_int != cQuote) {
                        break;
                    }
                }
                (*p).cTerm = c;
                break;
            } else {
                if pc == cQuote && c != '\r' as i32 {
                    fprintf(
                        stderr,
                        b"%s:%d: unescaped %c character\n\0" as *const u8
                            as *const libc::c_char,
                        (*p).zFile,
                        (*p).nLine,
                        cQuote,
                    );
                }
                if c == -(1 as libc::c_int) {
                    fprintf(
                        stderr,
                        b"%s:%d: unterminated %c-quoted field\n\0" as *const u8
                            as *const libc::c_char,
                        (*p).zFile,
                        startLine,
                        cQuote,
                    );
                    (*p).cTerm = c;
                    break;
                } else {
                    import_append_char(p, c);
                    ppc = pc;
                    pc = c;
                }
            }
        }
    } else {
        if c & 0xff as libc::c_int == 0xef as libc::c_int
            && (*p).bNotFirst == 0 as libc::c_int
        {
            import_append_char(p, c);
            c = fgetc((*p).in_0);
            if c & 0xff as libc::c_int == 0xbb as libc::c_int {
                import_append_char(p, c);
                c = fgetc((*p).in_0);
                if c & 0xff as libc::c_int == 0xbf as libc::c_int {
                    (*p).bNotFirst = 1 as libc::c_int;
                    (*p).n = 0 as libc::c_int;
                    return csv_read_one_field(p);
                }
            }
        }
        while c != -(1 as libc::c_int) && c != cSep && c != rSep {
            import_append_char(p, c);
            c = fgetc((*p).in_0);
        }
        if c == rSep {
            let ref mut fresh394 = (*p).nLine;
            *fresh394 += 1;
            if (*p).n > 0 as libc::c_int
                && *((*p).z).offset(((*p).n - 1 as libc::c_int) as isize) as libc::c_int
                    == '\r' as i32
            {
                let ref mut fresh395 = (*p).n;
                *fresh395 -= 1;
            }
        }
        (*p).cTerm = c;
    }
    if !((*p).z).is_null() {
        *((*p).z).offset((*p).n as isize) = 0 as libc::c_int as libc::c_char;
    }
    (*p).bNotFirst = 1 as libc::c_int;
    return (*p).z;
}
unsafe extern "C" fn ascii_read_one_field(mut p: *mut ImportCtx) -> *mut libc::c_char {
    let mut c: libc::c_int = 0;
    let mut cSep: libc::c_int = (*p).cColSep;
    let mut rSep: libc::c_int = (*p).cRowSep;
    (*p).n = 0 as libc::c_int;
    c = fgetc((*p).in_0);
    if c == -(1 as libc::c_int) || seenInterrupt != 0 {
        (*p).cTerm = -(1 as libc::c_int);
        return 0 as *mut libc::c_char;
    }
    while c != -(1 as libc::c_int) && c != cSep && c != rSep {
        import_append_char(p, c);
        c = fgetc((*p).in_0);
    }
    if c == rSep {
        let ref mut fresh396 = (*p).nLine;
        *fresh396 += 1;
    }
    (*p).cTerm = c;
    if !((*p).z).is_null() {
        *((*p).z).offset((*p).n as isize) = 0 as libc::c_int as libc::c_char;
    }
    return (*p).z;
}
unsafe extern "C" fn tryToCloneData(
    mut p: *mut ShellState,
    mut newDb: *mut sqlite3,
    mut zTable: *const libc::c_char,
) {
    let mut pQuery: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut pInsert: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut zQuery: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zInsert: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut rc: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut nTable: libc::c_int = strlen30(zTable);
    let mut k: libc::c_int = 0 as libc::c_int;
    let mut cnt: libc::c_int = 0 as libc::c_int;
    let spinRate: libc::c_int = 10000 as libc::c_int;
    zQuery = sqlite3_mprintf(
        b"SELECT * FROM \"%w\"\0" as *const u8 as *const libc::c_char,
        zTable,
    );
    shell_check_oom(zQuery as *mut libc::c_void);
    rc = sqlite3_prepare_v2(
        (*p).db,
        zQuery,
        -(1 as libc::c_int),
        &mut pQuery,
        0 as *mut *const libc::c_char,
    );
    if rc != 0 {
        fprintf(
            stderr,
            b"Error %d: %s on [%s]\n\0" as *const u8 as *const libc::c_char,
            sqlite3_extended_errcode((*p).db),
            sqlite3_errmsg((*p).db),
            zQuery,
        );
    } else {
        n = sqlite3_column_count(pQuery);
        zInsert = sqlite3_malloc64(
            (200 as libc::c_int + nTable + n * 3 as libc::c_int) as sqlite3_uint64,
        ) as *mut libc::c_char;
        shell_check_oom(zInsert as *mut libc::c_void);
        sqlite3_snprintf(
            200 as libc::c_int + nTable,
            zInsert,
            b"INSERT OR IGNORE INTO \"%s\" VALUES(?\0" as *const u8
                as *const libc::c_char,
            zTable,
        );
        i = strlen30(zInsert);
        j = 1 as libc::c_int;
        while j < n {
            memcpy(
                zInsert.offset(i as isize) as *mut libc::c_void,
                b",?\0" as *const u8 as *const libc::c_char as *const libc::c_void,
                2 as libc::c_int as libc::c_ulong,
            );
            i += 2 as libc::c_int;
            j += 1;
        }
        memcpy(
            zInsert.offset(i as isize) as *mut libc::c_void,
            b");\0" as *const u8 as *const libc::c_char as *const libc::c_void,
            3 as libc::c_int as libc::c_ulong,
        );
        rc = sqlite3_prepare_v2(
            newDb,
            zInsert,
            -(1 as libc::c_int),
            &mut pInsert,
            0 as *mut *const libc::c_char,
        );
        if rc != 0 {
            fprintf(
                stderr,
                b"Error %d: %s on [%s]\n\0" as *const u8 as *const libc::c_char,
                sqlite3_extended_errcode(newDb),
                sqlite3_errmsg(newDb),
                zQuery,
            );
        } else {
            k = 0 as libc::c_int;
            while k < 2 as libc::c_int {
                loop {
                    rc = sqlite3_step(pQuery);
                    if !(rc == 100 as libc::c_int) {
                        break;
                    }
                    i = 0 as libc::c_int;
                    while i < n {
                        match sqlite3_column_type(pQuery, i) {
                            5 => {
                                sqlite3_bind_null(pInsert, i + 1 as libc::c_int);
                            }
                            1 => {
                                sqlite3_bind_int64(
                                    pInsert,
                                    i + 1 as libc::c_int,
                                    sqlite3_column_int64(pQuery, i),
                                );
                            }
                            2 => {
                                sqlite3_bind_double(
                                    pInsert,
                                    i + 1 as libc::c_int,
                                    sqlite3_column_double(pQuery, i),
                                );
                            }
                            3 => {
                                sqlite3_bind_text(
                                    pInsert,
                                    i + 1 as libc::c_int,
                                    sqlite3_column_text(pQuery, i) as *const libc::c_char,
                                    -(1 as libc::c_int),
                                    None,
                                );
                            }
                            4 => {
                                sqlite3_bind_blob(
                                    pInsert,
                                    i + 1 as libc::c_int,
                                    sqlite3_column_blob(pQuery, i),
                                    sqlite3_column_bytes(pQuery, i),
                                    None,
                                );
                            }
                            _ => {}
                        }
                        i += 1;
                    }
                    rc = sqlite3_step(pInsert);
                    if rc != 0 as libc::c_int && rc != 100 as libc::c_int
                        && rc != 101 as libc::c_int
                    {
                        fprintf(
                            stderr,
                            b"Error %d: %s\n\0" as *const u8 as *const libc::c_char,
                            sqlite3_extended_errcode(newDb),
                            sqlite3_errmsg(newDb),
                        );
                    }
                    sqlite3_reset(pInsert);
                    cnt += 1;
                    if cnt % spinRate == 0 as libc::c_int {
                        printf(
                            b"%c\x08\0" as *const u8 as *const libc::c_char,
                            (*::std::mem::transmute::<
                                &[u8; 5],
                                &[libc::c_char; 5],
                            >(b"|/-\\\0"))[(cnt / spinRate % 4 as libc::c_int) as usize]
                                as libc::c_int,
                        );
                        fflush(stdout);
                    }
                }
                if rc == 101 as libc::c_int {
                    break;
                }
                sqlite3_finalize(pQuery);
                sqlite3_free(zQuery as *mut libc::c_void);
                zQuery = sqlite3_mprintf(
                    b"SELECT * FROM \"%w\" ORDER BY rowid DESC;\0" as *const u8
                        as *const libc::c_char,
                    zTable,
                );
                shell_check_oom(zQuery as *mut libc::c_void);
                rc = sqlite3_prepare_v2(
                    (*p).db,
                    zQuery,
                    -(1 as libc::c_int),
                    &mut pQuery,
                    0 as *mut *const libc::c_char,
                );
                if rc != 0 {
                    fprintf(
                        stderr,
                        b"Warning: cannot step \"%s\" backwards\0" as *const u8
                            as *const libc::c_char,
                        zTable,
                    );
                    break;
                } else {
                    k += 1;
                }
            }
        }
    }
    sqlite3_finalize(pQuery);
    sqlite3_finalize(pInsert);
    sqlite3_free(zQuery as *mut libc::c_void);
    sqlite3_free(zInsert as *mut libc::c_void);
}
unsafe extern "C" fn tryToCloneSchema(
    mut p: *mut ShellState,
    mut newDb: *mut sqlite3,
    mut zWhere: *const libc::c_char,
    mut xForEach: Option::<
        unsafe extern "C" fn(*mut ShellState, *mut sqlite3, *const libc::c_char) -> (),
    >,
) {
    let mut pQuery: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut zQuery: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut rc: libc::c_int = 0;
    let mut zName: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut zSql: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut zErrMsg: *mut libc::c_char = 0 as *mut libc::c_char;
    zQuery = sqlite3_mprintf(
        b"SELECT name, sql FROM sqlite_schema WHERE %s\0" as *const u8
            as *const libc::c_char,
        zWhere,
    );
    shell_check_oom(zQuery as *mut libc::c_void);
    rc = sqlite3_prepare_v2(
        (*p).db,
        zQuery,
        -(1 as libc::c_int),
        &mut pQuery,
        0 as *mut *const libc::c_char,
    );
    if rc != 0 {
        fprintf(
            stderr,
            b"Error: (%d) %s on [%s]\n\0" as *const u8 as *const libc::c_char,
            sqlite3_extended_errcode((*p).db),
            sqlite3_errmsg((*p).db),
            zQuery,
        );
    } else {
        loop {
            rc = sqlite3_step(pQuery);
            if !(rc == 100 as libc::c_int) {
                break;
            }
            zName = sqlite3_column_text(pQuery, 0 as libc::c_int);
            zSql = sqlite3_column_text(pQuery, 1 as libc::c_int);
            if zName.is_null() || zSql.is_null() {
                continue;
            }
            printf(b"%s... \0" as *const u8 as *const libc::c_char, zName);
            fflush(stdout);
            sqlite3_exec(
                newDb,
                zSql as *const libc::c_char,
                None,
                0 as *mut libc::c_void,
                &mut zErrMsg,
            );
            if !zErrMsg.is_null() {
                fprintf(
                    stderr,
                    b"Error: %s\nSQL: [%s]\n\0" as *const u8 as *const libc::c_char,
                    zErrMsg,
                    zSql,
                );
                sqlite3_free(zErrMsg as *mut libc::c_void);
                zErrMsg = 0 as *mut libc::c_char;
            }
            if xForEach.is_some() {
                xForEach
                    .expect(
                        "non-null function pointer",
                    )(p, newDb, zName as *const libc::c_char);
            }
            printf(b"done\n\0" as *const u8 as *const libc::c_char);
        }
        if rc != 101 as libc::c_int {
            sqlite3_finalize(pQuery);
            sqlite3_free(zQuery as *mut libc::c_void);
            zQuery = sqlite3_mprintf(
                b"SELECT name, sql FROM sqlite_schema WHERE %s ORDER BY rowid DESC\0"
                    as *const u8 as *const libc::c_char,
                zWhere,
            );
            shell_check_oom(zQuery as *mut libc::c_void);
            rc = sqlite3_prepare_v2(
                (*p).db,
                zQuery,
                -(1 as libc::c_int),
                &mut pQuery,
                0 as *mut *const libc::c_char,
            );
            if rc != 0 {
                fprintf(
                    stderr,
                    b"Error: (%d) %s on [%s]\n\0" as *const u8 as *const libc::c_char,
                    sqlite3_extended_errcode((*p).db),
                    sqlite3_errmsg((*p).db),
                    zQuery,
                );
            } else {
                while sqlite3_step(pQuery) == 100 as libc::c_int {
                    zName = sqlite3_column_text(pQuery, 0 as libc::c_int);
                    zSql = sqlite3_column_text(pQuery, 1 as libc::c_int);
                    if zName.is_null() || zSql.is_null() {
                        continue;
                    }
                    printf(b"%s... \0" as *const u8 as *const libc::c_char, zName);
                    fflush(stdout);
                    sqlite3_exec(
                        newDb,
                        zSql as *const libc::c_char,
                        None,
                        0 as *mut libc::c_void,
                        &mut zErrMsg,
                    );
                    if !zErrMsg.is_null() {
                        fprintf(
                            stderr,
                            b"Error: %s\nSQL: [%s]\n\0" as *const u8
                                as *const libc::c_char,
                            zErrMsg,
                            zSql,
                        );
                        sqlite3_free(zErrMsg as *mut libc::c_void);
                        zErrMsg = 0 as *mut libc::c_char;
                    }
                    if xForEach.is_some() {
                        xForEach
                            .expect(
                                "non-null function pointer",
                            )(p, newDb, zName as *const libc::c_char);
                    }
                    printf(b"done\n\0" as *const u8 as *const libc::c_char);
                }
            }
        }
    }
    sqlite3_finalize(pQuery);
    sqlite3_free(zQuery as *mut libc::c_void);
}
unsafe extern "C" fn tryToClone(
    mut p: *mut ShellState,
    mut zNewDb: *const libc::c_char,
) {
    let mut rc: libc::c_int = 0;
    let mut newDb: *mut sqlite3 = 0 as *mut sqlite3;
    if access(zNewDb, 0 as libc::c_int) == 0 as libc::c_int {
        fprintf(
            stderr,
            b"File \"%s\" already exists.\n\0" as *const u8 as *const libc::c_char,
            zNewDb,
        );
        return;
    }
    rc = sqlite3_open(zNewDb, &mut newDb);
    if rc != 0 {
        fprintf(
            stderr,
            b"Cannot create output database: %s\n\0" as *const u8 as *const libc::c_char,
            sqlite3_errmsg(newDb),
        );
    } else {
        sqlite3_exec(
            (*p).db,
            b"PRAGMA writable_schema=ON;\0" as *const u8 as *const libc::c_char,
            None,
            0 as *mut libc::c_void,
            0 as *mut *mut libc::c_char,
        );
        sqlite3_exec(
            newDb,
            b"BEGIN EXCLUSIVE;\0" as *const u8 as *const libc::c_char,
            None,
            0 as *mut libc::c_void,
            0 as *mut *mut libc::c_char,
        );
        tryToCloneSchema(
            p,
            newDb,
            b"type='table'\0" as *const u8 as *const libc::c_char,
            Some(
                tryToCloneData
                    as unsafe extern "C" fn(
                        *mut ShellState,
                        *mut sqlite3,
                        *const libc::c_char,
                    ) -> (),
            ),
        );
        tryToCloneSchema(
            p,
            newDb,
            b"type!='table'\0" as *const u8 as *const libc::c_char,
            None,
        );
        sqlite3_exec(
            newDb,
            b"COMMIT;\0" as *const u8 as *const libc::c_char,
            None,
            0 as *mut libc::c_void,
            0 as *mut *mut libc::c_char,
        );
        sqlite3_exec(
            (*p).db,
            b"PRAGMA writable_schema=OFF;\0" as *const u8 as *const libc::c_char,
            None,
            0 as *mut libc::c_void,
            0 as *mut *mut libc::c_char,
        );
    }
    close_db(newDb);
}
unsafe extern "C" fn output_reset(mut p: *mut ShellState) {
    if (*p).outfile[0 as libc::c_int as usize] as libc::c_int == '|' as i32 {
        pclose((*p).out);
    } else {
        output_file_close((*p).out);
        if (*p).doXdgOpen != 0 {
            let mut zXdgOpenCmd: *const libc::c_char = b"xdg-open\0" as *const u8
                as *const libc::c_char;
            let mut zCmd: *mut libc::c_char = 0 as *mut libc::c_char;
            zCmd = sqlite3_mprintf(
                b"%s %s\0" as *const u8 as *const libc::c_char,
                zXdgOpenCmd,
                (*p).zTempFile,
            );
            if system(zCmd) != 0 {
                fprintf(
                    stderr,
                    b"Failed: [%s]\n\0" as *const u8 as *const libc::c_char,
                    zCmd,
                );
            } else {
                sqlite3_sleep(2000 as libc::c_int);
            }
            sqlite3_free(zCmd as *mut libc::c_void);
            outputModePop(p);
            (*p).doXdgOpen = 0 as libc::c_int as u8_0;
        }
    }
    (*p).outfile[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    let ref mut fresh397 = (*p).out;
    *fresh397 = stdout;
}
unsafe extern "C" fn db_int(
    mut db: *mut sqlite3,
    mut zSql: *const libc::c_char,
) -> libc::c_int {
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut res: libc::c_int = 0 as libc::c_int;
    sqlite3_prepare_v2(
        db,
        zSql,
        -(1 as libc::c_int),
        &mut pStmt,
        0 as *mut *const libc::c_char,
    );
    if !pStmt.is_null() && sqlite3_step(pStmt) == 100 as libc::c_int {
        res = sqlite3_column_int(pStmt, 0 as libc::c_int);
    }
    sqlite3_finalize(pStmt);
    return res;
}
unsafe extern "C" fn get2byteInt(mut a: *mut libc::c_uchar) -> libc::c_uint {
    return (((*a.offset(0 as libc::c_int as isize) as libc::c_int) << 8 as libc::c_int)
        + *a.offset(1 as libc::c_int as isize) as libc::c_int) as libc::c_uint;
}
unsafe extern "C" fn get4byteInt(mut a: *mut libc::c_uchar) -> libc::c_uint {
    return (((*a.offset(0 as libc::c_int as isize) as libc::c_int) << 24 as libc::c_int)
        + ((*a.offset(1 as libc::c_int as isize) as libc::c_int) << 16 as libc::c_int)
        + ((*a.offset(2 as libc::c_int as isize) as libc::c_int) << 8 as libc::c_int)
        + *a.offset(3 as libc::c_int as isize) as libc::c_int) as libc::c_uint;
}
unsafe extern "C" fn shell_dbinfo_command(
    mut p: *mut ShellState,
    mut nArg: libc::c_int,
    mut azArg: *mut *mut libc::c_char,
) -> libc::c_int {
    static mut aField: [C2RustUnnamed_23; 12] = [
        {
            let mut init = C2RustUnnamed_23 {
                zName: b"file change counter:\0" as *const u8 as *const libc::c_char,
                ofst: 24 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_23 {
                zName: b"database page count:\0" as *const u8 as *const libc::c_char,
                ofst: 28 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_23 {
                zName: b"freelist page count:\0" as *const u8 as *const libc::c_char,
                ofst: 36 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_23 {
                zName: b"schema cookie:\0" as *const u8 as *const libc::c_char,
                ofst: 40 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_23 {
                zName: b"schema format:\0" as *const u8 as *const libc::c_char,
                ofst: 44 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_23 {
                zName: b"default cache size:\0" as *const u8 as *const libc::c_char,
                ofst: 48 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_23 {
                zName: b"autovacuum top root:\0" as *const u8 as *const libc::c_char,
                ofst: 52 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_23 {
                zName: b"incremental vacuum:\0" as *const u8 as *const libc::c_char,
                ofst: 64 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_23 {
                zName: b"text encoding:\0" as *const u8 as *const libc::c_char,
                ofst: 56 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_23 {
                zName: b"user version:\0" as *const u8 as *const libc::c_char,
                ofst: 60 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_23 {
                zName: b"application id:\0" as *const u8 as *const libc::c_char,
                ofst: 68 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_23 {
                zName: b"software version:\0" as *const u8 as *const libc::c_char,
                ofst: 96 as libc::c_int,
            };
            init
        },
    ];
    static mut aQuery: [C2RustUnnamed_22; 5] = [
        {
            let mut init = C2RustUnnamed_22 {
                zName: b"number of tables:\0" as *const u8 as *const libc::c_char,
                zSql: b"SELECT count(*) FROM %s WHERE type='table'\0" as *const u8
                    as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_22 {
                zName: b"number of indexes:\0" as *const u8 as *const libc::c_char,
                zSql: b"SELECT count(*) FROM %s WHERE type='index'\0" as *const u8
                    as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_22 {
                zName: b"number of triggers:\0" as *const u8 as *const libc::c_char,
                zSql: b"SELECT count(*) FROM %s WHERE type='trigger'\0" as *const u8
                    as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_22 {
                zName: b"number of views:\0" as *const u8 as *const libc::c_char,
                zSql: b"SELECT count(*) FROM %s WHERE type='view'\0" as *const u8
                    as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_22 {
                zName: b"schema size:\0" as *const u8 as *const libc::c_char,
                zSql: b"SELECT total(length(sql)) FROM %s\0" as *const u8
                    as *const libc::c_char,
            };
            init
        },
    ];
    let mut i: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    let mut iDataVersion: libc::c_uint = 0;
    let mut zSchemaTab: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zDb: *mut libc::c_char = (if nArg >= 2 as libc::c_int {
        *azArg.offset(1 as libc::c_int as isize) as *const libc::c_char
    } else {
        b"main\0" as *const u8 as *const libc::c_char
    }) as *mut libc::c_char;
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut aHdr: [libc::c_uchar; 100] = [0; 100];
    open_db(p, 0 as libc::c_int);
    if ((*p).db).is_null() {
        return 1 as libc::c_int;
    }
    rc = sqlite3_prepare_v2(
        (*p).db,
        b"SELECT data FROM sqlite_dbpage(?1) WHERE pgno=1\0" as *const u8
            as *const libc::c_char,
        -(1 as libc::c_int),
        &mut pStmt,
        0 as *mut *const libc::c_char,
    );
    if rc != 0 {
        fprintf(
            stderr,
            b"error: %s\n\0" as *const u8 as *const libc::c_char,
            sqlite3_errmsg((*p).db),
        );
        sqlite3_finalize(pStmt);
        return 1 as libc::c_int;
    }
    sqlite3_bind_text(pStmt, 1 as libc::c_int, zDb, -(1 as libc::c_int), None);
    if sqlite3_step(pStmt) == 100 as libc::c_int
        && sqlite3_column_bytes(pStmt, 0 as libc::c_int) > 100 as libc::c_int
    {
        memcpy(
            aHdr.as_mut_ptr() as *mut libc::c_void,
            sqlite3_column_blob(pStmt, 0 as libc::c_int),
            100 as libc::c_int as libc::c_ulong,
        );
        sqlite3_finalize(pStmt);
    } else {
        fprintf(
            stderr,
            b"unable to read database header\n\0" as *const u8 as *const libc::c_char,
        );
        sqlite3_finalize(pStmt);
        return 1 as libc::c_int;
    }
    i = get2byteInt(aHdr.as_mut_ptr().offset(16 as libc::c_int as isize)) as libc::c_int;
    if i == 1 as libc::c_int {
        i = 65536 as libc::c_int;
    }
    fprintf(
        (*p).out,
        b"%-20s %d\n\0" as *const u8 as *const libc::c_char,
        b"database page size:\0" as *const u8 as *const libc::c_char,
        i,
    );
    fprintf(
        (*p).out,
        b"%-20s %d\n\0" as *const u8 as *const libc::c_char,
        b"write format:\0" as *const u8 as *const libc::c_char,
        aHdr[18 as libc::c_int as usize] as libc::c_int,
    );
    fprintf(
        (*p).out,
        b"%-20s %d\n\0" as *const u8 as *const libc::c_char,
        b"read format:\0" as *const u8 as *const libc::c_char,
        aHdr[19 as libc::c_int as usize] as libc::c_int,
    );
    fprintf(
        (*p).out,
        b"%-20s %d\n\0" as *const u8 as *const libc::c_char,
        b"reserved bytes:\0" as *const u8 as *const libc::c_char,
        aHdr[20 as libc::c_int as usize] as libc::c_int,
    );
    i = 0 as libc::c_int;
    while i
        < (::std::mem::size_of::<[C2RustUnnamed_23; 12]>() as libc::c_ulong)
            .wrapping_div(::std::mem::size_of::<C2RustUnnamed_23>() as libc::c_ulong)
            as libc::c_int
    {
        let mut ofst: libc::c_int = aField[i as usize].ofst;
        let mut val: libc::c_uint = get4byteInt(aHdr.as_mut_ptr().offset(ofst as isize));
        fprintf(
            (*p).out,
            b"%-20s %u\0" as *const u8 as *const libc::c_char,
            aField[i as usize].zName,
            val,
        );
        match ofst {
            56 => {
                if val == 1 as libc::c_int as libc::c_uint {
                    fprintf((*p).out, b" (utf8)\0" as *const u8 as *const libc::c_char);
                }
                if val == 2 as libc::c_int as libc::c_uint {
                    fprintf(
                        (*p).out,
                        b" (utf16le)\0" as *const u8 as *const libc::c_char,
                    );
                }
                if val == 3 as libc::c_int as libc::c_uint {
                    fprintf(
                        (*p).out,
                        b" (utf16be)\0" as *const u8 as *const libc::c_char,
                    );
                }
            }
            _ => {}
        }
        fprintf((*p).out, b"\n\0" as *const u8 as *const libc::c_char);
        i += 1;
    }
    if zDb.is_null() {
        zSchemaTab = sqlite3_mprintf(
            b"main.sqlite_schema\0" as *const u8 as *const libc::c_char,
        );
    } else if cli_strcmp(zDb, b"temp\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        zSchemaTab = sqlite3_mprintf(
            b"%s\0" as *const u8 as *const libc::c_char,
            b"sqlite_temp_schema\0" as *const u8 as *const libc::c_char,
        );
    } else {
        zSchemaTab = sqlite3_mprintf(
            b"\"%w\".sqlite_schema\0" as *const u8 as *const libc::c_char,
            zDb,
        );
    }
    i = 0 as libc::c_int;
    while i
        < (::std::mem::size_of::<[C2RustUnnamed_22; 5]>() as libc::c_ulong)
            .wrapping_div(::std::mem::size_of::<C2RustUnnamed_22>() as libc::c_ulong)
            as libc::c_int
    {
        let mut zSql: *mut libc::c_char = sqlite3_mprintf(
            aQuery[i as usize].zSql,
            zSchemaTab,
        );
        let mut val_0: libc::c_int = db_int((*p).db, zSql);
        sqlite3_free(zSql as *mut libc::c_void);
        fprintf(
            (*p).out,
            b"%-20s %d\n\0" as *const u8 as *const libc::c_char,
            aQuery[i as usize].zName,
            val_0,
        );
        i += 1;
    }
    sqlite3_free(zSchemaTab as *mut libc::c_void);
    sqlite3_file_control(
        (*p).db,
        zDb,
        35 as libc::c_int,
        &mut iDataVersion as *mut libc::c_uint as *mut libc::c_void,
    );
    fprintf(
        (*p).out,
        b"%-20s %u\n\0" as *const u8 as *const libc::c_char,
        b"data version\0" as *const u8 as *const libc::c_char,
        iDataVersion,
    );
    return 0 as libc::c_int;
}
unsafe extern "C" fn shellDatabaseError(mut db: *mut sqlite3) -> libc::c_int {
    let mut zErr: *const libc::c_char = sqlite3_errmsg(db);
    fprintf(stderr, b"Error: %s\n\0" as *const u8 as *const libc::c_char, zErr);
    return 1 as libc::c_int;
}
unsafe extern "C" fn testcase_glob(
    mut zGlob: *const libc::c_char,
    mut z: *const libc::c_char,
) -> libc::c_int {
    let mut c: libc::c_int = 0;
    let mut c2: libc::c_int = 0;
    let mut invert: libc::c_int = 0;
    let mut seen: libc::c_int = 0;
    loop {
        let fresh398 = zGlob;
        zGlob = zGlob.offset(1);
        c = *fresh398 as libc::c_int;
        if !(c != 0 as libc::c_int) {
            break;
        }
        if *(*__ctype_b_loc()).offset(c as libc::c_uchar as libc::c_int as isize)
            as libc::c_int & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
            != 0
        {
            if *(*__ctype_b_loc()).offset(*z as libc::c_uchar as libc::c_int as isize)
                as libc::c_int & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                == 0
            {
                return 0 as libc::c_int;
            }
            while *(*__ctype_b_loc())
                .offset(*zGlob as libc::c_uchar as libc::c_int as isize) as libc::c_int
                & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0
            {
                zGlob = zGlob.offset(1);
            }
            while *(*__ctype_b_loc()).offset(*z as libc::c_uchar as libc::c_int as isize)
                as libc::c_int & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                != 0
            {
                z = z.offset(1);
            }
        } else if c == '*' as i32 {
            loop {
                let fresh399 = zGlob;
                zGlob = zGlob.offset(1);
                c = *fresh399 as libc::c_int;
                if !(c == '*' as i32 || c == '?' as i32) {
                    break;
                }
                if c == '?' as i32
                    && {
                        let fresh400 = z;
                        z = z.offset(1);
                        *fresh400 as libc::c_int == 0 as libc::c_int
                    }
                {
                    return 0 as libc::c_int;
                }
            }
            if c == 0 as libc::c_int {
                return 1 as libc::c_int
            } else {
                if c == '[' as i32 {
                    while *z as libc::c_int != 0
                        && testcase_glob(zGlob.offset(-(1 as libc::c_int as isize)), z)
                            == 0 as libc::c_int
                    {
                        z = z.offset(1);
                    }
                    return (*z as libc::c_int != 0 as libc::c_int) as libc::c_int;
                }
            }
            loop {
                let fresh401 = z;
                z = z.offset(1);
                c2 = *fresh401 as libc::c_int;
                if !(c2 != 0 as libc::c_int) {
                    break;
                }
                while c2 != c {
                    let fresh402 = z;
                    z = z.offset(1);
                    c2 = *fresh402 as libc::c_int;
                    if c2 == 0 as libc::c_int {
                        return 0 as libc::c_int;
                    }
                }
                if testcase_glob(zGlob, z) != 0 {
                    return 1 as libc::c_int;
                }
            }
            return 0 as libc::c_int;
        } else {
            if c == '?' as i32 {
                let fresh403 = z;
                z = z.offset(1);
                if *fresh403 as libc::c_int == 0 as libc::c_int {
                    return 0 as libc::c_int;
                }
            } else if c == '[' as i32 {
                let mut prior_c: libc::c_int = 0 as libc::c_int;
                seen = 0 as libc::c_int;
                invert = 0 as libc::c_int;
                let fresh404 = z;
                z = z.offset(1);
                c = *fresh404 as libc::c_int;
                if c == 0 as libc::c_int {
                    return 0 as libc::c_int;
                }
                let fresh405 = zGlob;
                zGlob = zGlob.offset(1);
                c2 = *fresh405 as libc::c_int;
                if c2 == '^' as i32 {
                    invert = 1 as libc::c_int;
                    let fresh406 = zGlob;
                    zGlob = zGlob.offset(1);
                    c2 = *fresh406 as libc::c_int;
                }
                if c2 == ']' as i32 {
                    if c == ']' as i32 {
                        seen = 1 as libc::c_int;
                    }
                    let fresh407 = zGlob;
                    zGlob = zGlob.offset(1);
                    c2 = *fresh407 as libc::c_int;
                }
                while c2 != 0 && c2 != ']' as i32 {
                    if c2 == '-' as i32
                        && *zGlob.offset(0 as libc::c_int as isize) as libc::c_int
                            != ']' as i32
                        && *zGlob.offset(0 as libc::c_int as isize) as libc::c_int
                            != 0 as libc::c_int && prior_c > 0 as libc::c_int
                    {
                        let fresh408 = zGlob;
                        zGlob = zGlob.offset(1);
                        c2 = *fresh408 as libc::c_int;
                        if c >= prior_c && c <= c2 {
                            seen = 1 as libc::c_int;
                        }
                        prior_c = 0 as libc::c_int;
                    } else {
                        if c == c2 {
                            seen = 1 as libc::c_int;
                        }
                        prior_c = c2;
                    }
                    let fresh409 = zGlob;
                    zGlob = zGlob.offset(1);
                    c2 = *fresh409 as libc::c_int;
                }
                if c2 == 0 as libc::c_int || seen ^ invert == 0 as libc::c_int {
                    return 0 as libc::c_int;
                }
            } else if c == '#' as i32 {
                if (*z.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
                    || *z.offset(0 as libc::c_int as isize) as libc::c_int == '+' as i32)
                    && *(*__ctype_b_loc())
                        .offset(
                            *z.offset(1 as libc::c_int as isize) as libc::c_uchar
                                as libc::c_int as isize,
                        ) as libc::c_int
                        & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int != 0
                {
                    z = z.offset(1);
                }
                if *(*__ctype_b_loc())
                    .offset(
                        *z.offset(0 as libc::c_int as isize) as libc::c_uchar
                            as libc::c_int as isize,
                    ) as libc::c_int
                    & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int == 0
                {
                    return 0 as libc::c_int;
                }
                z = z.offset(1);
                while *(*__ctype_b_loc())
                    .offset(
                        *z.offset(0 as libc::c_int as isize) as libc::c_uchar
                            as libc::c_int as isize,
                    ) as libc::c_int
                    & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int != 0
                {
                    z = z.offset(1);
                }
            } else {
                let fresh410 = z;
                z = z.offset(1);
                if c != *fresh410 as libc::c_int {
                    return 0 as libc::c_int;
                }
            }
        }
    }
    while *(*__ctype_b_loc()).offset(*z as libc::c_uchar as libc::c_int as isize)
        as libc::c_int & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0
    {
        z = z.offset(1);
    }
    return (*z as libc::c_int == 0 as libc::c_int) as libc::c_int;
}
unsafe extern "C" fn optionMatch(
    mut zStr: *const libc::c_char,
    mut zOpt: *const libc::c_char,
) -> libc::c_int {
    if *zStr.offset(0 as libc::c_int as isize) as libc::c_int != '-' as i32 {
        return 0 as libc::c_int;
    }
    zStr = zStr.offset(1);
    if *zStr.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
        zStr = zStr.offset(1);
    }
    return (cli_strcmp(zStr, zOpt) == 0 as libc::c_int) as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn shellDeleteFile(
    mut zFilename: *const libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    rc = unlink(zFilename);
    return rc;
}
unsafe extern "C" fn clearTempFile(mut p: *mut ShellState) {
    if ((*p).zTempFile).is_null() {
        return;
    }
    if (*p).doXdgOpen != 0 {
        return;
    }
    if shellDeleteFile((*p).zTempFile) != 0 {
        return;
    }
    sqlite3_free((*p).zTempFile as *mut libc::c_void);
    let ref mut fresh411 = (*p).zTempFile;
    *fresh411 = 0 as *mut libc::c_char;
}
unsafe extern "C" fn newTempFile(
    mut p: *mut ShellState,
    mut zSuffix: *const libc::c_char,
) {
    clearTempFile(p);
    sqlite3_free((*p).zTempFile as *mut libc::c_void);
    let ref mut fresh412 = (*p).zTempFile;
    *fresh412 = 0 as *mut libc::c_char;
    if !((*p).db).is_null() {
        sqlite3_file_control(
            (*p).db,
            0 as *const libc::c_char,
            16 as libc::c_int,
            &mut (*p).zTempFile as *mut *mut libc::c_char as *mut libc::c_void,
        );
    }
    if ((*p).zTempFile).is_null() {
        let mut zTemp: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut r: sqlite3_uint64 = 0;
        sqlite3_randomness(
            ::std::mem::size_of::<sqlite3_uint64>() as libc::c_ulong as libc::c_int,
            &mut r as *mut sqlite3_uint64 as *mut libc::c_void,
        );
        zTemp = getenv(b"TEMP\0" as *const u8 as *const libc::c_char);
        if zTemp.is_null() {
            zTemp = getenv(b"TMP\0" as *const u8 as *const libc::c_char);
        }
        if zTemp.is_null() {
            zTemp = b"/tmp\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
        }
        let ref mut fresh413 = (*p).zTempFile;
        *fresh413 = sqlite3_mprintf(
            b"%s/temp%llx.%s\0" as *const u8 as *const libc::c_char,
            zTemp,
            r,
            zSuffix,
        );
    } else {
        let ref mut fresh414 = (*p).zTempFile;
        *fresh414 = sqlite3_mprintf(
            b"%z.%s\0" as *const u8 as *const libc::c_char,
            (*p).zTempFile,
            zSuffix,
        );
    }
    shell_check_oom((*p).zTempFile as *mut libc::c_void);
}
unsafe extern "C" fn shellFkeyCollateClause(
    mut pCtx: *mut sqlite3_context,
    mut nVal: libc::c_int,
    mut apVal: *mut *mut sqlite3_value,
) {
    let mut db: *mut sqlite3 = sqlite3_context_db_handle(pCtx);
    let mut zParent: *const libc::c_char = 0 as *const libc::c_char;
    let mut zParentCol: *const libc::c_char = 0 as *const libc::c_char;
    let mut zParentSeq: *const libc::c_char = 0 as *const libc::c_char;
    let mut zChild: *const libc::c_char = 0 as *const libc::c_char;
    let mut zChildCol: *const libc::c_char = 0 as *const libc::c_char;
    let mut zChildSeq: *const libc::c_char = 0 as *const libc::c_char;
    let mut rc: libc::c_int = 0;
    zParent = sqlite3_value_text(*apVal.offset(0 as libc::c_int as isize))
        as *const libc::c_char;
    zParentCol = sqlite3_value_text(*apVal.offset(1 as libc::c_int as isize))
        as *const libc::c_char;
    zChild = sqlite3_value_text(*apVal.offset(2 as libc::c_int as isize))
        as *const libc::c_char;
    zChildCol = sqlite3_value_text(*apVal.offset(3 as libc::c_int as isize))
        as *const libc::c_char;
    sqlite3_result_text(
        pCtx,
        b"\0" as *const u8 as *const libc::c_char,
        -(1 as libc::c_int),
        None,
    );
    rc = sqlite3_table_column_metadata(
        db,
        b"main\0" as *const u8 as *const libc::c_char,
        zParent,
        zParentCol,
        0 as *mut *const libc::c_char,
        &mut zParentSeq,
        0 as *mut libc::c_int,
        0 as *mut libc::c_int,
        0 as *mut libc::c_int,
    );
    if rc == 0 as libc::c_int {
        rc = sqlite3_table_column_metadata(
            db,
            b"main\0" as *const u8 as *const libc::c_char,
            zChild,
            zChildCol,
            0 as *mut *const libc::c_char,
            &mut zChildSeq,
            0 as *mut libc::c_int,
            0 as *mut libc::c_int,
            0 as *mut libc::c_int,
        );
    }
    if rc == 0 as libc::c_int && sqlite3_stricmp(zParentSeq, zChildSeq) != 0 {
        let mut z: *mut libc::c_char = sqlite3_mprintf(
            b" COLLATE %s\0" as *const u8 as *const libc::c_char,
            zParentSeq,
        );
        sqlite3_result_text(
            pCtx,
            z,
            -(1 as libc::c_int),
            ::std::mem::transmute::<
                libc::intptr_t,
                sqlite3_destructor_type,
            >(-(1 as libc::c_int) as libc::intptr_t),
        );
        sqlite3_free(z as *mut libc::c_void);
    }
}
unsafe extern "C" fn lintFkeyIndexes(
    mut pState: *mut ShellState,
    mut azArg: *mut *mut libc::c_char,
    mut nArg: libc::c_int,
) -> libc::c_int {
    let mut db: *mut sqlite3 = (*pState).db;
    let mut out: *mut FILE = (*pState).out;
    let mut bVerbose: libc::c_int = 0 as libc::c_int;
    let mut bGroupByParent: libc::c_int = 0 as libc::c_int;
    let mut i: libc::c_int = 0;
    let mut zIndent: *const libc::c_char = b"\0" as *const u8 as *const libc::c_char;
    let mut rc: libc::c_int = 0;
    let mut pSql: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut zSql: *const libc::c_char = b"SELECT      'EXPLAIN QUERY PLAN SELECT 1 FROM ' || quote(s.name) || ' WHERE '  || group_concat(quote(s.name) || '.' || quote(f.[from]) || '=?'   || fkey_collate_clause(       f.[table], COALESCE(f.[to], p.[name]), s.name, f.[from]),' AND '),      'SEARCH ' || s.name || ' USING COVERING INDEX*('  || group_concat('*=?', ' AND ') || ')',      s.name  || '(' || group_concat(f.[from],  ', ') || ')',      f.[table] || '(' || group_concat(COALESCE(f.[to], p.[name])) || ')',      'CREATE INDEX ' || quote(s.name ||'_'|| group_concat(f.[from], '_'))  || ' ON ' || quote(s.name) || '('  || group_concat(quote(f.[from]) ||        fkey_collate_clause(          f.[table], COALESCE(f.[to], p.[name]), s.name, f.[from]), ', ')  || ');',      f.[table] FROM sqlite_schema AS s, pragma_foreign_key_list(s.name) AS f LEFT JOIN pragma_table_info AS p ON (pk-1=seq AND p.arg=f.[table]) GROUP BY s.name, f.id ORDER BY (CASE WHEN ? THEN f.[table] ELSE s.name END)\0"
        as *const u8 as *const libc::c_char;
    let mut zGlobIPK: *const libc::c_char = b"SEARCH * USING INTEGER PRIMARY KEY (rowid=?)\0"
        as *const u8 as *const libc::c_char;
    i = 2 as libc::c_int;
    while i < nArg {
        let mut n: libc::c_int = strlen30(*azArg.offset(i as isize));
        if n > 1 as libc::c_int
            && sqlite3_strnicmp(
                b"-verbose\0" as *const u8 as *const libc::c_char,
                *azArg.offset(i as isize),
                n,
            ) == 0 as libc::c_int
        {
            bVerbose = 1 as libc::c_int;
        } else if n > 1 as libc::c_int
            && sqlite3_strnicmp(
                b"-groupbyparent\0" as *const u8 as *const libc::c_char,
                *azArg.offset(i as isize),
                n,
            ) == 0 as libc::c_int
        {
            bGroupByParent = 1 as libc::c_int;
            zIndent = b"    \0" as *const u8 as *const libc::c_char;
        } else {
            fprintf(
                stderr,
                b"Usage: %s %s ?-verbose? ?-groupbyparent?\n\0" as *const u8
                    as *const libc::c_char,
                *azArg.offset(0 as libc::c_int as isize),
                *azArg.offset(1 as libc::c_int as isize),
            );
            return 1 as libc::c_int;
        }
        i += 1;
    }
    rc = sqlite3_create_function(
        db,
        b"fkey_collate_clause\0" as *const u8 as *const libc::c_char,
        4 as libc::c_int,
        1 as libc::c_int,
        0 as *mut libc::c_void,
        Some(
            shellFkeyCollateClause
                as unsafe extern "C" fn(
                    *mut sqlite3_context,
                    libc::c_int,
                    *mut *mut sqlite3_value,
                ) -> (),
        ),
        None,
        None,
    );
    if rc == 0 as libc::c_int {
        rc = sqlite3_prepare_v2(
            db,
            zSql,
            -(1 as libc::c_int),
            &mut pSql,
            0 as *mut *const libc::c_char,
        );
    }
    if rc == 0 as libc::c_int {
        sqlite3_bind_int(pSql, 1 as libc::c_int, bGroupByParent);
    }
    if rc == 0 as libc::c_int {
        let mut rc2: libc::c_int = 0;
        let mut zPrev: *mut libc::c_char = 0 as *mut libc::c_char;
        while 100 as libc::c_int == sqlite3_step(pSql) {
            let mut res: libc::c_int = -(1 as libc::c_int);
            let mut pExplain: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
            let mut zEQP: *const libc::c_char = sqlite3_column_text(
                pSql,
                0 as libc::c_int,
            ) as *const libc::c_char;
            let mut zGlob: *const libc::c_char = sqlite3_column_text(
                pSql,
                1 as libc::c_int,
            ) as *const libc::c_char;
            let mut zFrom: *const libc::c_char = sqlite3_column_text(
                pSql,
                2 as libc::c_int,
            ) as *const libc::c_char;
            let mut zTarget: *const libc::c_char = sqlite3_column_text(
                pSql,
                3 as libc::c_int,
            ) as *const libc::c_char;
            let mut zCI: *const libc::c_char = sqlite3_column_text(
                pSql,
                4 as libc::c_int,
            ) as *const libc::c_char;
            let mut zParent: *const libc::c_char = sqlite3_column_text(
                pSql,
                5 as libc::c_int,
            ) as *const libc::c_char;
            if zEQP.is_null() {
                continue;
            }
            if zGlob.is_null() {
                continue;
            }
            rc = sqlite3_prepare_v2(
                db,
                zEQP,
                -(1 as libc::c_int),
                &mut pExplain,
                0 as *mut *const libc::c_char,
            );
            if rc != 0 as libc::c_int {
                break;
            }
            if 100 as libc::c_int == sqlite3_step(pExplain) {
                let mut zPlan: *const libc::c_char = sqlite3_column_text(
                    pExplain,
                    3 as libc::c_int,
                ) as *const libc::c_char;
                res = (!zPlan.is_null()
                    && (0 as libc::c_int == sqlite3_strglob(zGlob, zPlan)
                        || 0 as libc::c_int == sqlite3_strglob(zGlobIPK, zPlan)))
                    as libc::c_int;
            }
            rc = sqlite3_finalize(pExplain);
            if rc != 0 as libc::c_int {
                break;
            }
            if res < 0 as libc::c_int {
                fprintf(
                    stderr,
                    b"Error: internal error\0" as *const u8 as *const libc::c_char,
                );
                break;
            } else {
                if bGroupByParent != 0 && (bVerbose != 0 || res == 0 as libc::c_int)
                    && (zPrev.is_null() || sqlite3_stricmp(zParent, zPrev) != 0)
                {
                    fprintf(
                        out,
                        b"-- Parent table %s\n\0" as *const u8 as *const libc::c_char,
                        zParent,
                    );
                    sqlite3_free(zPrev as *mut libc::c_void);
                    zPrev = sqlite3_mprintf(
                        b"%s\0" as *const u8 as *const libc::c_char,
                        zParent,
                    );
                }
                if res == 0 as libc::c_int {
                    fprintf(
                        out,
                        b"%s%s --> %s\n\0" as *const u8 as *const libc::c_char,
                        zIndent,
                        zCI,
                        zTarget,
                    );
                } else if bVerbose != 0 {
                    fprintf(
                        out,
                        b"%s/* no extra indexes required for %s -> %s */\n\0"
                            as *const u8 as *const libc::c_char,
                        zIndent,
                        zFrom,
                        zTarget,
                    );
                }
            }
        }
        sqlite3_free(zPrev as *mut libc::c_void);
        if rc != 0 as libc::c_int {
            fprintf(
                stderr,
                b"%s\n\0" as *const u8 as *const libc::c_char,
                sqlite3_errmsg(db),
            );
        }
        rc2 = sqlite3_finalize(pSql);
        if rc == 0 as libc::c_int && rc2 != 0 as libc::c_int {
            rc = rc2;
            fprintf(
                stderr,
                b"%s\n\0" as *const u8 as *const libc::c_char,
                sqlite3_errmsg(db),
            );
        }
    } else {
        fprintf(
            stderr,
            b"%s\n\0" as *const u8 as *const libc::c_char,
            sqlite3_errmsg(db),
        );
    }
    return rc;
}
unsafe extern "C" fn lintDotCommand(
    mut pState: *mut ShellState,
    mut azArg: *mut *mut libc::c_char,
    mut nArg: libc::c_int,
) -> libc::c_int {
    let mut n: libc::c_int = 0;
    n = if nArg >= 2 as libc::c_int {
        strlen30(*azArg.offset(1 as libc::c_int as isize))
    } else {
        0 as libc::c_int
    };
    if n < 1 as libc::c_int
        || sqlite3_strnicmp(
            *azArg.offset(1 as libc::c_int as isize),
            b"fkey-indexes\0" as *const u8 as *const libc::c_char,
            n,
        ) != 0
    {
        fprintf(
            stderr,
            b"Usage %s sub-command ?switches...?\n\0" as *const u8
                as *const libc::c_char,
            *azArg.offset(0 as libc::c_int as isize),
        );
        fprintf(
            stderr,
            b"Where sub-commands are:\n\0" as *const u8 as *const libc::c_char,
        );
        fprintf(stderr, b"    fkey-indexes\n\0" as *const u8 as *const libc::c_char);
        return 1 as libc::c_int;
    } else {
        return lintFkeyIndexes(pState, azArg, nArg)
    };
}
unsafe extern "C" fn shellPrepare(
    mut db: *mut sqlite3,
    mut pRc: *mut libc::c_int,
    mut zSql: *const libc::c_char,
    mut ppStmt: *mut *mut sqlite3_stmt,
) {
    *ppStmt = 0 as *mut sqlite3_stmt;
    if *pRc == 0 as libc::c_int {
        let mut rc: libc::c_int = sqlite3_prepare_v2(
            db,
            zSql,
            -(1 as libc::c_int),
            ppStmt,
            0 as *mut *const libc::c_char,
        );
        if rc != 0 as libc::c_int {
            fprintf(
                stderr,
                b"sql error: %s (%d)\n\0" as *const u8 as *const libc::c_char,
                sqlite3_errmsg(db),
                sqlite3_errcode(db),
            );
            *pRc = rc;
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn shellPreparePrintf(
    mut db: *mut sqlite3,
    mut pRc: *mut libc::c_int,
    mut ppStmt: *mut *mut sqlite3_stmt,
    mut zFmt: *const libc::c_char,
    mut args: ...
) {
    *ppStmt = 0 as *mut sqlite3_stmt;
    if *pRc == 0 as libc::c_int {
        let mut ap: ::std::ffi::VaListImpl;
        let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
        ap = args.clone();
        z = sqlite3_vmprintf(zFmt, ap.as_va_list());
        if z.is_null() {
            *pRc = 7 as libc::c_int;
        } else {
            shellPrepare(db, pRc, z, ppStmt);
            sqlite3_free(z as *mut libc::c_void);
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn shellFinalize(
    mut pRc: *mut libc::c_int,
    mut pStmt: *mut sqlite3_stmt,
) {
    if !pStmt.is_null() {
        let mut db: *mut sqlite3 = sqlite3_db_handle(pStmt);
        let mut rc: libc::c_int = sqlite3_finalize(pStmt);
        if *pRc == 0 as libc::c_int {
            if rc != 0 as libc::c_int {
                fprintf(
                    stderr,
                    b"SQL error: %s\n\0" as *const u8 as *const libc::c_char,
                    sqlite3_errmsg(db),
                );
            }
            *pRc = rc;
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn shellReset(
    mut pRc: *mut libc::c_int,
    mut pStmt: *mut sqlite3_stmt,
) {
    let mut rc: libc::c_int = sqlite3_reset(pStmt);
    if *pRc == 0 as libc::c_int {
        if rc != 0 as libc::c_int {
            let mut db: *mut sqlite3 = sqlite3_db_handle(pStmt);
            fprintf(
                stderr,
                b"SQL error: %s\n\0" as *const u8 as *const libc::c_char,
                sqlite3_errmsg(db),
            );
        }
        *pRc = rc;
    }
}
unsafe extern "C" fn arUsage(mut f: *mut FILE) -> libc::c_int {
    showHelp(f, b"archive\0" as *const u8 as *const libc::c_char);
    return 1 as libc::c_int;
}
unsafe extern "C" fn arErrorMsg(
    mut pAr: *mut ArCommand,
    mut zFmt: *const libc::c_char,
    mut args: ...
) -> libc::c_int {
    let mut ap: ::std::ffi::VaListImpl;
    let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
    ap = args.clone();
    z = sqlite3_vmprintf(zFmt, ap.as_va_list());
    fprintf(stderr, b"Error: %s\n\0" as *const u8 as *const libc::c_char, z);
    if (*pAr).fromCmdLine != 0 {
        fprintf(
            stderr,
            b"Use \"-A\" for more help\n\0" as *const u8 as *const libc::c_char,
        );
    } else {
        fprintf(
            stderr,
            b"Use \".archive --help\" for more help\n\0" as *const u8
                as *const libc::c_char,
        );
    }
    sqlite3_free(z as *mut libc::c_void);
    return 1 as libc::c_int;
}
unsafe extern "C" fn arProcessSwitch(
    mut pAr: *mut ArCommand,
    mut eSwitch: libc::c_int,
    mut zArg: *const libc::c_char,
) -> libc::c_int {
    let mut current_block_9: u64;
    match eSwitch {
        1 | 4 | 5 | 7 | 2 | 3 | 6 => {
            if (*pAr).eCmd != 0 {
                return arErrorMsg(
                    pAr,
                    b"multiple command options\0" as *const u8 as *const libc::c_char,
                );
            }
            (*pAr).eCmd = eSwitch as u8_0;
            current_block_9 = 7149356873433890176;
        }
        12 => {
            (*pAr).bDryRun = 1 as libc::c_int as u8_0;
            current_block_9 = 7149356873433890176;
        }
        13 => {
            (*pAr).bGlob = 1 as libc::c_int as u8_0;
            current_block_9 = 7149356873433890176;
        }
        8 => {
            (*pAr).bVerbose = 1 as libc::c_int as u8_0;
            current_block_9 = 7149356873433890176;
        }
        11 => {
            (*pAr).bAppend = 1 as libc::c_int as u8_0;
            current_block_9 = 8728614136593692817;
        }
        9 => {
            current_block_9 = 8728614136593692817;
        }
        10 => {
            let ref mut fresh416 = (*pAr).zDir;
            *fresh416 = zArg;
            current_block_9 = 7149356873433890176;
        }
        _ => {
            current_block_9 = 7149356873433890176;
        }
    }
    match current_block_9 {
        8728614136593692817 => {
            let ref mut fresh415 = (*pAr).zFile;
            *fresh415 = zArg;
        }
        _ => {}
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn arParseCommand(
    mut azArg: *mut *mut libc::c_char,
    mut nArg: libc::c_int,
    mut pAr: *mut ArCommand,
) -> libc::c_int {
    let mut aSwitch: [ArSwitch; 13] = [
        {
            let mut init = ArSwitch {
                zLong: b"create\0" as *const u8 as *const libc::c_char,
                cShort: 'c' as i32 as libc::c_char,
                eSwitch: 1 as libc::c_int as u8_0,
                bArg: 0 as libc::c_int as u8_0,
            };
            init
        },
        {
            let mut init = ArSwitch {
                zLong: b"extract\0" as *const u8 as *const libc::c_char,
                cShort: 'x' as i32 as libc::c_char,
                eSwitch: 4 as libc::c_int as u8_0,
                bArg: 0 as libc::c_int as u8_0,
            };
            init
        },
        {
            let mut init = ArSwitch {
                zLong: b"insert\0" as *const u8 as *const libc::c_char,
                cShort: 'i' as i32 as libc::c_char,
                eSwitch: 3 as libc::c_int as u8_0,
                bArg: 0 as libc::c_int as u8_0,
            };
            init
        },
        {
            let mut init = ArSwitch {
                zLong: b"list\0" as *const u8 as *const libc::c_char,
                cShort: 't' as i32 as libc::c_char,
                eSwitch: 5 as libc::c_int as u8_0,
                bArg: 0 as libc::c_int as u8_0,
            };
            init
        },
        {
            let mut init = ArSwitch {
                zLong: b"remove\0" as *const u8 as *const libc::c_char,
                cShort: 'r' as i32 as libc::c_char,
                eSwitch: 7 as libc::c_int as u8_0,
                bArg: 0 as libc::c_int as u8_0,
            };
            init
        },
        {
            let mut init = ArSwitch {
                zLong: b"update\0" as *const u8 as *const libc::c_char,
                cShort: 'u' as i32 as libc::c_char,
                eSwitch: 2 as libc::c_int as u8_0,
                bArg: 0 as libc::c_int as u8_0,
            };
            init
        },
        {
            let mut init = ArSwitch {
                zLong: b"help\0" as *const u8 as *const libc::c_char,
                cShort: 'h' as i32 as libc::c_char,
                eSwitch: 6 as libc::c_int as u8_0,
                bArg: 0 as libc::c_int as u8_0,
            };
            init
        },
        {
            let mut init = ArSwitch {
                zLong: b"verbose\0" as *const u8 as *const libc::c_char,
                cShort: 'v' as i32 as libc::c_char,
                eSwitch: 8 as libc::c_int as u8_0,
                bArg: 0 as libc::c_int as u8_0,
            };
            init
        },
        {
            let mut init = ArSwitch {
                zLong: b"file\0" as *const u8 as *const libc::c_char,
                cShort: 'f' as i32 as libc::c_char,
                eSwitch: 9 as libc::c_int as u8_0,
                bArg: 1 as libc::c_int as u8_0,
            };
            init
        },
        {
            let mut init = ArSwitch {
                zLong: b"append\0" as *const u8 as *const libc::c_char,
                cShort: 'a' as i32 as libc::c_char,
                eSwitch: 11 as libc::c_int as u8_0,
                bArg: 1 as libc::c_int as u8_0,
            };
            init
        },
        {
            let mut init = ArSwitch {
                zLong: b"directory\0" as *const u8 as *const libc::c_char,
                cShort: 'C' as i32 as libc::c_char,
                eSwitch: 10 as libc::c_int as u8_0,
                bArg: 1 as libc::c_int as u8_0,
            };
            init
        },
        {
            let mut init = ArSwitch {
                zLong: b"dryrun\0" as *const u8 as *const libc::c_char,
                cShort: 'n' as i32 as libc::c_char,
                eSwitch: 12 as libc::c_int as u8_0,
                bArg: 0 as libc::c_int as u8_0,
            };
            init
        },
        {
            let mut init = ArSwitch {
                zLong: b"glob\0" as *const u8 as *const libc::c_char,
                cShort: 'g' as i32 as libc::c_char,
                eSwitch: 13 as libc::c_int as u8_0,
                bArg: 0 as libc::c_int as u8_0,
            };
            init
        },
    ];
    let mut nSwitch: libc::c_int = (::std::mem::size_of::<[ArSwitch; 13]>()
        as libc::c_ulong)
        .wrapping_div(::std::mem::size_of::<ArSwitch>() as libc::c_ulong) as libc::c_int;
    let mut pEnd: *mut ArSwitch = &mut *aSwitch.as_mut_ptr().offset(nSwitch as isize)
        as *mut ArSwitch;
    if nArg <= 1 as libc::c_int {
        fprintf(
            stderr,
            b"Wrong number of arguments.  Usage:\n\0" as *const u8 as *const libc::c_char,
        );
        return arUsage(stderr);
    } else {
        let mut z: *mut libc::c_char = *azArg.offset(1 as libc::c_int as isize);
        if *z.offset(0 as libc::c_int as isize) as libc::c_int != '-' as i32 {
            let mut i: libc::c_int = 0;
            let mut iArg: libc::c_int = 2 as libc::c_int;
            i = 0 as libc::c_int;
            while *z.offset(i as isize) != 0 {
                let mut zArg: *const libc::c_char = 0 as *const libc::c_char;
                let mut pOpt: *mut ArSwitch = 0 as *mut ArSwitch;
                pOpt = &mut *aSwitch.as_mut_ptr().offset(0 as libc::c_int as isize)
                    as *mut ArSwitch;
                while pOpt < pEnd {
                    if *z.offset(i as isize) as libc::c_int
                        == (*pOpt).cShort as libc::c_int
                    {
                        break;
                    }
                    pOpt = pOpt.offset(1);
                }
                if pOpt == pEnd {
                    return arErrorMsg(
                        pAr,
                        b"unrecognized option: %c\0" as *const u8 as *const libc::c_char,
                        *z.offset(i as isize) as libc::c_int,
                    );
                }
                if (*pOpt).bArg != 0 {
                    if iArg >= nArg {
                        return arErrorMsg(
                            pAr,
                            b"option requires an argument: %c\0" as *const u8
                                as *const libc::c_char,
                            *z.offset(i as isize) as libc::c_int,
                        );
                    }
                    let fresh417 = iArg;
                    iArg = iArg + 1;
                    zArg = *azArg.offset(fresh417 as isize);
                }
                if arProcessSwitch(pAr, (*pOpt).eSwitch as libc::c_int, zArg) != 0 {
                    return 1 as libc::c_int;
                }
                i += 1;
            }
            (*pAr).nArg = nArg - iArg;
            if (*pAr).nArg > 0 as libc::c_int {
                let ref mut fresh418 = (*pAr).azArg;
                *fresh418 = &mut *azArg.offset(iArg as isize) as *mut *mut libc::c_char;
            }
        } else {
            let mut iArg_0: libc::c_int = 0;
            iArg_0 = 1 as libc::c_int;
            while iArg_0 < nArg {
                let mut n: libc::c_int = 0;
                z = *azArg.offset(iArg_0 as isize);
                if *z.offset(0 as libc::c_int as isize) as libc::c_int != '-' as i32 {
                    let ref mut fresh419 = (*pAr).azArg;
                    *fresh419 = &mut *azArg.offset(iArg_0 as isize)
                        as *mut *mut libc::c_char;
                    (*pAr).nArg = nArg - iArg_0;
                    break;
                } else {
                    n = strlen30(z);
                    if *z.offset(1 as libc::c_int as isize) as libc::c_int != '-' as i32
                    {
                        let mut i_0: libc::c_int = 0;
                        i_0 = 1 as libc::c_int;
                        while i_0 < n {
                            let mut zArg_0: *const libc::c_char = 0
                                as *const libc::c_char;
                            let mut pOpt_0: *mut ArSwitch = 0 as *mut ArSwitch;
                            pOpt_0 = &mut *aSwitch
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize) as *mut ArSwitch;
                            while pOpt_0 < pEnd {
                                if *z.offset(i_0 as isize) as libc::c_int
                                    == (*pOpt_0).cShort as libc::c_int
                                {
                                    break;
                                }
                                pOpt_0 = pOpt_0.offset(1);
                            }
                            if pOpt_0 == pEnd {
                                return arErrorMsg(
                                    pAr,
                                    b"unrecognized option: %c\0" as *const u8
                                        as *const libc::c_char,
                                    *z.offset(i_0 as isize) as libc::c_int,
                                );
                            }
                            if (*pOpt_0).bArg != 0 {
                                if i_0 < n - 1 as libc::c_int {
                                    zArg_0 = &mut *z.offset((i_0 + 1 as libc::c_int) as isize)
                                        as *mut libc::c_char;
                                    i_0 = n;
                                } else {
                                    if iArg_0 >= nArg - 1 as libc::c_int {
                                        return arErrorMsg(
                                            pAr,
                                            b"option requires an argument: %c\0" as *const u8
                                                as *const libc::c_char,
                                            *z.offset(i_0 as isize) as libc::c_int,
                                        );
                                    }
                                    iArg_0 += 1;
                                    zArg_0 = *azArg.offset(iArg_0 as isize);
                                }
                            }
                            if arProcessSwitch(
                                pAr,
                                (*pOpt_0).eSwitch as libc::c_int,
                                zArg_0,
                            ) != 0
                            {
                                return 1 as libc::c_int;
                            }
                            i_0 += 1;
                        }
                    } else if *z.offset(2 as libc::c_int as isize) as libc::c_int
                        == '\0' as i32
                    {
                        let ref mut fresh420 = (*pAr).azArg;
                        *fresh420 = &mut *azArg
                            .offset((iArg_0 + 1 as libc::c_int) as isize)
                            as *mut *mut libc::c_char;
                        (*pAr).nArg = nArg - iArg_0 - 1 as libc::c_int;
                        break;
                    } else {
                        let mut zArg_1: *const libc::c_char = 0 as *const libc::c_char;
                        let mut pMatch: *mut ArSwitch = 0 as *mut ArSwitch;
                        let mut pOpt_1: *mut ArSwitch = 0 as *mut ArSwitch;
                        pOpt_1 = &mut *aSwitch
                            .as_mut_ptr()
                            .offset(0 as libc::c_int as isize) as *mut ArSwitch;
                        while pOpt_1 < pEnd {
                            let mut zLong: *const libc::c_char = (*pOpt_1).zLong;
                            if n - 2 as libc::c_int <= strlen30(zLong)
                                && 0 as libc::c_int
                                    == memcmp(
                                        &mut *z.offset(2 as libc::c_int as isize)
                                            as *mut libc::c_char as *const libc::c_void,
                                        zLong as *const libc::c_void,
                                        (n - 2 as libc::c_int) as libc::c_ulong,
                                    )
                            {
                                if !pMatch.is_null() {
                                    return arErrorMsg(
                                        pAr,
                                        b"ambiguous option: %s\0" as *const u8
                                            as *const libc::c_char,
                                        z,
                                    )
                                } else {
                                    pMatch = pOpt_1;
                                }
                            }
                            pOpt_1 = pOpt_1.offset(1);
                        }
                        if pMatch.is_null() {
                            return arErrorMsg(
                                pAr,
                                b"unrecognized option: %s\0" as *const u8
                                    as *const libc::c_char,
                                z,
                            );
                        }
                        if (*pMatch).bArg != 0 {
                            if iArg_0 >= nArg - 1 as libc::c_int {
                                return arErrorMsg(
                                    pAr,
                                    b"option requires an argument: %s\0" as *const u8
                                        as *const libc::c_char,
                                    z,
                                );
                            }
                            iArg_0 += 1;
                            zArg_1 = *azArg.offset(iArg_0 as isize);
                        }
                        if arProcessSwitch(pAr, (*pMatch).eSwitch as libc::c_int, zArg_1)
                            != 0
                        {
                            return 1 as libc::c_int;
                        }
                    }
                    iArg_0 += 1;
                }
            }
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn arCheckEntries(mut pAr: *mut ArCommand) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (*pAr).nArg != 0 {
        let mut i: libc::c_int = 0;
        let mut j: libc::c_int = 0;
        let mut pTest: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        let mut zSel: *const libc::c_char = if (*pAr).bGlob as libc::c_int != 0 {
            b"SELECT name FROM %s WHERE glob($name,name)\0" as *const u8
                as *const libc::c_char
        } else {
            b"SELECT name FROM %s WHERE name=$name\0" as *const u8 as *const libc::c_char
        };
        shellPreparePrintf(
            (*pAr).db,
            &mut rc as *mut libc::c_int,
            &mut pTest as *mut *mut sqlite3_stmt,
            zSel,
            (*pAr).zSrcTable,
        );
        j = sqlite3_bind_parameter_index(
            pTest,
            b"$name\0" as *const u8 as *const libc::c_char,
        );
        i = 0 as libc::c_int;
        while i < (*pAr).nArg && rc == 0 as libc::c_int {
            let mut z: *mut libc::c_char = *((*pAr).azArg).offset(i as isize);
            let mut n: libc::c_int = strlen30(z);
            let mut bOk: libc::c_int = 0 as libc::c_int;
            while n > 0 as libc::c_int
                && *z.offset((n - 1 as libc::c_int) as isize) as libc::c_int
                    == '/' as i32
            {
                n -= 1;
            }
            *z.offset(n as isize) = '\0' as i32 as libc::c_char;
            sqlite3_bind_text(pTest, j, z, -(1 as libc::c_int), None);
            if 100 as libc::c_int == sqlite3_step(pTest) {
                bOk = 1 as libc::c_int;
            }
            shellReset(&mut rc, pTest);
            if rc == 0 as libc::c_int && bOk == 0 as libc::c_int {
                fprintf(
                    stderr,
                    b"not found in archive: %s\n\0" as *const u8 as *const libc::c_char,
                    z,
                );
                rc = 1 as libc::c_int;
            }
            i += 1;
        }
        shellFinalize(&mut rc, pTest);
    }
    return rc;
}
unsafe extern "C" fn arWhereClause(
    mut pRc: *mut libc::c_int,
    mut pAr: *mut ArCommand,
    mut pzWhere: *mut *mut libc::c_char,
) {
    let mut zWhere: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zSameOp: *const libc::c_char = if (*pAr).bGlob as libc::c_int != 0 {
        b"GLOB\0" as *const u8 as *const libc::c_char
    } else {
        b"=\0" as *const u8 as *const libc::c_char
    };
    if *pRc == 0 as libc::c_int {
        if (*pAr).nArg == 0 as libc::c_int {
            zWhere = sqlite3_mprintf(b"1\0" as *const u8 as *const libc::c_char);
        } else {
            let mut i: libc::c_int = 0;
            let mut zSep: *const libc::c_char = b"\0" as *const u8
                as *const libc::c_char;
            i = 0 as libc::c_int;
            while i < (*pAr).nArg {
                let mut z: *const libc::c_char = *((*pAr).azArg).offset(i as isize);
                zWhere = sqlite3_mprintf(
                    b"%z%s name %s '%q' OR substr(name,1,%d) %s '%q/'\0" as *const u8
                        as *const libc::c_char,
                    zWhere,
                    zSep,
                    zSameOp,
                    z,
                    strlen30(z) + 1 as libc::c_int,
                    zSameOp,
                    z,
                );
                if zWhere.is_null() {
                    *pRc = 7 as libc::c_int;
                    break;
                } else {
                    zSep = b" OR \0" as *const u8 as *const libc::c_char;
                    i += 1;
                }
            }
        }
    }
    *pzWhere = zWhere;
}
unsafe extern "C" fn arListCommand(mut pAr: *mut ArCommand) -> libc::c_int {
    let mut zSql: *const libc::c_char = b"SELECT %s FROM %s WHERE %s\0" as *const u8
        as *const libc::c_char;
    let mut azCols: [*const libc::c_char; 2] = [
        b"name\0" as *const u8 as *const libc::c_char,
        b"lsmode(mode), sz, datetime(mtime, 'unixepoch'), name\0" as *const u8
            as *const libc::c_char,
    ];
    let mut zWhere: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut pSql: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut rc: libc::c_int = 0;
    rc = arCheckEntries(pAr);
    arWhereClause(&mut rc, pAr, &mut zWhere);
    shellPreparePrintf(
        (*pAr).db,
        &mut rc as *mut libc::c_int,
        &mut pSql as *mut *mut sqlite3_stmt,
        zSql,
        azCols[(*pAr).bVerbose as usize],
        (*pAr).zSrcTable,
        zWhere,
    );
    if (*pAr).bDryRun != 0 {
        fprintf(
            (*(*pAr).p).out,
            b"%s\n\0" as *const u8 as *const libc::c_char,
            sqlite3_sql(pSql),
        );
    } else {
        while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pSql) {
            if (*pAr).bVerbose != 0 {
                fprintf(
                    (*(*pAr).p).out,
                    b"%s % 10d  %s  %s\n\0" as *const u8 as *const libc::c_char,
                    sqlite3_column_text(pSql, 0 as libc::c_int),
                    sqlite3_column_int(pSql, 1 as libc::c_int),
                    sqlite3_column_text(pSql, 2 as libc::c_int),
                    sqlite3_column_text(pSql, 3 as libc::c_int),
                );
            } else {
                fprintf(
                    (*(*pAr).p).out,
                    b"%s\n\0" as *const u8 as *const libc::c_char,
                    sqlite3_column_text(pSql, 0 as libc::c_int),
                );
            }
        }
    }
    shellFinalize(&mut rc, pSql);
    sqlite3_free(zWhere as *mut libc::c_void);
    return rc;
}
unsafe extern "C" fn arRemoveCommand(mut pAr: *mut ArCommand) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zWhere: *mut libc::c_char = 0 as *mut libc::c_char;
    if (*pAr).nArg != 0 {
        rc = arCheckEntries(pAr);
        arWhereClause(&mut rc, pAr, &mut zWhere);
    }
    if rc == 0 as libc::c_int {
        zSql = sqlite3_mprintf(
            b"DELETE FROM %s WHERE %s;\0" as *const u8 as *const libc::c_char,
            (*pAr).zSrcTable,
            zWhere,
        );
        if (*pAr).bDryRun != 0 {
            fprintf(
                (*(*pAr).p).out,
                b"%s\n\0" as *const u8 as *const libc::c_char,
                zSql,
            );
        } else {
            let mut zErr: *mut libc::c_char = 0 as *mut libc::c_char;
            rc = sqlite3_exec(
                (*pAr).db,
                b"SAVEPOINT ar;\0" as *const u8 as *const libc::c_char,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
            if rc == 0 as libc::c_int {
                rc = sqlite3_exec(
                    (*pAr).db,
                    zSql,
                    None,
                    0 as *mut libc::c_void,
                    &mut zErr,
                );
                if rc != 0 as libc::c_int {
                    sqlite3_exec(
                        (*pAr).db,
                        b"ROLLBACK TO ar; RELEASE ar;\0" as *const u8
                            as *const libc::c_char,
                        None,
                        0 as *mut libc::c_void,
                        0 as *mut *mut libc::c_char,
                    );
                } else {
                    rc = sqlite3_exec(
                        (*pAr).db,
                        b"RELEASE ar;\0" as *const u8 as *const libc::c_char,
                        None,
                        0 as *mut libc::c_void,
                        0 as *mut *mut libc::c_char,
                    );
                }
            }
            if !zErr.is_null() {
                fprintf(
                    stdout,
                    b"ERROR: %s\n\0" as *const u8 as *const libc::c_char,
                    zErr,
                );
                sqlite3_free(zErr as *mut libc::c_void);
            }
        }
    }
    sqlite3_free(zWhere as *mut libc::c_void);
    sqlite3_free(zSql as *mut libc::c_void);
    return rc;
}
unsafe extern "C" fn arExtractCommand(mut pAr: *mut ArCommand) -> libc::c_int {
    let mut zSql1: *const libc::c_char = b"SELECT  ($dir || name), writefile(($dir || name), %s, mode, mtime) FROM %s WHERE (%s) AND (data IS NULL OR $dirOnly = 0) AND name NOT GLOB '*..[/\\]*'\0"
        as *const u8 as *const libc::c_char;
    let mut azExtraArg: [*const libc::c_char; 2] = [
        b"sqlar_uncompress(data, sz)\0" as *const u8 as *const libc::c_char,
        b"data\0" as *const u8 as *const libc::c_char,
    ];
    let mut pSql: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut zDir: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zWhere: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    rc = arCheckEntries(pAr);
    arWhereClause(&mut rc, pAr, &mut zWhere);
    if rc == 0 as libc::c_int {
        if !((*pAr).zDir).is_null() {
            zDir = sqlite3_mprintf(
                b"%s/\0" as *const u8 as *const libc::c_char,
                (*pAr).zDir,
            );
        } else {
            zDir = sqlite3_mprintf(b"\0" as *const u8 as *const libc::c_char);
        }
        if zDir.is_null() {
            rc = 7 as libc::c_int;
        }
    }
    shellPreparePrintf(
        (*pAr).db,
        &mut rc as *mut libc::c_int,
        &mut pSql as *mut *mut sqlite3_stmt,
        zSql1,
        azExtraArg[(*pAr).bZip as usize],
        (*pAr).zSrcTable,
        zWhere,
    );
    if rc == 0 as libc::c_int {
        j = sqlite3_bind_parameter_index(
            pSql,
            b"$dir\0" as *const u8 as *const libc::c_char,
        );
        sqlite3_bind_text(pSql, j, zDir, -(1 as libc::c_int), None);
        i = 0 as libc::c_int;
        while i < 2 as libc::c_int {
            j = sqlite3_bind_parameter_index(
                pSql,
                b"$dirOnly\0" as *const u8 as *const libc::c_char,
            );
            sqlite3_bind_int(pSql, j, i);
            if (*pAr).bDryRun != 0 {
                fprintf(
                    (*(*pAr).p).out,
                    b"%s\n\0" as *const u8 as *const libc::c_char,
                    sqlite3_sql(pSql),
                );
            } else {
                while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pSql)
                {
                    if i == 0 as libc::c_int && (*pAr).bVerbose as libc::c_int != 0 {
                        fprintf(
                            (*(*pAr).p).out,
                            b"%s\n\0" as *const u8 as *const libc::c_char,
                            sqlite3_column_text(pSql, 0 as libc::c_int),
                        );
                    }
                }
            }
            shellReset(&mut rc, pSql);
            i += 1;
        }
        shellFinalize(&mut rc, pSql);
    }
    sqlite3_free(zDir as *mut libc::c_void);
    sqlite3_free(zWhere as *mut libc::c_void);
    return rc;
}
unsafe extern "C" fn arExecSql(
    mut pAr: *mut ArCommand,
    mut zSql: *const libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    if (*pAr).bDryRun != 0 {
        fprintf((*(*pAr).p).out, b"%s\n\0" as *const u8 as *const libc::c_char, zSql);
        rc = 0 as libc::c_int;
    } else {
        let mut zErr: *mut libc::c_char = 0 as *mut libc::c_char;
        rc = sqlite3_exec((*pAr).db, zSql, None, 0 as *mut libc::c_void, &mut zErr);
        if !zErr.is_null() {
            fprintf(stdout, b"ERROR: %s\n\0" as *const u8 as *const libc::c_char, zErr);
            sqlite3_free(zErr as *mut libc::c_void);
        }
    }
    return rc;
}
unsafe extern "C" fn arCreateOrUpdateCommand(
    mut pAr: *mut ArCommand,
    mut bUpdate: libc::c_int,
    mut bOnlyIfChanged: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut zCreate: *const libc::c_char = b"CREATE TABLE IF NOT EXISTS sqlar(\n  name TEXT PRIMARY KEY,  -- name of the file\n  mode INT,               -- access permissions\n  mtime INT,              -- last modification time\n  sz INT,                 -- original file size\n  data BLOB               -- compressed content\n)\0"
        as *const u8 as *const libc::c_char;
    let mut zDrop: *const libc::c_char = b"DROP TABLE IF EXISTS sqlar\0" as *const u8
        as *const libc::c_char;
    let mut zInsertFmt: [*const libc::c_char; 2] = [
        b"REPLACE INTO %s(name,mode,mtime,sz,data)\n  SELECT\n    %s,\n    mode,\n    mtime,\n    CASE substr(lsmode(mode),1,1)\n      WHEN '-' THEN length(data)\n      WHEN 'd' THEN 0\n      ELSE -1 END,\n    sqlar_compress(data)\n  FROM fsdir(%Q,%Q) AS disk\n  WHERE lsmode(mode) NOT LIKE '?%%'%s;\0"
            as *const u8 as *const libc::c_char,
        b"REPLACE INTO %s(name,mode,mtime,data)\n  SELECT\n    %s,\n    mode,\n    mtime,\n    data\n  FROM fsdir(%Q,%Q) AS disk\n  WHERE lsmode(mode) NOT LIKE '?%%'%s;\0"
            as *const u8 as *const libc::c_char,
    ];
    let mut i: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    let mut zTab: *const libc::c_char = 0 as *const libc::c_char;
    let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zTemp: [libc::c_char; 50] = [0; 50];
    let mut zExists: *mut libc::c_char = 0 as *mut libc::c_char;
    arExecSql(pAr, b"PRAGMA page_size=512\0" as *const u8 as *const libc::c_char);
    rc = arExecSql(pAr, b"SAVEPOINT ar;\0" as *const u8 as *const libc::c_char);
    if rc != 0 as libc::c_int {
        return rc;
    }
    zTemp[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    if (*pAr).bZip != 0 {
        if !((*pAr).zFile).is_null() {
            let mut r: sqlite3_uint64 = 0;
            sqlite3_randomness(
                ::std::mem::size_of::<sqlite3_uint64>() as libc::c_ulong as libc::c_int,
                &mut r as *mut sqlite3_uint64 as *mut libc::c_void,
            );
            sqlite3_snprintf(
                ::std::mem::size_of::<[libc::c_char; 50]>() as libc::c_ulong
                    as libc::c_int,
                zTemp.as_mut_ptr(),
                b"zip%016llx\0" as *const u8 as *const libc::c_char,
                r,
            );
            zTab = zTemp.as_mut_ptr();
            zSql = sqlite3_mprintf(
                b"CREATE VIRTUAL TABLE temp.%s USING zipfile(%Q)\0" as *const u8
                    as *const libc::c_char,
                zTab,
                (*pAr).zFile,
            );
            rc = arExecSql(pAr, zSql);
            sqlite3_free(zSql as *mut libc::c_void);
        } else {
            zTab = b"zip\0" as *const u8 as *const libc::c_char;
        }
        current_block = 2232869372362427478;
    } else {
        zTab = b"sqlar\0" as *const u8 as *const libc::c_char;
        if bUpdate == 0 as libc::c_int {
            rc = arExecSql(pAr, zDrop);
            if rc != 0 as libc::c_int {
                current_block = 12465208156071891550;
            } else {
                current_block = 17478428563724192186;
            }
        } else {
            current_block = 17478428563724192186;
        }
        match current_block {
            12465208156071891550 => {}
            _ => {
                rc = arExecSql(pAr, zCreate);
                current_block = 2232869372362427478;
            }
        }
    }
    match current_block {
        2232869372362427478 => {
            if bOnlyIfChanged != 0 {
                zExists = sqlite3_mprintf(
                    b" AND NOT EXISTS(SELECT 1 FROM %s AS mem WHERE mem.name=disk.name AND mem.mtime=disk.mtime AND mem.mode=disk.mode)\0"
                        as *const u8 as *const libc::c_char,
                    zTab,
                );
            } else {
                zExists = sqlite3_mprintf(b"\0" as *const u8 as *const libc::c_char);
            }
            if zExists.is_null() {
                rc = 7 as libc::c_int;
            }
            i = 0 as libc::c_int;
            while i < (*pAr).nArg && rc == 0 as libc::c_int {
                let mut zSql2: *mut libc::c_char = sqlite3_mprintf(
                    zInsertFmt[(*pAr).bZip as usize],
                    zTab,
                    if (*pAr).bVerbose as libc::c_int != 0 {
                        b"shell_putsnl(name)\0" as *const u8 as *const libc::c_char
                    } else {
                        b"name\0" as *const u8 as *const libc::c_char
                    },
                    *((*pAr).azArg).offset(i as isize),
                    (*pAr).zDir,
                    zExists,
                );
                rc = arExecSql(pAr, zSql2);
                sqlite3_free(zSql2 as *mut libc::c_void);
                i += 1;
            }
        }
        _ => {}
    }
    if rc != 0 as libc::c_int {
        sqlite3_exec(
            (*pAr).db,
            b"ROLLBACK TO ar; RELEASE ar;\0" as *const u8 as *const libc::c_char,
            None,
            0 as *mut libc::c_void,
            0 as *mut *mut libc::c_char,
        );
    } else {
        rc = arExecSql(pAr, b"RELEASE ar;\0" as *const u8 as *const libc::c_char);
        if (*pAr).bZip as libc::c_int != 0 && !((*pAr).zFile).is_null() {
            zSql = sqlite3_mprintf(
                b"DROP TABLE %s\0" as *const u8 as *const libc::c_char,
                zTemp.as_mut_ptr(),
            );
            arExecSql(pAr, zSql);
            sqlite3_free(zSql as *mut libc::c_void);
        }
    }
    sqlite3_free(zExists as *mut libc::c_void);
    return rc;
}
unsafe extern "C" fn arDotCommand(
    mut pState: *mut ShellState,
    mut fromCmdLine: libc::c_int,
    mut azArg: *mut *mut libc::c_char,
    mut nArg: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut cmd: ArCommand = ArCommand {
        eCmd: 0,
        bVerbose: 0,
        bZip: 0,
        bDryRun: 0,
        bAppend: 0,
        bGlob: 0,
        fromCmdLine: 0,
        nArg: 0,
        zSrcTable: 0 as *mut libc::c_char,
        zFile: 0 as *const libc::c_char,
        zDir: 0 as *const libc::c_char,
        azArg: 0 as *mut *mut libc::c_char,
        p: 0 as *mut ShellState,
        db: 0 as *mut sqlite3,
    };
    let mut rc: libc::c_int = 0;
    memset(
        &mut cmd as *mut ArCommand as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<ArCommand>() as libc::c_ulong,
    );
    cmd.fromCmdLine = fromCmdLine as u8_0;
    rc = arParseCommand(azArg, nArg, &mut cmd);
    if rc == 0 as libc::c_int {
        let mut eDbType: libc::c_int = 0 as libc::c_int;
        cmd.p = pState;
        cmd.db = (*pState).db;
        if !(cmd.zFile).is_null() {
            eDbType = deduceDatabaseType(cmd.zFile, 1 as libc::c_int);
        } else {
            eDbType = (*pState).openMode as libc::c_int;
        }
        if eDbType == 3 as libc::c_int {
            if cmd.eCmd as libc::c_int == 4 as libc::c_int
                || cmd.eCmd as libc::c_int == 5 as libc::c_int
            {
                if (cmd.zFile).is_null() {
                    cmd
                        .zSrcTable = sqlite3_mprintf(
                        b"zip\0" as *const u8 as *const libc::c_char,
                    );
                } else {
                    cmd
                        .zSrcTable = sqlite3_mprintf(
                        b"zipfile(%Q)\0" as *const u8 as *const libc::c_char,
                        cmd.zFile,
                    );
                }
            }
            cmd.bZip = 1 as libc::c_int as u8_0;
            current_block = 5529461102203738653;
        } else if !(cmd.zFile).is_null() {
            let mut flags: libc::c_int = 0;
            if cmd.bAppend != 0 {
                eDbType = 2 as libc::c_int;
            }
            if cmd.eCmd as libc::c_int == 1 as libc::c_int
                || cmd.eCmd as libc::c_int == 3 as libc::c_int
                || cmd.eCmd as libc::c_int == 7 as libc::c_int
                || cmd.eCmd as libc::c_int == 2 as libc::c_int
            {
                flags = 0x2 as libc::c_int | 0x4 as libc::c_int;
            } else {
                flags = 0x1 as libc::c_int;
            }
            cmd.db = 0 as *mut sqlite3;
            if cmd.bDryRun != 0 {
                fprintf(
                    (*pState).out,
                    b"-- open database '%s'%s\n\0" as *const u8 as *const libc::c_char,
                    cmd.zFile,
                    if eDbType == 2 as libc::c_int {
                        b" using 'apndvfs'\0" as *const u8 as *const libc::c_char
                    } else {
                        b"\0" as *const u8 as *const libc::c_char
                    },
                );
            }
            rc = sqlite3_open_v2(
                cmd.zFile,
                &mut cmd.db,
                flags,
                if eDbType == 2 as libc::c_int {
                    b"apndvfs\0" as *const u8 as *const libc::c_char
                } else {
                    0 as *const libc::c_char
                },
            );
            if rc != 0 as libc::c_int {
                fprintf(
                    stderr,
                    b"cannot open file: %s (%s)\n\0" as *const u8 as *const libc::c_char,
                    cmd.zFile,
                    sqlite3_errmsg(cmd.db),
                );
                current_block = 18239839686042348459;
            } else {
                sqlite3_fileio_init(
                    cmd.db,
                    0 as *mut *mut libc::c_char,
                    0 as *const sqlite3_api_routines,
                );
                sqlite3_sqlar_init(
                    cmd.db,
                    0 as *mut *mut libc::c_char,
                    0 as *const sqlite3_api_routines,
                );
                sqlite3_create_function(
                    cmd.db,
                    b"shell_putsnl\0" as *const u8 as *const libc::c_char,
                    1 as libc::c_int,
                    1 as libc::c_int,
                    cmd.p as *mut libc::c_void,
                    Some(
                        shellPutsFunc
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                    None,
                    None,
                );
                current_block = 5529461102203738653;
            }
        } else {
            current_block = 5529461102203738653;
        }
        match current_block {
            18239839686042348459 => {}
            _ => {
                if (cmd.zSrcTable).is_null()
                    && cmd.bZip as libc::c_int == 0 as libc::c_int
                    && cmd.eCmd as libc::c_int != 6 as libc::c_int
                {
                    if cmd.eCmd as libc::c_int != 1 as libc::c_int
                        && sqlite3_table_column_metadata(
                            cmd.db,
                            0 as *const libc::c_char,
                            b"sqlar\0" as *const u8 as *const libc::c_char,
                            b"name\0" as *const u8 as *const libc::c_char,
                            0 as *mut *const libc::c_char,
                            0 as *mut *const libc::c_char,
                            0 as *mut libc::c_int,
                            0 as *mut libc::c_int,
                            0 as *mut libc::c_int,
                        ) != 0
                    {
                        fprintf(
                            stderr,
                            b"database does not contain an 'sqlar' table\n\0"
                                as *const u8 as *const libc::c_char,
                        );
                        rc = 1 as libc::c_int;
                        current_block = 18239839686042348459;
                    } else {
                        cmd
                            .zSrcTable = sqlite3_mprintf(
                            b"sqlar\0" as *const u8 as *const libc::c_char,
                        );
                        current_block = 1847472278776910194;
                    }
                } else {
                    current_block = 1847472278776910194;
                }
                match current_block {
                    18239839686042348459 => {}
                    _ => {
                        match cmd.eCmd as libc::c_int {
                            1 => {
                                rc = arCreateOrUpdateCommand(
                                    &mut cmd,
                                    0 as libc::c_int,
                                    0 as libc::c_int,
                                );
                            }
                            4 => {
                                rc = arExtractCommand(&mut cmd);
                            }
                            5 => {
                                rc = arListCommand(&mut cmd);
                            }
                            6 => {
                                arUsage((*pState).out);
                            }
                            3 => {
                                rc = arCreateOrUpdateCommand(
                                    &mut cmd,
                                    1 as libc::c_int,
                                    0 as libc::c_int,
                                );
                            }
                            7 => {
                                rc = arRemoveCommand(&mut cmd);
                            }
                            _ => {
                                rc = arCreateOrUpdateCommand(
                                    &mut cmd,
                                    1 as libc::c_int,
                                    1 as libc::c_int,
                                );
                            }
                        }
                    }
                }
            }
        }
    }
    if cmd.db != (*pState).db {
        close_db(cmd.db);
    }
    sqlite3_free(cmd.zSrcTable as *mut libc::c_void);
    return rc;
}
unsafe extern "C" fn recoverSqlCb(
    mut pCtx: *mut libc::c_void,
    mut zSql: *const libc::c_char,
) -> libc::c_int {
    let mut pState: *mut ShellState = pCtx as *mut ShellState;
    fprintf((*pState).out, b"%s;\n\0" as *const u8 as *const libc::c_char, zSql);
    return 0 as libc::c_int;
}
unsafe extern "C" fn recoverDatabaseCmd(
    mut pState: *mut ShellState,
    mut nArg: libc::c_int,
    mut azArg: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut zRecoveryDb: *const libc::c_char = b"\0" as *const u8 as *const libc::c_char;
    let mut zLAF: *const libc::c_char = b"lost_and_found\0" as *const u8
        as *const libc::c_char;
    let mut bFreelist: libc::c_int = 1 as libc::c_int;
    let mut bRowids: libc::c_int = 1 as libc::c_int;
    let mut p: *mut sqlite3_recover = 0 as *mut sqlite3_recover;
    let mut i: libc::c_int = 0 as libc::c_int;
    i = 1 as libc::c_int;
    while i < nArg {
        let mut z: *mut libc::c_char = *azArg.offset(i as isize);
        let mut n: libc::c_int = 0;
        if *z.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
            && *z.offset(1 as libc::c_int as isize) as libc::c_int == '-' as i32
        {
            z = z.offset(1);
        }
        n = strlen30(z);
        if n <= 17 as libc::c_int
            && memcmp(
                b"-ignore-freelist\0" as *const u8 as *const libc::c_char
                    as *const libc::c_void,
                z as *const libc::c_void,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            bFreelist = 0 as libc::c_int;
        } else if n <= 12 as libc::c_int
            && memcmp(
                b"-recovery-db\0" as *const u8 as *const libc::c_char
                    as *const libc::c_void,
                z as *const libc::c_void,
                n as libc::c_ulong,
            ) == 0 as libc::c_int && i < nArg - 1 as libc::c_int
        {
            i += 1;
            zRecoveryDb = *azArg.offset(i as isize);
        } else if n <= 15 as libc::c_int
            && memcmp(
                b"-lost-and-found\0" as *const u8 as *const libc::c_char
                    as *const libc::c_void,
                z as *const libc::c_void,
                n as libc::c_ulong,
            ) == 0 as libc::c_int && i < nArg - 1 as libc::c_int
        {
            i += 1;
            zLAF = *azArg.offset(i as isize);
        } else if n <= 10 as libc::c_int
            && memcmp(
                b"-no-rowids\0" as *const u8 as *const libc::c_char
                    as *const libc::c_void,
                z as *const libc::c_void,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            bRowids = 0 as libc::c_int;
        } else {
            fprintf(
                stderr,
                b"unexpected option: %s\n\0" as *const u8 as *const libc::c_char,
                *azArg.offset(i as isize),
            );
            showHelp((*pState).out, *azArg.offset(0 as libc::c_int as isize));
            return 1 as libc::c_int;
        }
        i += 1;
    }
    p = sqlite3_recover_init_sql(
        (*pState).db,
        b"main\0" as *const u8 as *const libc::c_char,
        Some(
            recoverSqlCb
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const libc::c_char,
                ) -> libc::c_int,
        ),
        pState as *mut libc::c_void,
    );
    sqlite3_recover_config(p, 789 as libc::c_int, zRecoveryDb as *mut libc::c_void);
    sqlite3_recover_config(p, 1 as libc::c_int, zLAF as *mut libc::c_void);
    sqlite3_recover_config(
        p,
        3 as libc::c_int,
        &mut bRowids as *mut libc::c_int as *mut libc::c_void,
    );
    sqlite3_recover_config(
        p,
        2 as libc::c_int,
        &mut bFreelist as *mut libc::c_int as *mut libc::c_void,
    );
    sqlite3_recover_run(p);
    if sqlite3_recover_errcode(p) != 0 as libc::c_int {
        let mut zErr: *const libc::c_char = sqlite3_recover_errmsg(p);
        let mut errCode: libc::c_int = sqlite3_recover_errcode(p);
        fprintf(
            stderr,
            b"sql error: %s (%d)\n\0" as *const u8 as *const libc::c_char,
            zErr,
            errCode,
        );
    }
    rc = sqlite3_recover_finish(p);
    return rc;
}
unsafe extern "C" fn rc_err_oom_die(mut rc: libc::c_int) {
    if rc == 7 as libc::c_int {
        shell_check_oom(0 as *mut libc::c_void);
    }
}
static mut zCOL_DB: *const libc::c_char = b":memory:\0" as *const u8
    as *const libc::c_char;
unsafe extern "C" fn zAutoColumn(
    mut zColNew: *const libc::c_char,
    mut pDb: *mut *mut sqlite3,
    mut pzRenamed: *mut *mut libc::c_char,
) -> *mut libc::c_char {
    static mut zTabMake: *const libc::c_char = b"CREATE TABLE ColNames( cpos INTEGER PRIMARY KEY, name TEXT, nlen INT, chop INT, reps INT, suff TEXT);CREATE VIEW RepeatedNames AS SELECT DISTINCT t.name FROM ColNames t WHERE t.name COLLATE NOCASE IN ( SELECT o.name FROM ColNames o WHERE o.cpos<>t.cpos);\0"
        as *const u8 as *const libc::c_char;
    static mut zTabFill: *const libc::c_char = b"INSERT INTO ColNames(name,nlen,chop,reps,suff) VALUES(iif(length(?1)>0,?1,'?'),max(length(?1),1),0,0,'')\0"
        as *const u8 as *const libc::c_char;
    static mut zHasDupes: *const libc::c_char = b"SELECT count(DISTINCT (substring(name,1,nlen-chop)||suff) COLLATE NOCASE) <count(name) FROM ColNames\0"
        as *const u8 as *const libc::c_char;
    static mut zSetReps: *const libc::c_char = b"UPDATE ColNames AS t SET reps=(SELECT count(*) FROM ColNames d  WHERE substring(t.name,1,t.nlen-t.chop)=substring(d.name,1,d.nlen-d.chop) COLLATE NOCASE)\0"
        as *const u8 as *const libc::c_char;
    static mut zColDigits: *const libc::c_char = b"SELECT CAST(ceil(log(count(*)+0.5)) AS INT) FROM ColNames \0"
        as *const u8 as *const libc::c_char;
    static mut zRenameRank: *const libc::c_char = b"WITH Lzn(nlz) AS (  SELECT 0 AS nlz  UNION  SELECT nlz+1 AS nlz FROM Lzn  WHERE EXISTS(   SELECT 1   FROM ColNames t, ColNames o   WHERE    iif(t.name IN (SELECT * FROM RepeatedNames),     printf('%s_%s',      t.name, substring(printf('%.*c%0.*d',nlz+1,'0',$1,t.cpos),2)),     t.name    )    =    iif(o.name IN (SELECT * FROM RepeatedNames),     printf('%s_%s',      o.name, substring(printf('%.*c%0.*d',nlz+1,'0',$1,o.cpos),2)),     o.name    )    COLLATE NOCASE    AND o.cpos<>t.cpos   GROUP BY t.cpos  )) UPDATE Colnames AS t SET chop = 0, suff = iif(name IN (SELECT * FROM RepeatedNames),  printf('_%s', substring(   printf('%.*c%0.*d',(SELECT max(nlz) FROM Lzn)+1,'0',1,t.cpos),2)),  '' )\0"
        as *const u8 as *const libc::c_char;
    static mut zCollectVar: *const libc::c_char = b"SELECT '('||x'0a' || group_concat(  cname||' TEXT',  ','||iif((cpos-1)%4>0, ' ', x'0a'||' ')) ||')' AS ColsSpec FROM ( SELECT cpos, printf('\"%w\"',printf('%!.*s%s', nlen-chop,name,suff)) AS cname  FROM ColNames ORDER BY cpos)\0"
        as *const u8 as *const libc::c_char;
    static mut zRenamesDone: *const libc::c_char = b"SELECT group_concat( printf('\"%w\" to \"%w\"',name,printf('%!.*s%s', nlen-chop, name, suff)), ','||x'0a')FROM ColNames WHERE suff<>'' OR chop!=0\0"
        as *const u8 as *const libc::c_char;
    let mut rc: libc::c_int = 0;
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    if !zColNew.is_null() {
        if (*pDb).is_null() {
            if 0 as libc::c_int != sqlite3_open(zCOL_DB, pDb) {
                return 0 as *mut libc::c_char;
            }
            rc = sqlite3_exec(
                *pDb,
                zTabMake,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
            rc_err_oom_die(rc);
        }
        rc = sqlite3_prepare_v2(
            *pDb,
            zTabFill,
            -(1 as libc::c_int),
            &mut pStmt,
            0 as *mut *const libc::c_char,
        );
        rc_err_oom_die(rc);
        rc = sqlite3_bind_text(
            pStmt,
            1 as libc::c_int,
            zColNew,
            -(1 as libc::c_int),
            None,
        );
        rc_err_oom_die(rc);
        rc = sqlite3_step(pStmt);
        rc_err_oom_die(rc);
        sqlite3_finalize(pStmt);
        return 0 as *mut libc::c_char;
    } else if (*pDb).is_null() {
        return 0 as *mut libc::c_char
    } else {
        let mut zColsSpec: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut hasDupes: libc::c_int = db_int(*pDb, zHasDupes);
        let mut nDigits: libc::c_int = if hasDupes != 0 {
            db_int(*pDb, zColDigits)
        } else {
            0 as libc::c_int
        };
        if hasDupes != 0 {
            rc = sqlite3_exec(
                *pDb,
                zSetReps,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
            rc_err_oom_die(rc);
            rc = sqlite3_prepare_v2(
                *pDb,
                zRenameRank,
                -(1 as libc::c_int),
                &mut pStmt,
                0 as *mut *const libc::c_char,
            );
            rc_err_oom_die(rc);
            sqlite3_bind_int(pStmt, 1 as libc::c_int, nDigits);
            rc = sqlite3_step(pStmt);
            sqlite3_finalize(pStmt);
        }
        rc = sqlite3_prepare_v2(
            *pDb,
            zCollectVar,
            -(1 as libc::c_int),
            &mut pStmt,
            0 as *mut *const libc::c_char,
        );
        rc_err_oom_die(rc);
        rc = sqlite3_step(pStmt);
        if rc == 100 as libc::c_int {
            zColsSpec = sqlite3_mprintf(
                b"%s\0" as *const u8 as *const libc::c_char,
                sqlite3_column_text(pStmt, 0 as libc::c_int),
            );
        } else {
            zColsSpec = 0 as *mut libc::c_char;
        }
        if !pzRenamed.is_null() {
            if hasDupes == 0 {
                *pzRenamed = 0 as *mut libc::c_char;
            } else {
                sqlite3_finalize(pStmt);
                if 0 as libc::c_int
                    == sqlite3_prepare_v2(
                        *pDb,
                        zRenamesDone,
                        -(1 as libc::c_int),
                        &mut pStmt,
                        0 as *mut *const libc::c_char,
                    ) && 100 as libc::c_int == sqlite3_step(pStmt)
                {
                    *pzRenamed = sqlite3_mprintf(
                        b"%s\0" as *const u8 as *const libc::c_char,
                        sqlite3_column_text(pStmt, 0 as libc::c_int),
                    );
                } else {
                    *pzRenamed = 0 as *mut libc::c_char;
                }
            }
        }
        sqlite3_finalize(pStmt);
        sqlite3_close(*pDb);
        *pDb = 0 as *mut sqlite3;
        return zColsSpec;
    };
}
unsafe extern "C" fn do_meta_command(
    mut zLine: *mut libc::c_char,
    mut p: *mut ShellState,
) -> libc::c_int {
    let mut dbCols: *mut sqlite3 = 0 as *mut sqlite3;
    let mut zRenames: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zColDefs: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut current_block: u64;
    let mut h: libc::c_int = 1 as libc::c_int;
    let mut nArg: libc::c_int = 0 as libc::c_int;
    let mut n: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut azArg: [*mut libc::c_char; 52] = [0 as *mut libc::c_char; 52];
    if !((*p).expert.pExpert).is_null() {
        expertFinish(p, 1 as libc::c_int, 0 as *mut *mut libc::c_char);
    }
    while *zLine.offset(h as isize) as libc::c_int != 0
        && nArg
            < (::std::mem::size_of::<[*mut libc::c_char; 52]>() as libc::c_ulong)
                .wrapping_div(
                    ::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong,
                ) as libc::c_int - 1 as libc::c_int
    {
        while *(*__ctype_b_loc())
            .offset(*zLine.offset(h as isize) as libc::c_uchar as libc::c_int as isize)
            as libc::c_int & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
            != 0
        {
            h += 1;
        }
        if *zLine.offset(h as isize) as libc::c_int == 0 as libc::c_int {
            break;
        }
        if *zLine.offset(h as isize) as libc::c_int == '\'' as i32
            || *zLine.offset(h as isize) as libc::c_int == '"' as i32
        {
            let fresh421 = h;
            h = h + 1;
            let mut delim: libc::c_int = *zLine.offset(fresh421 as isize) as libc::c_int;
            let fresh422 = nArg;
            nArg = nArg + 1;
            azArg[fresh422
                as usize] = &mut *zLine.offset(h as isize) as *mut libc::c_char;
            while *zLine.offset(h as isize) as libc::c_int != 0
                && *zLine.offset(h as isize) as libc::c_int != delim
            {
                if *zLine.offset(h as isize) as libc::c_int == '\\' as i32
                    && delim == '"' as i32
                    && *zLine.offset((h + 1 as libc::c_int) as isize) as libc::c_int
                        != 0 as libc::c_int
                {
                    h += 1;
                }
                h += 1;
            }
            if *zLine.offset(h as isize) as libc::c_int == delim {
                let fresh423 = h;
                h = h + 1;
                *zLine.offset(fresh423 as isize) = 0 as libc::c_int as libc::c_char;
            }
            if delim == '"' as i32 {
                resolve_backslashes(azArg[(nArg - 1 as libc::c_int) as usize]);
            }
        } else {
            let fresh424 = nArg;
            nArg = nArg + 1;
            azArg[fresh424
                as usize] = &mut *zLine.offset(h as isize) as *mut libc::c_char;
            while *zLine.offset(h as isize) as libc::c_int != 0
                && *(*__ctype_b_loc())
                    .offset(
                        *zLine.offset(h as isize) as libc::c_uchar as libc::c_int
                            as isize,
                    ) as libc::c_int
                    & _ISspace as libc::c_int as libc::c_ushort as libc::c_int == 0
            {
                h += 1;
            }
            if *zLine.offset(h as isize) != 0 {
                let fresh425 = h;
                h = h + 1;
                *zLine.offset(fresh425 as isize) = 0 as libc::c_int as libc::c_char;
            }
            resolve_backslashes(azArg[(nArg - 1 as libc::c_int) as usize]);
        }
    }
    azArg[nArg as usize] = 0 as *mut libc::c_char;
    if nArg == 0 as libc::c_int {
        return 0 as libc::c_int;
    }
    n = strlen30(azArg[0 as libc::c_int as usize]);
    c = *(azArg[0 as libc::c_int as usize]).offset(0 as libc::c_int as isize)
        as libc::c_int;
    clearTempFile(p);
    if c == 'a' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"auth\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        if nArg != 2 as libc::c_int {
            fprintf(
                stderr,
                b"Usage: .auth ON|OFF\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        } else {
            open_db(p, 0 as libc::c_int);
            if booleanValue(azArg[1 as libc::c_int as usize]) != 0 {
                sqlite3_set_authorizer(
                    (*p).db,
                    Some(
                        shellAuth
                            as unsafe extern "C" fn(
                                *mut libc::c_void,
                                libc::c_int,
                                *const libc::c_char,
                                *const libc::c_char,
                                *const libc::c_char,
                                *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    p as *mut libc::c_void,
                );
            } else if (*p).bSafeModePersist != 0 {
                sqlite3_set_authorizer(
                    (*p).db,
                    Some(
                        safeModeAuth
                            as unsafe extern "C" fn(
                                *mut libc::c_void,
                                libc::c_int,
                                *const libc::c_char,
                                *const libc::c_char,
                                *const libc::c_char,
                                *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    p as *mut libc::c_void,
                );
            } else {
                sqlite3_set_authorizer((*p).db, None, 0 as *mut libc::c_void);
            }
        }
    } else if c == 'a' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"archive\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        open_db(p, 0 as libc::c_int);
        failIfSafeMode(
            p,
            b"cannot run .archive in safe mode\0" as *const u8 as *const libc::c_char,
        );
        rc = arDotCommand(p, 0 as libc::c_int, azArg.as_mut_ptr(), nArg);
    } else if c == 'b' as i32 && n >= 3 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"backup\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
        || c == 's' as i32 && n >= 3 as libc::c_int
            && cli_strncmp(
                azArg[0 as libc::c_int as usize],
                b"save\0" as *const u8 as *const libc::c_char,
                n as size_t,
            ) == 0 as libc::c_int
    {
        let mut zDestFile: *const libc::c_char = 0 as *const libc::c_char;
        let mut zDb: *const libc::c_char = 0 as *const libc::c_char;
        let mut pDest: *mut sqlite3 = 0 as *mut sqlite3;
        let mut pBackup: *mut sqlite3_backup = 0 as *mut sqlite3_backup;
        let mut j: libc::c_int = 0;
        let mut bAsync: libc::c_int = 0 as libc::c_int;
        let mut zVfs: *const libc::c_char = 0 as *const libc::c_char;
        failIfSafeMode(
            p,
            b"cannot run .%s in safe mode\0" as *const u8 as *const libc::c_char,
            azArg[0 as libc::c_int as usize],
        );
        j = 1 as libc::c_int;
        while j < nArg {
            let mut z: *const libc::c_char = azArg[j as usize];
            if *z.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                if *z.offset(1 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                    z = z.offset(1);
                }
                if cli_strcmp(z, b"-append\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    zVfs = b"apndvfs\0" as *const u8 as *const libc::c_char;
                } else if cli_strcmp(z, b"-async\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    bAsync = 1 as libc::c_int;
                } else {
                    fprintf(
                        stderr,
                        b"unknown option: %s\n\0" as *const u8 as *const libc::c_char,
                        azArg[j as usize],
                    );
                    return 1 as libc::c_int;
                }
            } else if zDestFile.is_null() {
                zDestFile = azArg[j as usize];
            } else if zDb.is_null() {
                zDb = zDestFile;
                zDestFile = azArg[j as usize];
            } else {
                fprintf(
                    stderr,
                    b"Usage: .backup ?DB? ?OPTIONS? FILENAME\n\0" as *const u8
                        as *const libc::c_char,
                );
                return 1 as libc::c_int;
            }
            j += 1;
        }
        if zDestFile.is_null() {
            fprintf(
                stderr,
                b"missing FILENAME argument on .backup\n\0" as *const u8
                    as *const libc::c_char,
            );
            return 1 as libc::c_int;
        }
        if zDb.is_null() {
            zDb = b"main\0" as *const u8 as *const libc::c_char;
        }
        rc = sqlite3_open_v2(
            zDestFile,
            &mut pDest,
            0x2 as libc::c_int | 0x4 as libc::c_int,
            zVfs,
        );
        if rc != 0 as libc::c_int {
            fprintf(
                stderr,
                b"Error: cannot open \"%s\"\n\0" as *const u8 as *const libc::c_char,
                zDestFile,
            );
            close_db(pDest);
            return 1 as libc::c_int;
        }
        if bAsync != 0 {
            sqlite3_exec(
                pDest,
                b"PRAGMA synchronous=OFF; PRAGMA journal_mode=OFF;\0" as *const u8
                    as *const libc::c_char,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
        }
        open_db(p, 0 as libc::c_int);
        pBackup = sqlite3_backup_init(
            pDest,
            b"main\0" as *const u8 as *const libc::c_char,
            (*p).db,
            zDb,
        );
        if pBackup.is_null() {
            fprintf(
                stderr,
                b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                sqlite3_errmsg(pDest),
            );
            close_db(pDest);
            return 1 as libc::c_int;
        }
        loop {
            rc = sqlite3_backup_step(pBackup, 100 as libc::c_int);
            if !(rc == 0 as libc::c_int) {
                break;
            }
        }
        sqlite3_backup_finish(pBackup);
        if rc == 101 as libc::c_int {
            rc = 0 as libc::c_int;
        } else {
            fprintf(
                stderr,
                b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                sqlite3_errmsg(pDest),
            );
            rc = 1 as libc::c_int;
        }
        close_db(pDest);
    } else if c == 'b' as i32 && n >= 3 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"bail\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        if nArg == 2 as libc::c_int {
            bail_on_error = booleanValue(azArg[1 as libc::c_int as usize]);
        } else {
            fprintf(
                stderr,
                b"Usage: .bail on|off\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 'b' as i32 && n >= 3 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"binary\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        if nArg == 2 as libc::c_int {
            booleanValue(azArg[1 as libc::c_int as usize]) != 0;
        } else {
            fprintf(
                stderr,
                b"Usage: .binary on|off\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 'b' as i32 && n >= 3 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"breakpoint\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        test_breakpoint();
    } else if c == 'c' as i32
        && cli_strcmp(
            azArg[0 as libc::c_int as usize],
            b"cd\0" as *const u8 as *const libc::c_char,
        ) == 0 as libc::c_int
    {
        failIfSafeMode(
            p,
            b"cannot run .cd in safe mode\0" as *const u8 as *const libc::c_char,
        );
        if nArg == 2 as libc::c_int {
            rc = chdir(azArg[1 as libc::c_int as usize]);
            if rc != 0 {
                fprintf(
                    stderr,
                    b"Cannot change to directory \"%s\"\n\0" as *const u8
                        as *const libc::c_char,
                    azArg[1 as libc::c_int as usize],
                );
                rc = 1 as libc::c_int;
            }
        } else {
            fprintf(
                stderr,
                b"Usage: .cd DIRECTORY\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 'c' as i32 && n >= 3 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"changes\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        if nArg == 2 as libc::c_int {
            setOrClearFlag(
                p,
                0x20 as libc::c_int as libc::c_uint,
                azArg[1 as libc::c_int as usize],
            );
        } else {
            fprintf(
                stderr,
                b"Usage: .changes on|off\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 'c' as i32 && n >= 3 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"check\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut zRes: *mut libc::c_char = 0 as *mut libc::c_char;
        output_reset(p);
        if nArg != 2 as libc::c_int {
            fprintf(
                stderr,
                b"Usage: .check GLOB-PATTERN\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 2 as libc::c_int;
        } else {
            zRes = readFile(
                b"testcase-out.txt\0" as *const u8 as *const libc::c_char,
                0 as *mut libc::c_int,
            );
            if zRes.is_null() {
                fprintf(
                    stderr,
                    b"Error: cannot read 'testcase-out.txt'\n\0" as *const u8
                        as *const libc::c_char,
                );
                rc = 2 as libc::c_int;
            } else if testcase_glob(azArg[1 as libc::c_int as usize], zRes)
                == 0 as libc::c_int
            {
                fprintf(
                    stderr,
                    b"testcase-%s FAILED\n Expected: [%s]\n      Got: [%s]\n\0"
                        as *const u8 as *const libc::c_char,
                    ((*p).zTestcase).as_mut_ptr(),
                    azArg[1 as libc::c_int as usize],
                    zRes,
                );
                rc = 1 as libc::c_int;
            } else {
                fprintf(
                    stdout,
                    b"testcase-%s ok\n\0" as *const u8 as *const libc::c_char,
                    ((*p).zTestcase).as_mut_ptr(),
                );
                let ref mut fresh426 = (*p).nCheck;
                *fresh426 += 1;
            }
        }
        sqlite3_free(zRes as *mut libc::c_void);
    } else if c == 'c' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"clone\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        failIfSafeMode(
            p,
            b"cannot run .clone in safe mode\0" as *const u8 as *const libc::c_char,
        );
        if nArg == 2 as libc::c_int {
            tryToClone(p, azArg[1 as libc::c_int as usize]);
        } else {
            fprintf(
                stderr,
                b"Usage: .clone FILENAME\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 'c' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"connection\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        if nArg == 1 as libc::c_int {
            let mut i: libc::c_int = 0;
            i = 0 as libc::c_int;
            while i
                < (::std::mem::size_of::<[AuxDb; 5]>() as libc::c_ulong)
                    .wrapping_div(::std::mem::size_of::<AuxDb>() as libc::c_ulong)
                    as libc::c_int
            {
                let mut zFile: *const libc::c_char = (*p).aAuxDb[i as usize].zDbFilename;
                if ((*p).aAuxDb[i as usize].db).is_null()
                    && (*p).pAuxDb
                        != &mut *((*p).aAuxDb).as_mut_ptr().offset(i as isize)
                            as *mut AuxDb
                {
                    zFile = b"(not open)\0" as *const u8 as *const libc::c_char;
                } else if zFile.is_null() {
                    zFile = b"(memory)\0" as *const u8 as *const libc::c_char;
                } else if *zFile.offset(0 as libc::c_int as isize) as libc::c_int
                    == 0 as libc::c_int
                {
                    zFile = b"(temporary-file)\0" as *const u8 as *const libc::c_char;
                }
                if (*p).pAuxDb
                    == &mut *((*p).aAuxDb).as_mut_ptr().offset(i as isize) as *mut AuxDb
                {
                    fprintf(
                        stdout,
                        b"ACTIVE %d: %s\n\0" as *const u8 as *const libc::c_char,
                        i,
                        zFile,
                    );
                } else if !((*p).aAuxDb[i as usize].db).is_null() {
                    fprintf(
                        stdout,
                        b"       %d: %s\n\0" as *const u8 as *const libc::c_char,
                        i,
                        zFile,
                    );
                }
                i += 1;
            }
        } else if nArg == 2 as libc::c_int
            && *(*__ctype_b_loc())
                .offset(
                    *(azArg[1 as libc::c_int as usize]).offset(0 as libc::c_int as isize)
                        as libc::c_uchar as libc::c_int as isize,
                ) as libc::c_int
                & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int != 0
            && *(azArg[1 as libc::c_int as usize]).offset(1 as libc::c_int as isize)
                as libc::c_int == 0 as libc::c_int
        {
            let mut i_0: libc::c_int = *(azArg[1 as libc::c_int as usize])
                .offset(0 as libc::c_int as isize) as libc::c_int - '0' as i32;
            if (*p).pAuxDb
                != &mut *((*p).aAuxDb).as_mut_ptr().offset(i_0 as isize) as *mut AuxDb
                && i_0 >= 0 as libc::c_int
                && i_0
                    < (::std::mem::size_of::<[AuxDb; 5]>() as libc::c_ulong)
                        .wrapping_div(::std::mem::size_of::<AuxDb>() as libc::c_ulong)
                        as libc::c_int
            {
                let ref mut fresh427 = (*(*p).pAuxDb).db;
                *fresh427 = (*p).db;
                let ref mut fresh428 = (*p).pAuxDb;
                *fresh428 = &mut *((*p).aAuxDb).as_mut_ptr().offset(i_0 as isize)
                    as *mut AuxDb;
                let ref mut fresh429 = (*p).db;
                *fresh429 = (*(*p).pAuxDb).db;
                globalDb = *fresh429;
                let ref mut fresh430 = (*(*p).pAuxDb).db;
                *fresh430 = 0 as *mut sqlite3;
            }
        } else if nArg == 3 as libc::c_int
            && cli_strcmp(
                azArg[1 as libc::c_int as usize],
                b"close\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
            && *(*__ctype_b_loc())
                .offset(
                    *(azArg[2 as libc::c_int as usize]).offset(0 as libc::c_int as isize)
                        as libc::c_uchar as libc::c_int as isize,
                ) as libc::c_int
                & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int != 0
            && *(azArg[2 as libc::c_int as usize]).offset(1 as libc::c_int as isize)
                as libc::c_int == 0 as libc::c_int
        {
            let mut i_1: libc::c_int = *(azArg[2 as libc::c_int as usize])
                .offset(0 as libc::c_int as isize) as libc::c_int - '0' as i32;
            if !(i_1 < 0 as libc::c_int
                || i_1
                    >= (::std::mem::size_of::<[AuxDb; 5]>() as libc::c_ulong)
                        .wrapping_div(::std::mem::size_of::<AuxDb>() as libc::c_ulong)
                        as libc::c_int)
            {
                if (*p).pAuxDb
                    == &mut *((*p).aAuxDb).as_mut_ptr().offset(i_1 as isize)
                        as *mut AuxDb
                {
                    fprintf(
                        stderr,
                        b"cannot close the active database connection\n\0" as *const u8
                            as *const libc::c_char,
                    );
                    rc = 1 as libc::c_int;
                } else if !((*p).aAuxDb[i_1 as usize].db).is_null() {
                    close_db((*p).aAuxDb[i_1 as usize].db);
                    let ref mut fresh431 = (*p).aAuxDb[i_1 as usize].db;
                    *fresh431 = 0 as *mut sqlite3;
                }
            }
        } else {
            fprintf(
                stderr,
                b"Usage: .connection [close] [CONNECTION-NUMBER]\n\0" as *const u8
                    as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 'd' as i32 && n > 1 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"databases\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut azName: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
        let mut nName: libc::c_int = 0 as libc::c_int;
        let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        let mut i_2: libc::c_int = 0;
        open_db(p, 0 as libc::c_int);
        rc = sqlite3_prepare_v2(
            (*p).db,
            b"PRAGMA database_list\0" as *const u8 as *const libc::c_char,
            -(1 as libc::c_int),
            &mut pStmt,
            0 as *mut *const libc::c_char,
        );
        if rc != 0 {
            fprintf(
                stderr,
                b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                sqlite3_errmsg((*p).db),
            );
            rc = 1 as libc::c_int;
        } else {
            while sqlite3_step(pStmt) == 100 as libc::c_int {
                let mut zSchema: *const libc::c_char = sqlite3_column_text(
                    pStmt,
                    1 as libc::c_int,
                ) as *const libc::c_char;
                let mut zFile_0: *const libc::c_char = sqlite3_column_text(
                    pStmt,
                    2 as libc::c_int,
                ) as *const libc::c_char;
                if zSchema.is_null() || zFile_0.is_null() {
                    continue;
                }
                azName = sqlite3_realloc(
                    azName as *mut libc::c_void,
                    (((nName + 1 as libc::c_int) * 2 as libc::c_int) as libc::c_ulong)
                        .wrapping_mul(
                            ::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong,
                        ) as libc::c_int,
                ) as *mut *mut libc::c_char;
                shell_check_oom(azName as *mut libc::c_void);
                let ref mut fresh432 = *azName
                    .offset((nName * 2 as libc::c_int) as isize);
                *fresh432 = strdup(zSchema);
                let ref mut fresh433 = *azName
                    .offset((nName * 2 as libc::c_int + 1 as libc::c_int) as isize);
                *fresh433 = strdup(zFile_0);
                nName += 1;
            }
        }
        sqlite3_finalize(pStmt);
        i_2 = 0 as libc::c_int;
        while i_2 < nName {
            let mut eTxn: libc::c_int = sqlite3_txn_state(
                (*p).db,
                *azName.offset((i_2 * 2 as libc::c_int) as isize),
            );
            let mut bRdonly: libc::c_int = sqlite3_db_readonly(
                (*p).db,
                *azName.offset((i_2 * 2 as libc::c_int) as isize),
            );
            let mut z_0: *const libc::c_char = *azName
                .offset((i_2 * 2 as libc::c_int + 1 as libc::c_int) as isize);
            fprintf(
                (*p).out,
                b"%s: %s %s%s\n\0" as *const u8 as *const libc::c_char,
                *azName.offset((i_2 * 2 as libc::c_int) as isize),
                if !z_0.is_null()
                    && *z_0.offset(0 as libc::c_int as isize) as libc::c_int != 0
                {
                    z_0
                } else {
                    b"\"\"\0" as *const u8 as *const libc::c_char
                },
                if bRdonly != 0 {
                    b"r/o\0" as *const u8 as *const libc::c_char
                } else {
                    b"r/w\0" as *const u8 as *const libc::c_char
                },
                if eTxn == 0 as libc::c_int {
                    b"\0" as *const u8 as *const libc::c_char
                } else if eTxn == 1 as libc::c_int {
                    b" read-txn\0" as *const u8 as *const libc::c_char
                } else {
                    b" write-txn\0" as *const u8 as *const libc::c_char
                },
            );
            free(*azName.offset((i_2 * 2 as libc::c_int) as isize) as *mut libc::c_void);
            free(
                *azName.offset((i_2 * 2 as libc::c_int + 1 as libc::c_int) as isize)
                    as *mut libc::c_void,
            );
            i_2 += 1;
        }
        sqlite3_free(azName as *mut libc::c_void);
    } else if c == 'd' as i32 && n >= 3 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"dbconfig\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        static mut aDbConfig: [DbConfigChoices; 16] = [
            {
                let mut init = DbConfigChoices {
                    zName: b"defensive\0" as *const u8 as *const libc::c_char,
                    op: 1010 as libc::c_int,
                };
                init
            },
            {
                let mut init = DbConfigChoices {
                    zName: b"dqs_ddl\0" as *const u8 as *const libc::c_char,
                    op: 1014 as libc::c_int,
                };
                init
            },
            {
                let mut init = DbConfigChoices {
                    zName: b"dqs_dml\0" as *const u8 as *const libc::c_char,
                    op: 1013 as libc::c_int,
                };
                init
            },
            {
                let mut init = DbConfigChoices {
                    zName: b"enable_fkey\0" as *const u8 as *const libc::c_char,
                    op: 1002 as libc::c_int,
                };
                init
            },
            {
                let mut init = DbConfigChoices {
                    zName: b"enable_qpsg\0" as *const u8 as *const libc::c_char,
                    op: 1007 as libc::c_int,
                };
                init
            },
            {
                let mut init = DbConfigChoices {
                    zName: b"enable_trigger\0" as *const u8 as *const libc::c_char,
                    op: 1003 as libc::c_int,
                };
                init
            },
            {
                let mut init = DbConfigChoices {
                    zName: b"enable_view\0" as *const u8 as *const libc::c_char,
                    op: 1015 as libc::c_int,
                };
                init
            },
            {
                let mut init = DbConfigChoices {
                    zName: b"fts3_tokenizer\0" as *const u8 as *const libc::c_char,
                    op: 1004 as libc::c_int,
                };
                init
            },
            {
                let mut init = DbConfigChoices {
                    zName: b"legacy_alter_table\0" as *const u8 as *const libc::c_char,
                    op: 1012 as libc::c_int,
                };
                init
            },
            {
                let mut init = DbConfigChoices {
                    zName: b"legacy_file_format\0" as *const u8 as *const libc::c_char,
                    op: 1016 as libc::c_int,
                };
                init
            },
            {
                let mut init = DbConfigChoices {
                    zName: b"load_extension\0" as *const u8 as *const libc::c_char,
                    op: 1005 as libc::c_int,
                };
                init
            },
            {
                let mut init = DbConfigChoices {
                    zName: b"no_ckpt_on_close\0" as *const u8 as *const libc::c_char,
                    op: 1006 as libc::c_int,
                };
                init
            },
            {
                let mut init = DbConfigChoices {
                    zName: b"reset_database\0" as *const u8 as *const libc::c_char,
                    op: 1009 as libc::c_int,
                };
                init
            },
            {
                let mut init = DbConfigChoices {
                    zName: b"trigger_eqp\0" as *const u8 as *const libc::c_char,
                    op: 1008 as libc::c_int,
                };
                init
            },
            {
                let mut init = DbConfigChoices {
                    zName: b"trusted_schema\0" as *const u8 as *const libc::c_char,
                    op: 1017 as libc::c_int,
                };
                init
            },
            {
                let mut init = DbConfigChoices {
                    zName: b"writable_schema\0" as *const u8 as *const libc::c_char,
                    op: 1011 as libc::c_int,
                };
                init
            },
        ];
        let mut ii: libc::c_int = 0;
        let mut v: libc::c_int = 0;
        open_db(p, 0 as libc::c_int);
        ii = 0 as libc::c_int;
        while ii
            < (::std::mem::size_of::<[DbConfigChoices; 16]>() as libc::c_ulong)
                .wrapping_div(::std::mem::size_of::<DbConfigChoices>() as libc::c_ulong)
                as libc::c_int
        {
            if !(nArg > 1 as libc::c_int
                && cli_strcmp(
                    azArg[1 as libc::c_int as usize],
                    aDbConfig[ii as usize].zName,
                ) != 0 as libc::c_int)
            {
                if nArg >= 3 as libc::c_int {
                    sqlite3_db_config(
                        (*p).db,
                        aDbConfig[ii as usize].op,
                        booleanValue(azArg[2 as libc::c_int as usize]),
                        0 as libc::c_int,
                    );
                }
                sqlite3_db_config(
                    (*p).db,
                    aDbConfig[ii as usize].op,
                    -(1 as libc::c_int),
                    &mut v as *mut libc::c_int,
                );
                fprintf(
                    (*p).out,
                    b"%19s %s\n\0" as *const u8 as *const libc::c_char,
                    aDbConfig[ii as usize].zName,
                    if v != 0 {
                        b"on\0" as *const u8 as *const libc::c_char
                    } else {
                        b"off\0" as *const u8 as *const libc::c_char
                    },
                );
                if nArg > 1 as libc::c_int {
                    break;
                }
            }
            ii += 1;
        }
        if nArg > 1 as libc::c_int
            && ii
                == (::std::mem::size_of::<[DbConfigChoices; 16]>() as libc::c_ulong)
                    .wrapping_div(
                        ::std::mem::size_of::<DbConfigChoices>() as libc::c_ulong,
                    ) as libc::c_int
        {
            fprintf(
                stderr,
                b"Error: unknown dbconfig \"%s\"\n\0" as *const u8
                    as *const libc::c_char,
                azArg[1 as libc::c_int as usize],
            );
            fprintf(
                stderr,
                b"Enter \".dbconfig\" with no arguments for a list\n\0" as *const u8
                    as *const libc::c_char,
            );
        }
    } else if c == 'd' as i32 && n >= 3 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"dbinfo\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        rc = shell_dbinfo_command(p, nArg, azArg.as_mut_ptr());
    } else if c == 'r' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"recover\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        open_db(p, 0 as libc::c_int);
        rc = recoverDatabaseCmd(p, nArg, azArg.as_mut_ptr());
    } else if c == 'd' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"dump\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut zLike: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut i_3: libc::c_int = 0;
        let mut savedShowHeader: libc::c_int = (*p).showHeader;
        let mut savedShellFlags: libc::c_int = (*p).shellFlgs as libc::c_int;
        (*p).shellFlgs
            &= !(0x8 as libc::c_int | 0x10 as libc::c_int | 0x40 as libc::c_int
                | 0x100 as libc::c_int | 0x200 as libc::c_int) as libc::c_uint;
        i_3 = 1 as libc::c_int;
        loop {
            if !(i_3 < nArg) {
                current_block = 7121273192085788486;
                break;
            }
            if *(azArg[i_3 as usize]).offset(0 as libc::c_int as isize) as libc::c_int
                == '-' as i32
            {
                let mut z_1: *const libc::c_char = (azArg[i_3 as usize])
                    .offset(1 as libc::c_int as isize);
                if *z_1.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                    z_1 = z_1.offset(1);
                }
                if cli_strcmp(
                    z_1,
                    b"preserve-rowids\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
                {
                    (*p).shellFlgs |= 0x8 as libc::c_int as libc::c_uint;
                } else if cli_strcmp(
                    z_1,
                    b"newlines\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
                {
                    (*p).shellFlgs |= 0x10 as libc::c_int as libc::c_uint;
                } else if cli_strcmp(
                    z_1,
                    b"data-only\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
                {
                    (*p).shellFlgs |= 0x100 as libc::c_int as libc::c_uint;
                } else if cli_strcmp(z_1, b"nosys\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    (*p).shellFlgs |= 0x200 as libc::c_int as libc::c_uint;
                } else {
                    fprintf(
                        stderr,
                        b"Unknown option \"%s\" on \".dump\"\n\0" as *const u8
                            as *const libc::c_char,
                        azArg[i_3 as usize],
                    );
                    rc = 1 as libc::c_int;
                    sqlite3_free(zLike as *mut libc::c_void);
                    current_block = 3081897820958806732;
                    break;
                }
            } else {
                let mut zExpr: *mut libc::c_char = sqlite3_mprintf(
                    b"name LIKE %Q ESCAPE '\\' OR EXISTS (  SELECT 1 FROM sqlite_schema WHERE     name LIKE %Q ESCAPE '\\' AND    sql LIKE 'CREATE VIRTUAL TABLE%%' AND    substr(o.name, 1, length(name)+1) == (name||'_'))\0"
                        as *const u8 as *const libc::c_char,
                    azArg[i_3 as usize],
                    azArg[i_3 as usize],
                );
                if !zLike.is_null() {
                    zLike = sqlite3_mprintf(
                        b"%z OR %z\0" as *const u8 as *const libc::c_char,
                        zLike,
                        zExpr,
                    );
                } else {
                    zLike = zExpr;
                }
            }
            i_3 += 1;
        }
        match current_block {
            3081897820958806732 => {}
            _ => {
                open_db(p, 0 as libc::c_int);
                if (*p).shellFlgs & 0x100 as libc::c_int as libc::c_uint
                    == 0 as libc::c_int as libc::c_uint
                {
                    fprintf(
                        (*p).out,
                        b"PRAGMA foreign_keys=OFF;\n\0" as *const u8
                            as *const libc::c_char,
                    );
                    fprintf(
                        (*p).out,
                        b"BEGIN TRANSACTION;\n\0" as *const u8 as *const libc::c_char,
                    );
                }
                (*p).writableSchema = 0 as libc::c_int;
                (*p).showHeader = 0 as libc::c_int;
                sqlite3_exec(
                    (*p).db,
                    b"SAVEPOINT dump; PRAGMA writable_schema=ON\0" as *const u8
                        as *const libc::c_char,
                    None,
                    0 as *mut libc::c_void,
                    0 as *mut *mut libc::c_char,
                );
                (*p).nErr = 0 as libc::c_int;
                if zLike.is_null() {
                    zLike = sqlite3_mprintf(
                        b"true\0" as *const u8 as *const libc::c_char,
                    );
                }
                zSql = sqlite3_mprintf(
                    b"SELECT name, type, sql FROM sqlite_schema AS o WHERE (%s) AND type=='table'  AND sql NOT NULL ORDER BY tbl_name='sqlite_sequence', rowid\0"
                        as *const u8 as *const libc::c_char,
                    zLike,
                );
                run_schema_dump_query(p, zSql);
                sqlite3_free(zSql as *mut libc::c_void);
                if (*p).shellFlgs & 0x100 as libc::c_int as libc::c_uint
                    == 0 as libc::c_int as libc::c_uint
                {
                    zSql = sqlite3_mprintf(
                        b"SELECT sql FROM sqlite_schema AS o WHERE (%s) AND sql NOT NULL  AND type IN ('index','trigger','view')\0"
                            as *const u8 as *const libc::c_char,
                        zLike,
                    );
                    run_table_dump_query(p, zSql);
                    sqlite3_free(zSql as *mut libc::c_void);
                }
                sqlite3_free(zLike as *mut libc::c_void);
                if (*p).writableSchema != 0 {
                    fprintf(
                        (*p).out,
                        b"PRAGMA writable_schema=OFF;\n\0" as *const u8
                            as *const libc::c_char,
                    );
                    (*p).writableSchema = 0 as libc::c_int;
                }
                sqlite3_exec(
                    (*p).db,
                    b"PRAGMA writable_schema=OFF;\0" as *const u8 as *const libc::c_char,
                    None,
                    0 as *mut libc::c_void,
                    0 as *mut *mut libc::c_char,
                );
                sqlite3_exec(
                    (*p).db,
                    b"RELEASE dump;\0" as *const u8 as *const libc::c_char,
                    None,
                    0 as *mut libc::c_void,
                    0 as *mut *mut libc::c_char,
                );
                if (*p).shellFlgs & 0x100 as libc::c_int as libc::c_uint
                    == 0 as libc::c_int as libc::c_uint
                {
                    fprintf(
                        (*p).out,
                        if (*p).nErr != 0 {
                            b"ROLLBACK; -- due to errors\n\0" as *const u8
                                as *const libc::c_char
                        } else {
                            b"COMMIT;\n\0" as *const u8 as *const libc::c_char
                        },
                    );
                }
                (*p).showHeader = savedShowHeader;
                (*p).shellFlgs = savedShellFlags as libc::c_uint;
            }
        }
    } else if c == 'e' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"echo\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        if nArg == 2 as libc::c_int {
            setOrClearFlag(
                p,
                0x40 as libc::c_int as libc::c_uint,
                azArg[1 as libc::c_int as usize],
            );
        } else {
            fprintf(
                stderr,
                b"Usage: .echo on|off\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 'e' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"eqp\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        if nArg == 2 as libc::c_int {
            (*p).autoEQPtest = 0 as libc::c_int as u8_0;
            if (*p).autoEQPtrace != 0 {
                if !((*p).db).is_null() {
                    sqlite3_exec(
                        (*p).db,
                        b"PRAGMA vdbe_trace=OFF;\0" as *const u8 as *const libc::c_char,
                        None,
                        0 as *mut libc::c_void,
                        0 as *mut *mut libc::c_char,
                    );
                }
                (*p).autoEQPtrace = 0 as libc::c_int as u8_0;
            }
            if cli_strcmp(
                azArg[1 as libc::c_int as usize],
                b"full\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
            {
                (*p).autoEQP = 3 as libc::c_int as u8_0;
            } else if cli_strcmp(
                azArg[1 as libc::c_int as usize],
                b"trigger\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
            {
                (*p).autoEQP = 2 as libc::c_int as u8_0;
            } else {
                (*p).autoEQP = booleanValue(azArg[1 as libc::c_int as usize]) as u8_0;
            }
        } else {
            fprintf(
                stderr,
                b"Usage: .eqp off|on|trace|trigger|full\n\0" as *const u8
                    as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 'e' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"exit\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        if nArg > 1 as libc::c_int
            && {
                rc = integerValue(azArg[1 as libc::c_int as usize]) as libc::c_int;
                rc != 0 as libc::c_int
            }
        {
            exit(rc);
        }
        rc = 2 as libc::c_int;
    } else if c == 'e' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"explain\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut val: libc::c_int = 1 as libc::c_int;
        if nArg >= 2 as libc::c_int {
            if cli_strcmp(
                azArg[1 as libc::c_int as usize],
                b"auto\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
            {
                val = 99 as libc::c_int;
            } else {
                val = booleanValue(azArg[1 as libc::c_int as usize]);
            }
        }
        if val == 1 as libc::c_int && (*p).mode != 9 as libc::c_int {
            (*p).normalMode = (*p).mode;
            (*p).mode = 9 as libc::c_int;
            (*p).autoExplain = 0 as libc::c_int as u8_0;
        } else if val == 0 as libc::c_int {
            if (*p).mode == 9 as libc::c_int {
                (*p).mode = (*p).normalMode;
            }
            (*p).autoExplain = 0 as libc::c_int as u8_0;
        } else if val == 99 as libc::c_int {
            if (*p).mode == 9 as libc::c_int {
                (*p).mode = (*p).normalMode;
            }
            (*p).autoExplain = 1 as libc::c_int as u8_0;
        }
    } else if c == 'e' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"expert\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        if (*p).bSafeMode != 0 {
            fprintf(
                stderr,
                b"Cannot run experimental commands such as \"%s\" in safe mode\n\0"
                    as *const u8 as *const libc::c_char,
                azArg[0 as libc::c_int as usize],
            );
            rc = 1 as libc::c_int;
        } else {
            open_db(p, 0 as libc::c_int);
            expertDotCommand(p, azArg.as_mut_ptr(), nArg);
        }
    } else if c == 'f' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"filectrl\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        static mut aCtrl: [C2RustUnnamed_21; 9] = [
            {
                let mut init = C2RustUnnamed_21 {
                    zCtrlName: b"chunk_size\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 6 as libc::c_int,
                    zUsage: b"SIZE\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_21 {
                    zCtrlName: b"data_version\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 35 as libc::c_int,
                    zUsage: b"\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_21 {
                    zCtrlName: b"has_moved\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 20 as libc::c_int,
                    zUsage: b"\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_21 {
                    zCtrlName: b"lock_timeout\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 34 as libc::c_int,
                    zUsage: b"MILLISEC\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_21 {
                    zCtrlName: b"persist_wal\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 10 as libc::c_int,
                    zUsage: b"[BOOLEAN]\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_21 {
                    zCtrlName: b"psow\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 13 as libc::c_int,
                    zUsage: b"[BOOLEAN]\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_21 {
                    zCtrlName: b"reserve_bytes\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 38 as libc::c_int,
                    zUsage: b"[N]\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_21 {
                    zCtrlName: b"size_limit\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 36 as libc::c_int,
                    zUsage: b"[LIMIT]\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_21 {
                    zCtrlName: b"tempfilename\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 16 as libc::c_int,
                    zUsage: b"\0" as *const u8 as *const libc::c_char,
                };
                init
            },
        ];
        let mut filectrl: libc::c_int = -(1 as libc::c_int);
        let mut iCtrl: libc::c_int = -(1 as libc::c_int);
        let mut iRes: sqlite3_int64 = 0 as libc::c_int as sqlite3_int64;
        let mut isOk: libc::c_int = 0 as libc::c_int;
        let mut n2: libc::c_int = 0;
        let mut i_4: libc::c_int = 0;
        let mut zCmd: *const libc::c_char = 0 as *const libc::c_char;
        let mut zSchema_0: *const libc::c_char = 0 as *const libc::c_char;
        open_db(p, 0 as libc::c_int);
        zCmd = if nArg >= 2 as libc::c_int {
            azArg[1 as libc::c_int as usize] as *const libc::c_char
        } else {
            b"help\0" as *const u8 as *const libc::c_char
        };
        if *zCmd.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
            && (cli_strcmp(zCmd, b"--schema\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
                || cli_strcmp(zCmd, b"-schema\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int) && nArg >= 4 as libc::c_int
        {
            zSchema_0 = azArg[2 as libc::c_int as usize];
            i_4 = 3 as libc::c_int;
            while i_4 < nArg {
                azArg[(i_4 - 2 as libc::c_int) as usize] = azArg[i_4 as usize];
                i_4 += 1;
            }
            nArg -= 2 as libc::c_int;
            zCmd = azArg[1 as libc::c_int as usize];
        }
        if *zCmd.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
            && *zCmd.offset(1 as libc::c_int as isize) as libc::c_int != 0
        {
            zCmd = zCmd.offset(1);
            if *zCmd.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
                && *zCmd.offset(1 as libc::c_int as isize) as libc::c_int != 0
            {
                zCmd = zCmd.offset(1);
            }
        }
        if cli_strcmp(zCmd, b"help\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            fprintf(
                (*p).out,
                b"Available file-controls:\n\0" as *const u8 as *const libc::c_char,
            );
            i_4 = 0 as libc::c_int;
            while i_4
                < (::std::mem::size_of::<[C2RustUnnamed_21; 9]>() as libc::c_ulong)
                    .wrapping_div(
                        ::std::mem::size_of::<C2RustUnnamed_21>() as libc::c_ulong,
                    ) as libc::c_int
            {
                fprintf(
                    (*p).out,
                    b"  .filectrl %s %s\n\0" as *const u8 as *const libc::c_char,
                    aCtrl[i_4 as usize].zCtrlName,
                    aCtrl[i_4 as usize].zUsage,
                );
                i_4 += 1;
            }
            rc = 1 as libc::c_int;
        } else {
            n2 = strlen30(zCmd);
            i_4 = 0 as libc::c_int;
            loop {
                if !(i_4
                    < (::std::mem::size_of::<[C2RustUnnamed_21; 9]>() as libc::c_ulong)
                        .wrapping_div(
                            ::std::mem::size_of::<C2RustUnnamed_21>() as libc::c_ulong,
                        ) as libc::c_int)
                {
                    current_block = 9592786760029756364;
                    break;
                }
                if cli_strncmp(zCmd, aCtrl[i_4 as usize].zCtrlName, n2 as size_t)
                    == 0 as libc::c_int
                {
                    if filectrl < 0 as libc::c_int {
                        filectrl = aCtrl[i_4 as usize].ctrlCode;
                        iCtrl = i_4;
                    } else {
                        fprintf(
                            stderr,
                            b"Error: ambiguous file-control: \"%s\"\nUse \".filectrl --help\" for help\n\0"
                                as *const u8 as *const libc::c_char,
                            zCmd,
                        );
                        rc = 1 as libc::c_int;
                        current_block = 3081897820958806732;
                        break;
                    }
                }
                i_4 += 1;
            }
            match current_block {
                3081897820958806732 => {}
                _ => {
                    if filectrl < 0 as libc::c_int {
                        fprintf(
                            stderr,
                            b"Error: unknown file-control: %s\nUse \".filectrl --help\" for help\n\0"
                                as *const u8 as *const libc::c_char,
                            zCmd,
                        );
                    } else {
                        match filectrl {
                            36 => {
                                if !(nArg != 2 as libc::c_int && nArg != 3 as libc::c_int) {
                                    iRes = if nArg == 3 as libc::c_int {
                                        integerValue(azArg[2 as libc::c_int as usize])
                                    } else {
                                        -(1 as libc::c_int) as libc::c_longlong
                                    };
                                    sqlite3_file_control(
                                        (*p).db,
                                        zSchema_0,
                                        36 as libc::c_int,
                                        &mut iRes as *mut sqlite3_int64 as *mut libc::c_void,
                                    );
                                    isOk = 1 as libc::c_int;
                                }
                            }
                            34 | 6 => {
                                let mut x: libc::c_int = 0;
                                if !(nArg != 3 as libc::c_int) {
                                    x = integerValue(azArg[2 as libc::c_int as usize])
                                        as libc::c_int;
                                    sqlite3_file_control(
                                        (*p).db,
                                        zSchema_0,
                                        filectrl,
                                        &mut x as *mut libc::c_int as *mut libc::c_void,
                                    );
                                    isOk = 2 as libc::c_int;
                                }
                            }
                            10 | 13 => {
                                let mut x_0: libc::c_int = 0;
                                if !(nArg != 2 as libc::c_int && nArg != 3 as libc::c_int) {
                                    x_0 = if nArg == 3 as libc::c_int {
                                        booleanValue(azArg[2 as libc::c_int as usize])
                                    } else {
                                        -(1 as libc::c_int)
                                    };
                                    sqlite3_file_control(
                                        (*p).db,
                                        zSchema_0,
                                        filectrl,
                                        &mut x_0 as *mut libc::c_int as *mut libc::c_void,
                                    );
                                    iRes = x_0 as sqlite3_int64;
                                    isOk = 1 as libc::c_int;
                                }
                            }
                            35 | 20 => {
                                let mut x_1: libc::c_int = 0;
                                if !(nArg != 2 as libc::c_int) {
                                    sqlite3_file_control(
                                        (*p).db,
                                        zSchema_0,
                                        filectrl,
                                        &mut x_1 as *mut libc::c_int as *mut libc::c_void,
                                    );
                                    iRes = x_1 as sqlite3_int64;
                                    isOk = 1 as libc::c_int;
                                }
                            }
                            16 => {
                                let mut z_2: *mut libc::c_char = 0 as *mut libc::c_char;
                                if !(nArg != 2 as libc::c_int) {
                                    sqlite3_file_control(
                                        (*p).db,
                                        zSchema_0,
                                        filectrl,
                                        &mut z_2 as *mut *mut libc::c_char as *mut libc::c_void,
                                    );
                                    if !z_2.is_null() {
                                        fprintf(
                                            (*p).out,
                                            b"%s\n\0" as *const u8 as *const libc::c_char,
                                            z_2,
                                        );
                                        sqlite3_free(z_2 as *mut libc::c_void);
                                    }
                                    isOk = 2 as libc::c_int;
                                }
                            }
                            38 => {
                                let mut x_2: libc::c_int = 0;
                                if nArg >= 3 as libc::c_int {
                                    x_2 = atoi(azArg[2 as libc::c_int as usize]);
                                    sqlite3_file_control(
                                        (*p).db,
                                        zSchema_0,
                                        filectrl,
                                        &mut x_2 as *mut libc::c_int as *mut libc::c_void,
                                    );
                                }
                                x_2 = -(1 as libc::c_int);
                                sqlite3_file_control(
                                    (*p).db,
                                    zSchema_0,
                                    filectrl,
                                    &mut x_2 as *mut libc::c_int as *mut libc::c_void,
                                );
                                fprintf(
                                    (*p).out,
                                    b"%d\n\0" as *const u8 as *const libc::c_char,
                                    x_2,
                                );
                                isOk = 2 as libc::c_int;
                            }
                            _ => {}
                        }
                    }
                    if isOk == 0 as libc::c_int && iCtrl >= 0 as libc::c_int {
                        fprintf(
                            (*p).out,
                            b"Usage: .filectrl %s %s\n\0" as *const u8
                                as *const libc::c_char,
                            zCmd,
                            aCtrl[iCtrl as usize].zUsage,
                        );
                        rc = 1 as libc::c_int;
                    } else if isOk == 1 as libc::c_int {
                        let mut zBuf: [libc::c_char; 100] = [0; 100];
                        sqlite3_snprintf(
                            ::std::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong
                                as libc::c_int,
                            zBuf.as_mut_ptr(),
                            b"%lld\0" as *const u8 as *const libc::c_char,
                            iRes,
                        );
                        fprintf(
                            (*p).out,
                            b"%s\n\0" as *const u8 as *const libc::c_char,
                            zBuf.as_mut_ptr(),
                        );
                    }
                }
            }
        }
    } else if c == 'f' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"fullschema\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut data: ShellState = ShellState {
            db: 0 as *mut sqlite3,
            autoExplain: 0,
            autoEQP: 0,
            autoEQPtest: 0,
            autoEQPtrace: 0,
            scanstatsOn: 0,
            openMode: 0,
            doXdgOpen: 0,
            nEqpLevel: 0,
            eTraceType: 0,
            bSafeMode: 0,
            bSafeModePersist: 0,
            cmOpts: ColModeOpts {
                iWrap: 0,
                bQuote: 0,
                bWordWrap: 0,
            },
            statsOn: 0,
            mEqpLines: 0,
            inputNesting: 0,
            outCount: 0,
            cnt: 0,
            lineno: 0,
            openFlags: 0,
            in_0: 0 as *mut FILE,
            out: 0 as *mut FILE,
            traceOut: 0 as *mut FILE,
            nErr: 0,
            mode: 0,
            modePrior: 0,
            cMode: 0,
            normalMode: 0,
            writableSchema: 0,
            showHeader: 0,
            nCheck: 0,
            nProgress: 0,
            mxProgress: 0,
            flgProgress: 0,
            shellFlgs: 0,
            priorShFlgs: 0,
            szMax: 0,
            zDestTable: 0 as *mut libc::c_char,
            zTempFile: 0 as *mut libc::c_char,
            zTestcase: [0; 30],
            colSeparator: [0; 20],
            rowSeparator: [0; 20],
            colSepPrior: [0; 20],
            rowSepPrior: [0; 20],
            colWidth: 0 as *mut libc::c_int,
            actualWidth: 0 as *mut libc::c_int,
            nWidth: 0,
            nullValue: [0; 20],
            outfile: [0; 4096],
            pStmt: 0 as *mut sqlite3_stmt,
            pLog: 0 as *mut FILE,
            aAuxDb: [AuxDb {
                db: 0 as *mut sqlite3,
                zDbFilename: 0 as *const libc::c_char,
                zFreeOnClose: 0 as *mut libc::c_char,
            }; 5],
            pAuxDb: 0 as *mut AuxDb,
            aiIndent: 0 as *mut libc::c_int,
            nIndent: 0,
            iIndent: 0,
            zNonce: 0 as *mut libc::c_char,
            sGraph: EQPGraph {
                pRow: 0 as *mut EQPGraphRow,
                pLast: 0 as *mut EQPGraphRow,
                zPrefix: [0; 100],
            },
            expert: ExpertInfo {
                pExpert: 0 as *mut sqlite3expert,
                bVerbose: 0,
            },
        };
        let mut doStats: libc::c_int = 0 as libc::c_int;
        memcpy(
            &mut data as *mut ShellState as *mut libc::c_void,
            p as *const libc::c_void,
            ::std::mem::size_of::<ShellState>() as libc::c_ulong,
        );
        data.showHeader = 0 as libc::c_int;
        data.mode = 3 as libc::c_int;
        data.cMode = data.mode;
        if nArg == 2 as libc::c_int
            && optionMatch(
                azArg[1 as libc::c_int as usize],
                b"indent\0" as *const u8 as *const libc::c_char,
            ) != 0
        {
            data.mode = 11 as libc::c_int;
            data.cMode = data.mode;
            nArg = 1 as libc::c_int;
        }
        if nArg != 1 as libc::c_int {
            fprintf(
                stderr,
                b"Usage: .fullschema ?--indent?\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        } else {
            open_db(p, 0 as libc::c_int);
            rc = sqlite3_exec(
                (*p).db,
                b"SELECT sql FROM  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x     FROM sqlite_schema UNION ALL   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_schema) WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%' ORDER BY x\0"
                    as *const u8 as *const libc::c_char,
                Some(
                    callback
                        as unsafe extern "C" fn(
                            *mut libc::c_void,
                            libc::c_int,
                            *mut *mut libc::c_char,
                            *mut *mut libc::c_char,
                        ) -> libc::c_int,
                ),
                &mut data as *mut ShellState as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
            if rc == 0 as libc::c_int {
                let mut pStmt_0: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
                rc = sqlite3_prepare_v2(
                    (*p).db,
                    b"SELECT rowid FROM sqlite_schema WHERE name GLOB 'sqlite_stat[134]'\0"
                        as *const u8 as *const libc::c_char,
                    -(1 as libc::c_int),
                    &mut pStmt_0,
                    0 as *mut *const libc::c_char,
                );
                doStats = (sqlite3_step(pStmt_0) == 100 as libc::c_int) as libc::c_int;
                sqlite3_finalize(pStmt_0);
            }
            if doStats == 0 as libc::c_int {
                fprintf(
                    (*p).out,
                    b"/* No STAT tables available */\n\0" as *const u8
                        as *const libc::c_char,
                );
            } else {
                fprintf(
                    (*p).out,
                    b"ANALYZE sqlite_schema;\n\0" as *const u8 as *const libc::c_char,
                );
                data.mode = 5 as libc::c_int;
                data.cMode = data.mode;
                data
                    .zDestTable = b"sqlite_stat1\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char;
                shell_exec(
                    &mut data,
                    b"SELECT * FROM sqlite_stat1\0" as *const u8 as *const libc::c_char,
                    0 as *mut *mut libc::c_char,
                );
                data
                    .zDestTable = b"sqlite_stat4\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char;
                shell_exec(
                    &mut data,
                    b"SELECT * FROM sqlite_stat4\0" as *const u8 as *const libc::c_char,
                    0 as *mut *mut libc::c_char,
                );
                fprintf(
                    (*p).out,
                    b"ANALYZE sqlite_schema;\n\0" as *const u8 as *const libc::c_char,
                );
            }
        }
    } else if c == 'h' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"headers\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        if nArg == 2 as libc::c_int {
            (*p).showHeader = booleanValue(azArg[1 as libc::c_int as usize]);
            (*p).shellFlgs |= 0x80 as libc::c_int as libc::c_uint;
        } else {
            fprintf(
                stderr,
                b"Usage: .headers on|off\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 'h' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"help\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        if nArg >= 2 as libc::c_int {
            n = showHelp((*p).out, azArg[1 as libc::c_int as usize]);
            if n == 0 as libc::c_int {
                fprintf(
                    (*p).out,
                    b"Nothing matches '%s'\n\0" as *const u8 as *const libc::c_char,
                    azArg[1 as libc::c_int as usize],
                );
            }
        } else {
            showHelp((*p).out, 0 as *const libc::c_char);
        }
    } else if c == 'i' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"import\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut zTable: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut zSchema_1: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut zFile_1: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut pStmt_1: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        let mut nCol: libc::c_int = 0;
        let mut nByte: libc::c_int = 0;
        let mut i_5: libc::c_int = 0;
        let mut j_0: libc::c_int = 0;
        let mut needCommit: libc::c_int = 0;
        let mut nSep: libc::c_int = 0;
        let mut zSql_0: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut zFullTabName: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut sCtx: ImportCtx = ImportCtx {
            zFile: 0 as *const libc::c_char,
            in_0: 0 as *mut FILE,
            xCloser: None,
            z: 0 as *mut libc::c_char,
            n: 0,
            nAlloc: 0,
            nLine: 0,
            nRow: 0,
            nErr: 0,
            bNotFirst: 0,
            cTerm: 0,
            cColSep: 0,
            cRowSep: 0,
        };
        let mut xRead: Option::<
            unsafe extern "C" fn(*mut ImportCtx) -> *mut libc::c_char,
        > = None;
        let mut eVerbose: libc::c_int = 0 as libc::c_int;
        let mut nSkip: libc::c_int = 0 as libc::c_int;
        let mut useOutputMode: libc::c_int = 1 as libc::c_int;
        let mut zCreate: *mut libc::c_char = 0 as *mut libc::c_char;
        failIfSafeMode(
            p,
            b"cannot run .import in safe mode\0" as *const u8 as *const libc::c_char,
        );
        memset(
            &mut sCtx as *mut ImportCtx as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<ImportCtx>() as libc::c_ulong,
        );
        if (*p).mode == 10 as libc::c_int {
            xRead = Some(
                ascii_read_one_field
                    as unsafe extern "C" fn(*mut ImportCtx) -> *mut libc::c_char,
            );
        } else {
            xRead = Some(
                csv_read_one_field
                    as unsafe extern "C" fn(*mut ImportCtx) -> *mut libc::c_char,
            );
        }
        rc = 1 as libc::c_int;
        i_5 = 1 as libc::c_int;
        loop {
            if !(i_5 < nArg) {
                current_block = 13872226096892761410;
                break;
            }
            let mut z_3: *mut libc::c_char = azArg[i_5 as usize];
            if *z_3.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
                && *z_3.offset(1 as libc::c_int as isize) as libc::c_int == '-' as i32
            {
                z_3 = z_3.offset(1);
            }
            if *z_3.offset(0 as libc::c_int as isize) as libc::c_int != '-' as i32 {
                if zFile_1.is_null() {
                    zFile_1 = z_3;
                } else if zTable.is_null() {
                    zTable = z_3;
                } else {
                    fprintf(
                        (*p).out,
                        b"ERROR: extra argument: \"%s\".  Usage:\n\0" as *const u8
                            as *const libc::c_char,
                        z_3,
                    );
                    showHelp((*p).out, b"import\0" as *const u8 as *const libc::c_char);
                    current_block = 3081897820958806732;
                    break;
                }
            } else if cli_strcmp(z_3, b"-v\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                eVerbose += 1;
            } else if cli_strcmp(z_3, b"-schema\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int && i_5 < nArg - 1 as libc::c_int
            {
                i_5 += 1;
                zSchema_1 = azArg[i_5 as usize];
            } else if cli_strcmp(z_3, b"-skip\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int && i_5 < nArg - 1 as libc::c_int
            {
                i_5 += 1;
                nSkip = integerValue(azArg[i_5 as usize]) as libc::c_int;
            } else if cli_strcmp(z_3, b"-ascii\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                sCtx
                    .cColSep = (*::std::mem::transmute::<
                    &[u8; 2],
                    &[libc::c_char; 2],
                >(b"\x1F\0"))[0 as libc::c_int as usize] as libc::c_int;
                sCtx
                    .cRowSep = (*::std::mem::transmute::<
                    &[u8; 2],
                    &[libc::c_char; 2],
                >(b"\x1E\0"))[0 as libc::c_int as usize] as libc::c_int;
                xRead = Some(
                    ascii_read_one_field
                        as unsafe extern "C" fn(*mut ImportCtx) -> *mut libc::c_char,
                );
                useOutputMode = 0 as libc::c_int;
            } else if cli_strcmp(z_3, b"-csv\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                sCtx.cColSep = ',' as i32;
                sCtx.cRowSep = '\n' as i32;
                xRead = Some(
                    csv_read_one_field
                        as unsafe extern "C" fn(*mut ImportCtx) -> *mut libc::c_char,
                );
                useOutputMode = 0 as libc::c_int;
            } else {
                fprintf(
                    (*p).out,
                    b"ERROR: unknown option: \"%s\".  Usage:\n\0" as *const u8
                        as *const libc::c_char,
                    z_3,
                );
                showHelp((*p).out, b"import\0" as *const u8 as *const libc::c_char);
                current_block = 3081897820958806732;
                break;
            }
            i_5 += 1;
        }
        match current_block {
            3081897820958806732 => {}
            _ => {
                if zTable.is_null() {
                    fprintf(
                        (*p).out,
                        b"ERROR: missing %s argument. Usage:\n\0" as *const u8
                            as *const libc::c_char,
                        if zFile_1.is_null() {
                            b"FILE\0" as *const u8 as *const libc::c_char
                        } else {
                            b"TABLE\0" as *const u8 as *const libc::c_char
                        },
                    );
                    showHelp((*p).out, b"import\0" as *const u8 as *const libc::c_char);
                } else {
                    ::std::ptr::write_volatile(
                        &mut seenInterrupt as *mut libc::c_int,
                        0 as libc::c_int,
                    );
                    open_db(p, 0 as libc::c_int);
                    if useOutputMode != 0 {
                        nSep = strlen30(((*p).colSeparator).as_mut_ptr());
                        if nSep == 0 as libc::c_int {
                            fprintf(
                                stderr,
                                b"Error: non-null column separator required for import\n\0"
                                    as *const u8 as *const libc::c_char,
                            );
                            current_block = 3081897820958806732;
                        } else if nSep > 1 as libc::c_int {
                            fprintf(
                                stderr,
                                b"Error: multi-character column separators not allowed for import\n\0"
                                    as *const u8 as *const libc::c_char,
                            );
                            current_block = 3081897820958806732;
                        } else {
                            nSep = strlen30(((*p).rowSeparator).as_mut_ptr());
                            if nSep == 0 as libc::c_int {
                                fprintf(
                                    stderr,
                                    b"Error: non-null row separator required for import\n\0"
                                        as *const u8 as *const libc::c_char,
                                );
                                current_block = 3081897820958806732;
                            } else {
                                if nSep == 2 as libc::c_int && (*p).mode == 8 as libc::c_int
                                    && cli_strcmp(
                                        ((*p).rowSeparator).as_mut_ptr(),
                                        b"\r\n\0" as *const u8 as *const libc::c_char,
                                    ) == 0 as libc::c_int
                                {
                                    sqlite3_snprintf(
                                        ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                                            as libc::c_int,
                                        ((*p).rowSeparator).as_mut_ptr(),
                                        b"\n\0" as *const u8 as *const libc::c_char,
                                    );
                                    nSep = strlen30(((*p).rowSeparator).as_mut_ptr());
                                }
                                if nSep > 1 as libc::c_int {
                                    fprintf(
                                        stderr,
                                        b"Error: multi-character row separators not allowed for import\n\0"
                                            as *const u8 as *const libc::c_char,
                                    );
                                    current_block = 3081897820958806732;
                                } else {
                                    sCtx
                                        .cColSep = (*p).colSeparator[0 as libc::c_int as usize]
                                        as libc::c_int;
                                    sCtx
                                        .cRowSep = (*p).rowSeparator[0 as libc::c_int as usize]
                                        as libc::c_int;
                                    current_block = 3530048995107750543;
                                }
                            }
                        }
                    } else {
                        current_block = 3530048995107750543;
                    }
                    match current_block {
                        3081897820958806732 => {}
                        _ => {
                            sCtx.zFile = zFile_1;
                            sCtx.nLine = 1 as libc::c_int;
                            if *(sCtx.zFile).offset(0 as libc::c_int as isize)
                                as libc::c_int == '|' as i32
                            {
                                sCtx
                                    .in_0 = popen(
                                    (sCtx.zFile).offset(1 as libc::c_int as isize),
                                    b"r\0" as *const u8 as *const libc::c_char,
                                );
                                sCtx
                                    .zFile = b"<pipe>\0" as *const u8 as *const libc::c_char;
                                sCtx
                                    .xCloser = Some(
                                    pclose as unsafe extern "C" fn(*mut FILE) -> libc::c_int,
                                );
                            } else {
                                sCtx
                                    .in_0 = fopen(
                                    sCtx.zFile,
                                    b"rb\0" as *const u8 as *const libc::c_char,
                                );
                                sCtx
                                    .xCloser = Some(
                                    fclose as unsafe extern "C" fn(*mut FILE) -> libc::c_int,
                                );
                            }
                            if (sCtx.in_0).is_null() {
                                fprintf(
                                    stderr,
                                    b"Error: cannot open \"%s\"\n\0" as *const u8
                                        as *const libc::c_char,
                                    zFile_1,
                                );
                            } else {
                                if eVerbose >= 2 as libc::c_int
                                    || eVerbose >= 1 as libc::c_int && useOutputMode != 0
                                {
                                    let mut zSep: [libc::c_char; 2] = [0; 2];
                                    zSep[1 as libc::c_int
                                        as usize] = 0 as libc::c_int as libc::c_char;
                                    zSep[0 as libc::c_int
                                        as usize] = sCtx.cColSep as libc::c_char;
                                    fprintf(
                                        (*p).out,
                                        b"Column separator \0" as *const u8 as *const libc::c_char,
                                    );
                                    output_c_string((*p).out, zSep.as_mut_ptr());
                                    fprintf(
                                        (*p).out,
                                        b", row separator \0" as *const u8 as *const libc::c_char,
                                    );
                                    zSep[0 as libc::c_int
                                        as usize] = sCtx.cRowSep as libc::c_char;
                                    output_c_string((*p).out, zSep.as_mut_ptr());
                                    fprintf(
                                        (*p).out,
                                        b"\n\0" as *const u8 as *const libc::c_char,
                                    );
                                }
                                sCtx
                                    .z = sqlite3_malloc64(120 as libc::c_int as sqlite3_uint64)
                                    as *mut libc::c_char;
                                if (sCtx.z).is_null() {
                                    import_cleanup(&mut sCtx);
                                    shell_out_of_memory();
                                }
                                loop {
                                    let fresh434 = nSkip;
                                    nSkip = nSkip - 1;
                                    if !(fresh434 > 0 as libc::c_int) {
                                        break;
                                    }
                                    while !(xRead
                                        .expect("non-null function pointer")(&mut sCtx))
                                        .is_null() && sCtx.cTerm == sCtx.cColSep
                                    {}
                                }
                                if !zSchema_1.is_null() {
                                    zFullTabName = sqlite3_mprintf(
                                        b"\"%w\".\"%w\"\0" as *const u8 as *const libc::c_char,
                                        zSchema_1,
                                        zTable,
                                    );
                                } else {
                                    zFullTabName = sqlite3_mprintf(
                                        b"\"%w\"\0" as *const u8 as *const libc::c_char,
                                        zTable,
                                    );
                                }
                                zSql_0 = sqlite3_mprintf(
                                    b"SELECT * FROM %s\0" as *const u8 as *const libc::c_char,
                                    zFullTabName,
                                );
                                if zSql_0.is_null() || zFullTabName.is_null() {
                                    import_cleanup(&mut sCtx);
                                    shell_out_of_memory();
                                }
                                nByte = strlen30(zSql_0);
                                rc = sqlite3_prepare_v2(
                                    (*p).db,
                                    zSql_0,
                                    -(1 as libc::c_int),
                                    &mut pStmt_1,
                                    0 as *mut *const libc::c_char,
                                );
                                import_append_char(&mut sCtx, 0 as libc::c_int);
                                if rc != 0
                                    && sqlite3_strglob(
                                        b"no such table: *\0" as *const u8 as *const libc::c_char,
                                        sqlite3_errmsg((*p).db),
                                    ) == 0 as libc::c_int
                                {
                                    dbCols = 0 as *mut sqlite3;
                                    zRenames = 0 as *mut libc::c_char;
                                    zColDefs = 0 as *mut libc::c_char;
                                    zCreate = sqlite3_mprintf(
                                        b"CREATE TABLE %s\0" as *const u8 as *const libc::c_char,
                                        zFullTabName,
                                    );
                                    while !(xRead
                                        .expect("non-null function pointer")(&mut sCtx))
                                        .is_null()
                                    {
                                        zAutoColumn(
                                            sCtx.z,
                                            &mut dbCols,
                                            0 as *mut *mut libc::c_char,
                                        );
                                        if sCtx.cTerm != sCtx.cColSep {
                                            break;
                                        }
                                    }
                                    zColDefs = zAutoColumn(
                                        0 as *const libc::c_char,
                                        &mut dbCols,
                                        &mut zRenames,
                                    );
                                    if !zRenames.is_null() {
                                        fprintf(
                                            if stdin_is_interactive != 0 && (*p).in_0 == stdin {
                                                (*p).out
                                            } else {
                                                stderr
                                            },
                                            b"Columns renamed during .import %s due to duplicates:\n%s\n\0"
                                                as *const u8 as *const libc::c_char,
                                            sCtx.zFile,
                                            zRenames,
                                        );
                                        sqlite3_free(zRenames as *mut libc::c_void);
                                    }
                                    if zColDefs.is_null() {
                                        fprintf(
                                            stderr,
                                            b"%s: empty file\n\0" as *const u8 as *const libc::c_char,
                                            sCtx.zFile,
                                        );
                                        current_block = 10900954862009114805;
                                    } else {
                                        zCreate = sqlite3_mprintf(
                                            b"%z%z\n\0" as *const u8 as *const libc::c_char,
                                            zCreate,
                                            zColDefs,
                                        );
                                        if eVerbose >= 1 as libc::c_int {
                                            fprintf(
                                                (*p).out,
                                                b"%s\n\0" as *const u8 as *const libc::c_char,
                                                zCreate,
                                            );
                                        }
                                        rc = sqlite3_exec(
                                            (*p).db,
                                            zCreate,
                                            None,
                                            0 as *mut libc::c_void,
                                            0 as *mut *mut libc::c_char,
                                        );
                                        if rc != 0 {
                                            fprintf(
                                                stderr,
                                                b"%s failed:\n%s\n\0" as *const u8 as *const libc::c_char,
                                                zCreate,
                                                sqlite3_errmsg((*p).db),
                                            );
                                            current_block = 10900954862009114805;
                                        } else {
                                            sqlite3_free(zCreate as *mut libc::c_void);
                                            zCreate = 0 as *mut libc::c_char;
                                            rc = sqlite3_prepare_v2(
                                                (*p).db,
                                                zSql_0,
                                                -(1 as libc::c_int),
                                                &mut pStmt_1,
                                                0 as *mut *const libc::c_char,
                                            );
                                            current_block = 13679161836941955923;
                                        }
                                    }
                                } else {
                                    current_block = 13679161836941955923;
                                }
                                match current_block {
                                    13679161836941955923 => {
                                        if rc != 0 {
                                            if !pStmt_1.is_null() {
                                                sqlite3_finalize(pStmt_1);
                                            }
                                            fprintf(
                                                stderr,
                                                b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                                                sqlite3_errmsg((*p).db),
                                            );
                                            current_block = 10900954862009114805;
                                        } else {
                                            sqlite3_free(zSql_0 as *mut libc::c_void);
                                            nCol = sqlite3_column_count(pStmt_1);
                                            sqlite3_finalize(pStmt_1);
                                            pStmt_1 = 0 as *mut sqlite3_stmt;
                                            if nCol == 0 as libc::c_int {
                                                return 0 as libc::c_int;
                                            }
                                            zSql_0 = sqlite3_malloc64(
                                                (nByte * 2 as libc::c_int + 20 as libc::c_int
                                                    + nCol * 2 as libc::c_int) as sqlite3_uint64,
                                            ) as *mut libc::c_char;
                                            if zSql_0.is_null() {
                                                import_cleanup(&mut sCtx);
                                                shell_out_of_memory();
                                            }
                                            sqlite3_snprintf(
                                                nByte + 20 as libc::c_int,
                                                zSql_0,
                                                b"INSERT INTO %s VALUES(?\0" as *const u8
                                                    as *const libc::c_char,
                                                zFullTabName,
                                            );
                                            j_0 = strlen30(zSql_0);
                                            i_5 = 1 as libc::c_int;
                                            while i_5 < nCol {
                                                let fresh435 = j_0;
                                                j_0 = j_0 + 1;
                                                *zSql_0
                                                    .offset(fresh435 as isize) = ',' as i32 as libc::c_char;
                                                let fresh436 = j_0;
                                                j_0 = j_0 + 1;
                                                *zSql_0
                                                    .offset(fresh436 as isize) = '?' as i32 as libc::c_char;
                                                i_5 += 1;
                                            }
                                            let fresh437 = j_0;
                                            j_0 = j_0 + 1;
                                            *zSql_0
                                                .offset(fresh437 as isize) = ')' as i32 as libc::c_char;
                                            *zSql_0
                                                .offset(j_0 as isize) = 0 as libc::c_int as libc::c_char;
                                            if eVerbose >= 2 as libc::c_int {
                                                fprintf(
                                                    (*p).out,
                                                    b"Insert using: %s\n\0" as *const u8 as *const libc::c_char,
                                                    zSql_0,
                                                );
                                            }
                                            rc = sqlite3_prepare_v2(
                                                (*p).db,
                                                zSql_0,
                                                -(1 as libc::c_int),
                                                &mut pStmt_1,
                                                0 as *mut *const libc::c_char,
                                            );
                                            if rc != 0 {
                                                fprintf(
                                                    stderr,
                                                    b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                                                    sqlite3_errmsg((*p).db),
                                                );
                                                if !pStmt_1.is_null() {
                                                    sqlite3_finalize(pStmt_1);
                                                }
                                                current_block = 10900954862009114805;
                                            } else {
                                                sqlite3_free(zSql_0 as *mut libc::c_void);
                                                sqlite3_free(zFullTabName as *mut libc::c_void);
                                                needCommit = sqlite3_get_autocommit((*p).db);
                                                if needCommit != 0 {
                                                    sqlite3_exec(
                                                        (*p).db,
                                                        b"BEGIN\0" as *const u8 as *const libc::c_char,
                                                        None,
                                                        0 as *mut libc::c_void,
                                                        0 as *mut *mut libc::c_char,
                                                    );
                                                }
                                                loop {
                                                    let mut startLine: libc::c_int = sCtx.nLine;
                                                    i_5 = 0 as libc::c_int;
                                                    while i_5 < nCol {
                                                        let mut z_4: *mut libc::c_char = xRead
                                                            .expect("non-null function pointer")(&mut sCtx);
                                                        if z_4.is_null() && i_5 == 0 as libc::c_int {
                                                            break;
                                                        }
                                                        if (*p).mode == 10 as libc::c_int
                                                            && (z_4.is_null()
                                                                || *z_4.offset(0 as libc::c_int as isize) as libc::c_int
                                                                    == 0 as libc::c_int) && i_5 == 0 as libc::c_int
                                                        {
                                                            break;
                                                        }
                                                        sqlite3_bind_text(
                                                            pStmt_1,
                                                            i_5 + 1 as libc::c_int,
                                                            z_4,
                                                            -(1 as libc::c_int),
                                                            ::std::mem::transmute::<
                                                                libc::intptr_t,
                                                                sqlite3_destructor_type,
                                                            >(-(1 as libc::c_int) as libc::intptr_t),
                                                        );
                                                        if i_5 < nCol - 1 as libc::c_int
                                                            && sCtx.cTerm != sCtx.cColSep
                                                        {
                                                            fprintf(
                                                                stderr,
                                                                b"%s:%d: expected %d columns but found %d - filling the rest with NULL\n\0"
                                                                    as *const u8 as *const libc::c_char,
                                                                sCtx.zFile,
                                                                startLine,
                                                                nCol,
                                                                i_5 + 1 as libc::c_int,
                                                            );
                                                            i_5 += 2 as libc::c_int;
                                                            while i_5 <= nCol {
                                                                sqlite3_bind_null(pStmt_1, i_5);
                                                                i_5 += 1;
                                                            }
                                                        }
                                                        i_5 += 1;
                                                    }
                                                    if sCtx.cTerm == sCtx.cColSep {
                                                        loop {
                                                            xRead.expect("non-null function pointer")(&mut sCtx);
                                                            i_5 += 1;
                                                            if !(sCtx.cTerm == sCtx.cColSep) {
                                                                break;
                                                            }
                                                        }
                                                        fprintf(
                                                            stderr,
                                                            b"%s:%d: expected %d columns but found %d - extras ignored\n\0"
                                                                as *const u8 as *const libc::c_char,
                                                            sCtx.zFile,
                                                            startLine,
                                                            nCol,
                                                            i_5,
                                                        );
                                                    }
                                                    if i_5 >= nCol {
                                                        sqlite3_step(pStmt_1);
                                                        rc = sqlite3_reset(pStmt_1);
                                                        if rc != 0 as libc::c_int {
                                                            fprintf(
                                                                stderr,
                                                                b"%s:%d: INSERT failed: %s\n\0" as *const u8
                                                                    as *const libc::c_char,
                                                                sCtx.zFile,
                                                                startLine,
                                                                sqlite3_errmsg((*p).db),
                                                            );
                                                            sCtx.nErr += 1;
                                                        } else {
                                                            sCtx.nRow += 1;
                                                        }
                                                    }
                                                    if !(sCtx.cTerm != -(1 as libc::c_int)) {
                                                        break;
                                                    }
                                                }
                                                import_cleanup(&mut sCtx);
                                                sqlite3_finalize(pStmt_1);
                                                if needCommit != 0 {
                                                    sqlite3_exec(
                                                        (*p).db,
                                                        b"COMMIT\0" as *const u8 as *const libc::c_char,
                                                        None,
                                                        0 as *mut libc::c_void,
                                                        0 as *mut *mut libc::c_char,
                                                    );
                                                }
                                                if eVerbose > 0 as libc::c_int {
                                                    fprintf(
                                                        (*p).out,
                                                        b"Added %d rows with %d errors using %d lines of input\n\0"
                                                            as *const u8 as *const libc::c_char,
                                                        sCtx.nRow,
                                                        sCtx.nErr,
                                                        sCtx.nLine - 1 as libc::c_int,
                                                    );
                                                }
                                                current_block = 3081897820958806732;
                                            }
                                        }
                                    }
                                    _ => {}
                                }
                                match current_block {
                                    3081897820958806732 => {}
                                    _ => {
                                        sqlite3_free(zCreate as *mut libc::c_void);
                                        sqlite3_free(zSql_0 as *mut libc::c_void);
                                        sqlite3_free(zFullTabName as *mut libc::c_void);
                                        import_cleanup(&mut sCtx);
                                        rc = 1 as libc::c_int;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    } else if c == 'i' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"imposter\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut zSql_1: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut zCollist: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut pStmt_2: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        let mut tnum: libc::c_int = 0 as libc::c_int;
        let mut isWO: libc::c_int = 0 as libc::c_int;
        let mut lenPK: libc::c_int = 0 as libc::c_int;
        let mut i_6: libc::c_int = 0;
        if !(nArg == 3 as libc::c_int
            || nArg == 2 as libc::c_int
                && sqlite3_stricmp(
                    azArg[1 as libc::c_int as usize],
                    b"off\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int)
        {
            fprintf(
                stderr,
                b"Usage: .imposter INDEX IMPOSTER\n       .imposter off\n\0" as *const u8
                    as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        } else {
            open_db(p, 0 as libc::c_int);
            if nArg == 2 as libc::c_int {
                sqlite3_test_control(
                    25 as libc::c_int,
                    (*p).db,
                    b"main\0" as *const u8 as *const libc::c_char,
                    0 as libc::c_int,
                    1 as libc::c_int,
                );
            } else {
                zSql_1 = sqlite3_mprintf(
                    b"SELECT rootpage, 0 FROM sqlite_schema WHERE name='%q' AND type='index'UNION ALL SELECT rootpage, 1 FROM sqlite_schema WHERE name='%q' AND type='table'   AND sql LIKE '%%without%%rowid%%'\0"
                        as *const u8 as *const libc::c_char,
                    azArg[1 as libc::c_int as usize],
                    azArg[1 as libc::c_int as usize],
                );
                sqlite3_prepare_v2(
                    (*p).db,
                    zSql_1,
                    -(1 as libc::c_int),
                    &mut pStmt_2,
                    0 as *mut *const libc::c_char,
                );
                sqlite3_free(zSql_1 as *mut libc::c_void);
                if sqlite3_step(pStmt_2) == 100 as libc::c_int {
                    tnum = sqlite3_column_int(pStmt_2, 0 as libc::c_int);
                    isWO = sqlite3_column_int(pStmt_2, 1 as libc::c_int);
                }
                sqlite3_finalize(pStmt_2);
                zSql_1 = sqlite3_mprintf(
                    b"PRAGMA index_xinfo='%q'\0" as *const u8 as *const libc::c_char,
                    azArg[1 as libc::c_int as usize],
                );
                rc = sqlite3_prepare_v2(
                    (*p).db,
                    zSql_1,
                    -(1 as libc::c_int),
                    &mut pStmt_2,
                    0 as *mut *const libc::c_char,
                );
                sqlite3_free(zSql_1 as *mut libc::c_void);
                i_6 = 0 as libc::c_int;
                while rc == 0 as libc::c_int
                    && sqlite3_step(pStmt_2) == 100 as libc::c_int
                {
                    let mut zLabel: [libc::c_char; 20] = [0; 20];
                    let mut zCol: *const libc::c_char = sqlite3_column_text(
                        pStmt_2,
                        2 as libc::c_int,
                    ) as *const libc::c_char;
                    i_6 += 1;
                    if zCol.is_null() {
                        if sqlite3_column_int(pStmt_2, 1 as libc::c_int)
                            == -(1 as libc::c_int)
                        {
                            zCol = b"_ROWID_\0" as *const u8 as *const libc::c_char;
                        } else {
                            sqlite3_snprintf(
                                ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                                    as libc::c_int,
                                zLabel.as_mut_ptr(),
                                b"expr%d\0" as *const u8 as *const libc::c_char,
                                i_6,
                            );
                            zCol = zLabel.as_mut_ptr();
                        }
                    }
                    if isWO != 0 && lenPK == 0 as libc::c_int
                        && sqlite3_column_int(pStmt_2, 5 as libc::c_int)
                            == 0 as libc::c_int && !zCollist.is_null()
                    {
                        lenPK = strlen(zCollist) as libc::c_int;
                    }
                    if zCollist.is_null() {
                        zCollist = sqlite3_mprintf(
                            b"\"%w\"\0" as *const u8 as *const libc::c_char,
                            zCol,
                        );
                    } else {
                        zCollist = sqlite3_mprintf(
                            b"%z,\"%w\"\0" as *const u8 as *const libc::c_char,
                            zCollist,
                            zCol,
                        );
                    }
                }
                sqlite3_finalize(pStmt_2);
                if i_6 == 0 as libc::c_int || tnum == 0 as libc::c_int {
                    fprintf(
                        stderr,
                        b"no such index: \"%s\"\n\0" as *const u8 as *const libc::c_char,
                        azArg[1 as libc::c_int as usize],
                    );
                    rc = 1 as libc::c_int;
                    sqlite3_free(zCollist as *mut libc::c_void);
                } else {
                    if lenPK == 0 as libc::c_int {
                        lenPK = 100000 as libc::c_int;
                    }
                    zSql_1 = sqlite3_mprintf(
                        b"CREATE TABLE \"%w\"(%s,PRIMARY KEY(%.*s))WITHOUT ROWID\0"
                            as *const u8 as *const libc::c_char,
                        azArg[2 as libc::c_int as usize],
                        zCollist,
                        lenPK,
                        zCollist,
                    );
                    sqlite3_free(zCollist as *mut libc::c_void);
                    rc = sqlite3_test_control(
                        25 as libc::c_int,
                        (*p).db,
                        b"main\0" as *const u8 as *const libc::c_char,
                        1 as libc::c_int,
                        tnum,
                    );
                    if rc == 0 as libc::c_int {
                        rc = sqlite3_exec(
                            (*p).db,
                            zSql_1,
                            None,
                            0 as *mut libc::c_void,
                            0 as *mut *mut libc::c_char,
                        );
                        sqlite3_test_control(
                            25 as libc::c_int,
                            (*p).db,
                            b"main\0" as *const u8 as *const libc::c_char,
                            0 as libc::c_int,
                            0 as libc::c_int,
                        );
                        if rc != 0 {
                            fprintf(
                                stderr,
                                b"Error in [%s]: %s\n\0" as *const u8
                                    as *const libc::c_char,
                                zSql_1,
                                sqlite3_errmsg((*p).db),
                            );
                        } else {
                            fprintf(
                                stdout,
                                b"%s;\n\0" as *const u8 as *const libc::c_char,
                                zSql_1,
                            );
                            fprintf(
                                stdout,
                                b"WARNING: writing to an imposter table will corrupt the \"%s\" %s!\n\0"
                                    as *const u8 as *const libc::c_char,
                                azArg[1 as libc::c_int as usize],
                                if isWO != 0 {
                                    b"table\0" as *const u8 as *const libc::c_char
                                } else {
                                    b"index\0" as *const u8 as *const libc::c_char
                                },
                            );
                        }
                    } else {
                        fprintf(
                            stderr,
                            b"SQLITE_TESTCTRL_IMPOSTER returns %d\n\0" as *const u8
                                as *const libc::c_char,
                            rc,
                        );
                        rc = 1 as libc::c_int;
                    }
                    sqlite3_free(zSql_1 as *mut libc::c_void);
                }
            }
        }
    } else if c == 'l' as i32 && n >= 5 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"limits\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        static mut aLimit: [C2RustUnnamed_20; 12] = [
            {
                let mut init = C2RustUnnamed_20 {
                    zLimitName: b"length\0" as *const u8 as *const libc::c_char,
                    limitCode: 0 as libc::c_int,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_20 {
                    zLimitName: b"sql_length\0" as *const u8 as *const libc::c_char,
                    limitCode: 1 as libc::c_int,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_20 {
                    zLimitName: b"column\0" as *const u8 as *const libc::c_char,
                    limitCode: 2 as libc::c_int,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_20 {
                    zLimitName: b"expr_depth\0" as *const u8 as *const libc::c_char,
                    limitCode: 3 as libc::c_int,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_20 {
                    zLimitName: b"compound_select\0" as *const u8 as *const libc::c_char,
                    limitCode: 4 as libc::c_int,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_20 {
                    zLimitName: b"vdbe_op\0" as *const u8 as *const libc::c_char,
                    limitCode: 5 as libc::c_int,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_20 {
                    zLimitName: b"function_arg\0" as *const u8 as *const libc::c_char,
                    limitCode: 6 as libc::c_int,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_20 {
                    zLimitName: b"attached\0" as *const u8 as *const libc::c_char,
                    limitCode: 7 as libc::c_int,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_20 {
                    zLimitName: b"like_pattern_length\0" as *const u8
                        as *const libc::c_char,
                    limitCode: 8 as libc::c_int,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_20 {
                    zLimitName: b"variable_number\0" as *const u8 as *const libc::c_char,
                    limitCode: 9 as libc::c_int,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_20 {
                    zLimitName: b"trigger_depth\0" as *const u8 as *const libc::c_char,
                    limitCode: 10 as libc::c_int,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_20 {
                    zLimitName: b"worker_threads\0" as *const u8 as *const libc::c_char,
                    limitCode: 11 as libc::c_int,
                };
                init
            },
        ];
        let mut i_7: libc::c_int = 0;
        let mut n2_0: libc::c_int = 0;
        open_db(p, 0 as libc::c_int);
        if nArg == 1 as libc::c_int {
            i_7 = 0 as libc::c_int;
            while i_7
                < (::std::mem::size_of::<[C2RustUnnamed_20; 12]>() as libc::c_ulong)
                    .wrapping_div(
                        ::std::mem::size_of::<C2RustUnnamed_20>() as libc::c_ulong,
                    ) as libc::c_int
            {
                printf(
                    b"%20s %d\n\0" as *const u8 as *const libc::c_char,
                    aLimit[i_7 as usize].zLimitName,
                    sqlite3_limit(
                        (*p).db,
                        aLimit[i_7 as usize].limitCode,
                        -(1 as libc::c_int),
                    ),
                );
                i_7 += 1;
            }
        } else if nArg > 3 as libc::c_int {
            fprintf(
                stderr,
                b"Usage: .limit NAME ?NEW-VALUE?\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        } else {
            let mut iLimit: libc::c_int = -(1 as libc::c_int);
            n2_0 = strlen30(azArg[1 as libc::c_int as usize]);
            i_7 = 0 as libc::c_int;
            loop {
                if !(i_7
                    < (::std::mem::size_of::<[C2RustUnnamed_20; 12]>() as libc::c_ulong)
                        .wrapping_div(
                            ::std::mem::size_of::<C2RustUnnamed_20>() as libc::c_ulong,
                        ) as libc::c_int)
                {
                    current_block = 10955169882855457607;
                    break;
                }
                if sqlite3_strnicmp(
                    aLimit[i_7 as usize].zLimitName,
                    azArg[1 as libc::c_int as usize],
                    n2_0,
                ) == 0 as libc::c_int
                {
                    if iLimit < 0 as libc::c_int {
                        iLimit = i_7;
                    } else {
                        fprintf(
                            stderr,
                            b"ambiguous limit: \"%s\"\n\0" as *const u8
                                as *const libc::c_char,
                            azArg[1 as libc::c_int as usize],
                        );
                        rc = 1 as libc::c_int;
                        current_block = 3081897820958806732;
                        break;
                    }
                }
                i_7 += 1;
            }
            match current_block {
                3081897820958806732 => {}
                _ => {
                    if iLimit < 0 as libc::c_int {
                        fprintf(
                            stderr,
                            b"unknown limit: \"%s\"\nenter \".limits\" with no arguments for a list.\n\0"
                                as *const u8 as *const libc::c_char,
                            azArg[1 as libc::c_int as usize],
                        );
                        rc = 1 as libc::c_int;
                    } else {
                        if nArg == 3 as libc::c_int {
                            sqlite3_limit(
                                (*p).db,
                                aLimit[iLimit as usize].limitCode,
                                integerValue(azArg[2 as libc::c_int as usize])
                                    as libc::c_int,
                            );
                        }
                        printf(
                            b"%20s %d\n\0" as *const u8 as *const libc::c_char,
                            aLimit[iLimit as usize].zLimitName,
                            sqlite3_limit(
                                (*p).db,
                                aLimit[iLimit as usize].limitCode,
                                -(1 as libc::c_int),
                            ),
                        );
                    }
                }
            }
        }
    } else if c == 'l' as i32 && n > 2 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"lint\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        open_db(p, 0 as libc::c_int);
        lintDotCommand(p, azArg.as_mut_ptr(), nArg);
    } else if c == 'l' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"load\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut zFile_2: *const libc::c_char = 0 as *const libc::c_char;
        let mut zProc: *const libc::c_char = 0 as *const libc::c_char;
        let mut zErrMsg: *mut libc::c_char = 0 as *mut libc::c_char;
        failIfSafeMode(
            p,
            b"cannot run .load in safe mode\0" as *const u8 as *const libc::c_char,
        );
        if nArg < 2 as libc::c_int {
            fprintf(
                stderr,
                b"Usage: .load FILE ?ENTRYPOINT?\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        } else {
            zFile_2 = azArg[1 as libc::c_int as usize];
            zProc = if nArg >= 3 as libc::c_int {
                azArg[2 as libc::c_int as usize]
            } else {
                0 as *mut libc::c_char
            };
            open_db(p, 0 as libc::c_int);
            rc = sqlite3_load_extension((*p).db, zFile_2, zProc, &mut zErrMsg);
            if rc != 0 as libc::c_int {
                fprintf(
                    stderr,
                    b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                    zErrMsg,
                );
                sqlite3_free(zErrMsg as *mut libc::c_void);
                rc = 1 as libc::c_int;
            }
        }
    } else if c == 'l' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"log\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        failIfSafeMode(
            p,
            b"cannot run .log in safe mode\0" as *const u8 as *const libc::c_char,
        );
        if nArg != 2 as libc::c_int {
            fprintf(
                stderr,
                b"Usage: .log FILENAME\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        } else {
            let mut zFile_3: *const libc::c_char = azArg[1 as libc::c_int as usize];
            output_file_close((*p).pLog);
            let ref mut fresh438 = (*p).pLog;
            *fresh438 = output_file_open(zFile_3, 0 as libc::c_int);
        }
    } else if c == 'm' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"mode\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut zMode: *const libc::c_char = 0 as *const libc::c_char;
        let mut zTabname: *const libc::c_char = 0 as *const libc::c_char;
        let mut i_8: libc::c_int = 0;
        let mut n2_1: libc::c_int = 0;
        let mut cmOpts: ColModeOpts = {
            let mut init = ColModeOpts {
                iWrap: 60 as libc::c_int,
                bQuote: 0 as libc::c_int as u8_0,
                bWordWrap: 0 as libc::c_int as u8_0,
            };
            init
        };
        i_8 = 1 as libc::c_int;
        loop {
            if !(i_8 < nArg) {
                current_block = 15635364688470452832;
                break;
            }
            let mut z_5: *const libc::c_char = azArg[i_8 as usize];
            if optionMatch(z_5, b"wrap\0" as *const u8 as *const libc::c_char) != 0
                && (i_8 + 1 as libc::c_int) < nArg
            {
                i_8 += 1;
                cmOpts.iWrap = integerValue(azArg[i_8 as usize]) as libc::c_int;
            } else if optionMatch(z_5, b"ww\0" as *const u8 as *const libc::c_char) != 0
            {
                cmOpts.bWordWrap = 1 as libc::c_int as u8_0;
            } else if optionMatch(z_5, b"wordwrap\0" as *const u8 as *const libc::c_char)
                != 0 && (i_8 + 1 as libc::c_int) < nArg
            {
                i_8 += 1;
                cmOpts.bWordWrap = booleanValue(azArg[i_8 as usize]) as u8_0;
            } else if optionMatch(z_5, b"quote\0" as *const u8 as *const libc::c_char)
                != 0
            {
                cmOpts.bQuote = 1 as libc::c_int as u8_0;
            } else if optionMatch(z_5, b"noquote\0" as *const u8 as *const libc::c_char)
                != 0
            {
                cmOpts.bQuote = 0 as libc::c_int as u8_0;
            } else if zMode.is_null() {
                zMode = z_5;
                if cli_strcmp(z_5, b"qbox\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    let mut cmo: ColModeOpts = {
                        let mut init = ColModeOpts {
                            iWrap: 60 as libc::c_int,
                            bQuote: 1 as libc::c_int as u8_0,
                            bWordWrap: 0 as libc::c_int as u8_0,
                        };
                        init
                    };
                    zMode = b"box\0" as *const u8 as *const libc::c_char;
                    cmOpts = cmo;
                }
            } else if zTabname.is_null() {
                zTabname = z_5;
            } else if *z_5.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
            {
                fprintf(
                    stderr,
                    b"unknown option: %s\n\0" as *const u8 as *const libc::c_char,
                    z_5,
                );
                fprintf(
                    stderr,
                    b"options:\n  --noquote\n  --quote\n  --wordwrap on/off\n  --wrap N\n  --ww\n\0"
                        as *const u8 as *const libc::c_char,
                );
                rc = 1 as libc::c_int;
                current_block = 3081897820958806732;
                break;
            } else {
                fprintf(
                    stderr,
                    b"extra argument: \"%s\"\n\0" as *const u8 as *const libc::c_char,
                    z_5,
                );
                rc = 1 as libc::c_int;
                current_block = 3081897820958806732;
                break;
            }
            i_8 += 1;
        }
        match current_block {
            3081897820958806732 => {}
            _ => {
                if zMode.is_null() {
                    if (*p).mode == 1 as libc::c_int
                        || (*p).mode >= 14 as libc::c_int
                            && (*p).mode <= 16 as libc::c_int
                    {
                        fprintf(
                            (*p).out,
                            b"current output mode: %s --wrap %d --wordwrap %s --%squote\n\0"
                                as *const u8 as *const libc::c_char,
                            modeDescr[(*p).mode as usize],
                            (*p).cmOpts.iWrap,
                            if (*p).cmOpts.bWordWrap as libc::c_int != 0 {
                                b"on\0" as *const u8 as *const libc::c_char
                            } else {
                                b"off\0" as *const u8 as *const libc::c_char
                            },
                            if (*p).cmOpts.bQuote as libc::c_int != 0 {
                                b"\0" as *const u8 as *const libc::c_char
                            } else {
                                b"no\0" as *const u8 as *const libc::c_char
                            },
                        );
                    } else {
                        fprintf(
                            (*p).out,
                            b"current output mode: %s\n\0" as *const u8
                                as *const libc::c_char,
                            modeDescr[(*p).mode as usize],
                        );
                    }
                    zMode = modeDescr[(*p).mode as usize];
                }
                n2_1 = strlen30(zMode);
                if cli_strncmp(
                    zMode,
                    b"lines\0" as *const u8 as *const libc::c_char,
                    n2_1 as size_t,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 0 as libc::c_int;
                    sqlite3_snprintf(
                        ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).rowSeparator).as_mut_ptr(),
                        b"\n\0" as *const u8 as *const libc::c_char,
                    );
                } else if cli_strncmp(
                    zMode,
                    b"columns\0" as *const u8 as *const libc::c_char,
                    n2_1 as size_t,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 1 as libc::c_int;
                    if (*p).shellFlgs & 0x80 as libc::c_int as libc::c_uint
                        == 0 as libc::c_int as libc::c_uint
                    {
                        (*p).showHeader = 1 as libc::c_int;
                    }
                    sqlite3_snprintf(
                        ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).rowSeparator).as_mut_ptr(),
                        b"\n\0" as *const u8 as *const libc::c_char,
                    );
                    (*p).cmOpts = cmOpts;
                } else if cli_strncmp(
                    zMode,
                    b"list\0" as *const u8 as *const libc::c_char,
                    n2_1 as size_t,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 2 as libc::c_int;
                    sqlite3_snprintf(
                        ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).colSeparator).as_mut_ptr(),
                        b"|\0" as *const u8 as *const libc::c_char,
                    );
                    sqlite3_snprintf(
                        ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).rowSeparator).as_mut_ptr(),
                        b"\n\0" as *const u8 as *const libc::c_char,
                    );
                } else if cli_strncmp(
                    zMode,
                    b"html\0" as *const u8 as *const libc::c_char,
                    n2_1 as size_t,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 4 as libc::c_int;
                } else if cli_strncmp(
                    zMode,
                    b"tcl\0" as *const u8 as *const libc::c_char,
                    n2_1 as size_t,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 7 as libc::c_int;
                    sqlite3_snprintf(
                        ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).colSeparator).as_mut_ptr(),
                        b" \0" as *const u8 as *const libc::c_char,
                    );
                    sqlite3_snprintf(
                        ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).rowSeparator).as_mut_ptr(),
                        b"\n\0" as *const u8 as *const libc::c_char,
                    );
                } else if cli_strncmp(
                    zMode,
                    b"csv\0" as *const u8 as *const libc::c_char,
                    n2_1 as size_t,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 8 as libc::c_int;
                    sqlite3_snprintf(
                        ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).colSeparator).as_mut_ptr(),
                        b",\0" as *const u8 as *const libc::c_char,
                    );
                    sqlite3_snprintf(
                        ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).rowSeparator).as_mut_ptr(),
                        b"\r\n\0" as *const u8 as *const libc::c_char,
                    );
                } else if cli_strncmp(
                    zMode,
                    b"tabs\0" as *const u8 as *const libc::c_char,
                    n2_1 as size_t,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 2 as libc::c_int;
                    sqlite3_snprintf(
                        ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).colSeparator).as_mut_ptr(),
                        b"\t\0" as *const u8 as *const libc::c_char,
                    );
                } else if cli_strncmp(
                    zMode,
                    b"insert\0" as *const u8 as *const libc::c_char,
                    n2_1 as size_t,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 5 as libc::c_int;
                    set_table_name(
                        p,
                        if !zTabname.is_null() {
                            zTabname
                        } else {
                            b"table\0" as *const u8 as *const libc::c_char
                        },
                    );
                } else if cli_strncmp(
                    zMode,
                    b"quote\0" as *const u8 as *const libc::c_char,
                    n2_1 as size_t,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 6 as libc::c_int;
                    sqlite3_snprintf(
                        ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).colSeparator).as_mut_ptr(),
                        b",\0" as *const u8 as *const libc::c_char,
                    );
                    sqlite3_snprintf(
                        ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).rowSeparator).as_mut_ptr(),
                        b"\n\0" as *const u8 as *const libc::c_char,
                    );
                } else if cli_strncmp(
                    zMode,
                    b"ascii\0" as *const u8 as *const libc::c_char,
                    n2_1 as size_t,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 10 as libc::c_int;
                    sqlite3_snprintf(
                        ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).colSeparator).as_mut_ptr(),
                        b"\x1F\0" as *const u8 as *const libc::c_char,
                    );
                    sqlite3_snprintf(
                        ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).rowSeparator).as_mut_ptr(),
                        b"\x1E\0" as *const u8 as *const libc::c_char,
                    );
                } else if cli_strncmp(
                    zMode,
                    b"markdown\0" as *const u8 as *const libc::c_char,
                    n2_1 as size_t,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 14 as libc::c_int;
                    (*p).cmOpts = cmOpts;
                } else if cli_strncmp(
                    zMode,
                    b"table\0" as *const u8 as *const libc::c_char,
                    n2_1 as size_t,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 15 as libc::c_int;
                    (*p).cmOpts = cmOpts;
                } else if cli_strncmp(
                    zMode,
                    b"box\0" as *const u8 as *const libc::c_char,
                    n2_1 as size_t,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 16 as libc::c_int;
                    (*p).cmOpts = cmOpts;
                } else if cli_strncmp(
                    zMode,
                    b"count\0" as *const u8 as *const libc::c_char,
                    n2_1 as size_t,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 17 as libc::c_int;
                } else if cli_strncmp(
                    zMode,
                    b"off\0" as *const u8 as *const libc::c_char,
                    n2_1 as size_t,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 18 as libc::c_int;
                } else if cli_strncmp(
                    zMode,
                    b"json\0" as *const u8 as *const libc::c_char,
                    n2_1 as size_t,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 13 as libc::c_int;
                } else {
                    fprintf(
                        stderr,
                        b"Error: mode should be one of: ascii box column csv html insert json line list markdown qbox quote table tabs tcl\n\0"
                            as *const u8 as *const libc::c_char,
                    );
                    rc = 1 as libc::c_int;
                }
                (*p).cMode = (*p).mode;
            }
        }
    } else if c == 'n' as i32
        && cli_strcmp(
            azArg[0 as libc::c_int as usize],
            b"nonce\0" as *const u8 as *const libc::c_char,
        ) == 0 as libc::c_int
    {
        if nArg != 2 as libc::c_int {
            fprintf(
                stderr,
                b"Usage: .nonce NONCE\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        } else if ((*p).zNonce).is_null()
            || cli_strcmp(azArg[1 as libc::c_int as usize], (*p).zNonce)
                != 0 as libc::c_int
        {
            fprintf(
                stderr,
                b"line %d: incorrect nonce: \"%s\"\n\0" as *const u8
                    as *const libc::c_char,
                (*p).lineno,
                azArg[1 as libc::c_int as usize],
            );
            exit(1 as libc::c_int);
        } else {
            (*p).bSafeMode = 0 as libc::c_int as u8_0;
            return 0 as libc::c_int;
        }
    } else if c == 'n' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"nullvalue\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        if nArg == 2 as libc::c_int {
            sqlite3_snprintf(
                ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                    as libc::c_int,
                ((*p).nullValue).as_mut_ptr(),
                b"%.*s\0" as *const u8 as *const libc::c_char,
                (::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                    .wrapping_div(::std::mem::size_of::<libc::c_char>() as libc::c_ulong)
                    as libc::c_int - 1 as libc::c_int,
                azArg[1 as libc::c_int as usize],
            );
        } else {
            fprintf(
                stderr,
                b"Usage: .nullvalue STRING\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 'o' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"open\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int && n >= 2 as libc::c_int
    {
        let mut zFN: *const libc::c_char = 0 as *const libc::c_char;
        let mut zNewFilename: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut iName: libc::c_int = 1 as libc::c_int;
        let mut newFlag: libc::c_int = 0 as libc::c_int;
        let mut openMode: libc::c_int = 0 as libc::c_int;
        iName = 1 as libc::c_int;
        loop {
            if !(iName < nArg) {
                current_block = 11975283866081141102;
                break;
            }
            let mut z_6: *const libc::c_char = azArg[iName as usize];
            if optionMatch(z_6, b"new\0" as *const u8 as *const libc::c_char) != 0 {
                newFlag = 1 as libc::c_int;
            } else if optionMatch(z_6, b"zip\0" as *const u8 as *const libc::c_char) != 0
            {
                openMode = 3 as libc::c_int;
            } else if optionMatch(z_6, b"append\0" as *const u8 as *const libc::c_char)
                != 0
            {
                openMode = 2 as libc::c_int;
            } else if optionMatch(z_6, b"readonly\0" as *const u8 as *const libc::c_char)
                != 0
            {
                openMode = 4 as libc::c_int;
            } else if optionMatch(z_6, b"nofollow\0" as *const u8 as *const libc::c_char)
                != 0
            {
                (*p).openFlags |= 0x1000000 as libc::c_int;
            } else if optionMatch(
                z_6,
                b"deserialize\0" as *const u8 as *const libc::c_char,
            ) != 0
            {
                openMode = 5 as libc::c_int;
            } else if optionMatch(z_6, b"hexdb\0" as *const u8 as *const libc::c_char)
                != 0
            {
                openMode = 6 as libc::c_int;
            } else if optionMatch(z_6, b"maxsize\0" as *const u8 as *const libc::c_char)
                != 0 && (iName + 1 as libc::c_int) < nArg
            {
                iName += 1;
                (*p).szMax = integerValue(azArg[iName as usize]);
            } else if *z_6.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
            {
                fprintf(
                    stderr,
                    b"unknown option: %s\n\0" as *const u8 as *const libc::c_char,
                    z_6,
                );
                rc = 1 as libc::c_int;
                current_block = 3081897820958806732;
                break;
            } else if !zFN.is_null() {
                fprintf(
                    stderr,
                    b"extra argument: \"%s\"\n\0" as *const u8 as *const libc::c_char,
                    z_6,
                );
                rc = 1 as libc::c_int;
                current_block = 3081897820958806732;
                break;
            } else {
                zFN = z_6;
            }
            iName += 1;
        }
        match current_block {
            3081897820958806732 => {}
            _ => {
                close_db((*p).db);
                let ref mut fresh439 = (*p).db;
                *fresh439 = 0 as *mut sqlite3;
                let ref mut fresh440 = (*(*p).pAuxDb).zDbFilename;
                *fresh440 = 0 as *const libc::c_char;
                sqlite3_free((*(*p).pAuxDb).zFreeOnClose as *mut libc::c_void);
                let ref mut fresh441 = (*(*p).pAuxDb).zFreeOnClose;
                *fresh441 = 0 as *mut libc::c_char;
                (*p).openMode = openMode as u8_0;
                (*p).openFlags = 0 as libc::c_int;
                (*p).szMax = 0 as libc::c_int as sqlite3_int64;
                if !zFN.is_null() || (*p).openMode as libc::c_int == 6 as libc::c_int {
                    if newFlag != 0 && !zFN.is_null() && (*p).bSafeMode == 0 {
                        shellDeleteFile(zFN);
                    }
                    if (*p).bSafeMode as libc::c_int != 0
                        && (*p).openMode as libc::c_int != 6 as libc::c_int
                        && !zFN.is_null()
                        && cli_strcmp(
                            zFN,
                            b":memory:\0" as *const u8 as *const libc::c_char,
                        ) != 0 as libc::c_int
                    {
                        failIfSafeMode(
                            p,
                            b"cannot open disk-based database files in safe mode\0"
                                as *const u8 as *const libc::c_char,
                        );
                    }
                    if !zFN.is_null() {
                        zNewFilename = sqlite3_mprintf(
                            b"%s\0" as *const u8 as *const libc::c_char,
                            zFN,
                        );
                        shell_check_oom(zNewFilename as *mut libc::c_void);
                    } else {
                        zNewFilename = 0 as *mut libc::c_char;
                    }
                    let ref mut fresh442 = (*(*p).pAuxDb).zDbFilename;
                    *fresh442 = zNewFilename;
                    open_db(p, 0x1 as libc::c_int);
                    if ((*p).db).is_null() {
                        fprintf(
                            stderr,
                            b"Error: cannot open '%s'\n\0" as *const u8
                                as *const libc::c_char,
                            zNewFilename,
                        );
                        sqlite3_free(zNewFilename as *mut libc::c_void);
                    } else {
                        let ref mut fresh443 = (*(*p).pAuxDb).zFreeOnClose;
                        *fresh443 = zNewFilename;
                    }
                }
                if ((*p).db).is_null() {
                    let ref mut fresh444 = (*(*p).pAuxDb).zDbFilename;
                    *fresh444 = 0 as *const libc::c_char;
                    open_db(p, 0 as libc::c_int);
                }
            }
        }
    } else if c == 'o' as i32
        && (cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"output\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
            || cli_strncmp(
                azArg[0 as libc::c_int as usize],
                b"once\0" as *const u8 as *const libc::c_char,
                n as size_t,
            ) == 0 as libc::c_int)
        || c == 'e' as i32 && n == 5 as libc::c_int
            && cli_strcmp(
                azArg[0 as libc::c_int as usize],
                b"excel\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
    {
        let mut zFile_4: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut bTxtMode: libc::c_int = 0 as libc::c_int;
        let mut i_9: libc::c_int = 0;
        let mut eMode: libc::c_int = 0 as libc::c_int;
        let mut bOnce: libc::c_int = 0 as libc::c_int;
        let mut zBOM: [libc::c_uchar; 4] = [0; 4];
        zBOM[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_uchar;
        failIfSafeMode(
            p,
            b"cannot run .%s in safe mode\0" as *const u8 as *const libc::c_char,
            azArg[0 as libc::c_int as usize],
        );
        if c == 'e' as i32 {
            eMode = 'x' as i32;
            bOnce = 2 as libc::c_int;
        } else if cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"once\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
        {
            bOnce = 1 as libc::c_int;
        }
        i_9 = 1 as libc::c_int;
        loop {
            if !(i_9 < nArg) {
                current_block = 5046807210318655509;
                break;
            }
            let mut z_7: *mut libc::c_char = azArg[i_9 as usize];
            if *z_7.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                if *z_7.offset(1 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                    z_7 = z_7.offset(1);
                }
                if cli_strcmp(z_7, b"-bom\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    zBOM[0 as libc::c_int
                        as usize] = 0xef as libc::c_int as libc::c_uchar;
                    zBOM[1 as libc::c_int
                        as usize] = 0xbb as libc::c_int as libc::c_uchar;
                    zBOM[2 as libc::c_int
                        as usize] = 0xbf as libc::c_int as libc::c_uchar;
                    zBOM[3 as libc::c_int as usize] = 0 as libc::c_int as libc::c_uchar;
                } else if c != 'e' as i32
                    && cli_strcmp(z_7, b"-x\0" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                {
                    eMode = 'x' as i32;
                } else if c != 'e' as i32
                    && cli_strcmp(z_7, b"-e\0" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                {
                    eMode = 'e' as i32;
                } else {
                    fprintf(
                        (*p).out,
                        b"ERROR: unknown option: \"%s\".  Usage:\n\0" as *const u8
                            as *const libc::c_char,
                        azArg[i_9 as usize],
                    );
                    showHelp((*p).out, azArg[0 as libc::c_int as usize]);
                    rc = 1 as libc::c_int;
                    current_block = 3081897820958806732;
                    break;
                }
            } else if zFile_4.is_null() && eMode != 'e' as i32 && eMode != 'x' as i32 {
                zFile_4 = sqlite3_mprintf(
                    b"%s\0" as *const u8 as *const libc::c_char,
                    z_7,
                );
                if !zFile_4.is_null()
                    && *zFile_4.offset(0 as libc::c_int as isize) as libc::c_int
                        == '|' as i32
                {
                    while (i_9 + 1 as libc::c_int) < nArg {
                        i_9 += 1;
                        zFile_4 = sqlite3_mprintf(
                            b"%z %s\0" as *const u8 as *const libc::c_char,
                            zFile_4,
                            azArg[i_9 as usize],
                        );
                    }
                    current_block = 5046807210318655509;
                    break;
                }
            } else {
                fprintf(
                    (*p).out,
                    b"ERROR: extra parameter: \"%s\".  Usage:\n\0" as *const u8
                        as *const libc::c_char,
                    azArg[i_9 as usize],
                );
                showHelp((*p).out, azArg[0 as libc::c_int as usize]);
                rc = 1 as libc::c_int;
                sqlite3_free(zFile_4 as *mut libc::c_void);
                current_block = 3081897820958806732;
                break;
            }
            i_9 += 1;
        }
        match current_block {
            3081897820958806732 => {}
            _ => {
                if zFile_4.is_null() {
                    zFile_4 = sqlite3_mprintf(
                        b"stdout\0" as *const u8 as *const libc::c_char,
                    );
                }
                if bOnce != 0 {
                    (*p).outCount = 2 as libc::c_int;
                } else {
                    (*p).outCount = 0 as libc::c_int;
                }
                output_reset(p);
                if eMode == 'e' as i32 || eMode == 'x' as i32 {
                    (*p).doXdgOpen = 1 as libc::c_int as u8_0;
                    outputModePush(p);
                    if eMode == 'x' as i32 {
                        newTempFile(p, b"csv\0" as *const u8 as *const libc::c_char);
                        (*p).shellFlgs &= !(0x40 as libc::c_int) as libc::c_uint;
                        (*p).mode = 8 as libc::c_int;
                        sqlite3_snprintf(
                            ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                                as libc::c_int,
                            ((*p).colSeparator).as_mut_ptr(),
                            b",\0" as *const u8 as *const libc::c_char,
                        );
                        sqlite3_snprintf(
                            ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                                as libc::c_int,
                            ((*p).rowSeparator).as_mut_ptr(),
                            b"\r\n\0" as *const u8 as *const libc::c_char,
                        );
                    } else {
                        newTempFile(p, b"txt\0" as *const u8 as *const libc::c_char);
                        bTxtMode = 1 as libc::c_int;
                    }
                    sqlite3_free(zFile_4 as *mut libc::c_void);
                    zFile_4 = sqlite3_mprintf(
                        b"%s\0" as *const u8 as *const libc::c_char,
                        (*p).zTempFile,
                    );
                }
                shell_check_oom(zFile_4 as *mut libc::c_void);
                if *zFile_4.offset(0 as libc::c_int as isize) as libc::c_int
                    == '|' as i32
                {
                    let ref mut fresh445 = (*p).out;
                    *fresh445 = popen(
                        zFile_4.offset(1 as libc::c_int as isize),
                        b"w\0" as *const u8 as *const libc::c_char,
                    );
                    if ((*p).out).is_null() {
                        fprintf(
                            stderr,
                            b"Error: cannot open pipe \"%s\"\n\0" as *const u8
                                as *const libc::c_char,
                            zFile_4.offset(1 as libc::c_int as isize),
                        );
                        let ref mut fresh446 = (*p).out;
                        *fresh446 = stdout;
                        rc = 1 as libc::c_int;
                    } else {
                        if zBOM[0 as libc::c_int as usize] != 0 {
                            fwrite(
                                zBOM.as_mut_ptr() as *const libc::c_void,
                                1 as libc::c_int as libc::c_ulong,
                                3 as libc::c_int as libc::c_ulong,
                                (*p).out,
                            );
                        }
                        sqlite3_snprintf(
                            ::std::mem::size_of::<[libc::c_char; 4096]>()
                                as libc::c_ulong as libc::c_int,
                            ((*p).outfile).as_mut_ptr(),
                            b"%s\0" as *const u8 as *const libc::c_char,
                            zFile_4,
                        );
                    }
                } else {
                    let ref mut fresh447 = (*p).out;
                    *fresh447 = output_file_open(zFile_4, bTxtMode);
                    if ((*p).out).is_null() {
                        if cli_strcmp(
                            zFile_4,
                            b"off\0" as *const u8 as *const libc::c_char,
                        ) != 0 as libc::c_int
                        {
                            fprintf(
                                stderr,
                                b"Error: cannot write to \"%s\"\n\0" as *const u8
                                    as *const libc::c_char,
                                zFile_4,
                            );
                        }
                        let ref mut fresh448 = (*p).out;
                        *fresh448 = stdout;
                        rc = 1 as libc::c_int;
                    } else {
                        if zBOM[0 as libc::c_int as usize] != 0 {
                            fwrite(
                                zBOM.as_mut_ptr() as *const libc::c_void,
                                1 as libc::c_int as libc::c_ulong,
                                3 as libc::c_int as libc::c_ulong,
                                (*p).out,
                            );
                        }
                        sqlite3_snprintf(
                            ::std::mem::size_of::<[libc::c_char; 4096]>()
                                as libc::c_ulong as libc::c_int,
                            ((*p).outfile).as_mut_ptr(),
                            b"%s\0" as *const u8 as *const libc::c_char,
                            zFile_4,
                        );
                    }
                }
                sqlite3_free(zFile_4 as *mut libc::c_void);
            }
        }
    } else if c == 'p' as i32 && n >= 3 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"parameter\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut current_block_1090: u64;
        open_db(p, 0 as libc::c_int);
        if nArg <= 1 as libc::c_int {
            current_block_1090 = 16458017167451600258;
        } else if nArg == 2 as libc::c_int
            && cli_strcmp(
                azArg[1 as libc::c_int as usize],
                b"clear\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
        {
            sqlite3_exec(
                (*p).db,
                b"DROP TABLE IF EXISTS temp.sqlite_parameters;\0" as *const u8
                    as *const libc::c_char,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
            current_block_1090 = 10465632374337877116;
        } else if nArg == 2 as libc::c_int
            && cli_strcmp(
                azArg[1 as libc::c_int as usize],
                b"list\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
        {
            let mut pStmt_3: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
            let mut rx: libc::c_int = 0;
            let mut len: libc::c_int = 0 as libc::c_int;
            rx = sqlite3_prepare_v2(
                (*p).db,
                b"SELECT max(length(key)) FROM temp.sqlite_parameters;\0" as *const u8
                    as *const libc::c_char,
                -(1 as libc::c_int),
                &mut pStmt_3,
                0 as *mut *const libc::c_char,
            );
            if rx == 0 as libc::c_int && sqlite3_step(pStmt_3) == 100 as libc::c_int {
                len = sqlite3_column_int(pStmt_3, 0 as libc::c_int);
                if len > 40 as libc::c_int {
                    len = 40 as libc::c_int;
                }
            }
            sqlite3_finalize(pStmt_3);
            pStmt_3 = 0 as *mut sqlite3_stmt;
            if len != 0 {
                rx = sqlite3_prepare_v2(
                    (*p).db,
                    b"SELECT key, quote(value) FROM temp.sqlite_parameters;\0"
                        as *const u8 as *const libc::c_char,
                    -(1 as libc::c_int),
                    &mut pStmt_3,
                    0 as *mut *const libc::c_char,
                );
                while rx == 0 as libc::c_int
                    && sqlite3_step(pStmt_3) == 100 as libc::c_int
                {
                    fprintf(
                        (*p).out,
                        b"%-*s %s\n\0" as *const u8 as *const libc::c_char,
                        len,
                        sqlite3_column_text(pStmt_3, 0 as libc::c_int),
                        sqlite3_column_text(pStmt_3, 1 as libc::c_int),
                    );
                }
                sqlite3_finalize(pStmt_3);
            }
            current_block_1090 = 10465632374337877116;
        } else if nArg == 2 as libc::c_int
            && cli_strcmp(
                azArg[1 as libc::c_int as usize],
                b"init\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
        {
            bind_table_init(p);
            current_block_1090 = 10465632374337877116;
        } else if nArg == 4 as libc::c_int
            && cli_strcmp(
                azArg[1 as libc::c_int as usize],
                b"set\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
        {
            let mut rx_0: libc::c_int = 0;
            let mut zSql_2: *mut libc::c_char = 0 as *mut libc::c_char;
            let mut pStmt_4: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
            let mut zKey: *const libc::c_char = azArg[2 as libc::c_int as usize];
            let mut zValue: *const libc::c_char = azArg[3 as libc::c_int as usize];
            bind_table_init(p);
            zSql_2 = sqlite3_mprintf(
                b"REPLACE INTO temp.sqlite_parameters(key,value)VALUES(%Q,%s);\0"
                    as *const u8 as *const libc::c_char,
                zKey,
                zValue,
            );
            shell_check_oom(zSql_2 as *mut libc::c_void);
            pStmt_4 = 0 as *mut sqlite3_stmt;
            rx_0 = sqlite3_prepare_v2(
                (*p).db,
                zSql_2,
                -(1 as libc::c_int),
                &mut pStmt_4,
                0 as *mut *const libc::c_char,
            );
            sqlite3_free(zSql_2 as *mut libc::c_void);
            if rx_0 != 0 as libc::c_int {
                sqlite3_finalize(pStmt_4);
                pStmt_4 = 0 as *mut sqlite3_stmt;
                zSql_2 = sqlite3_mprintf(
                    b"REPLACE INTO temp.sqlite_parameters(key,value)VALUES(%Q,%Q);\0"
                        as *const u8 as *const libc::c_char,
                    zKey,
                    zValue,
                );
                shell_check_oom(zSql_2 as *mut libc::c_void);
                rx_0 = sqlite3_prepare_v2(
                    (*p).db,
                    zSql_2,
                    -(1 as libc::c_int),
                    &mut pStmt_4,
                    0 as *mut *const libc::c_char,
                );
                sqlite3_free(zSql_2 as *mut libc::c_void);
                if rx_0 != 0 as libc::c_int {
                    fprintf(
                        (*p).out,
                        b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                        sqlite3_errmsg((*p).db),
                    );
                    sqlite3_finalize(pStmt_4);
                    pStmt_4 = 0 as *mut sqlite3_stmt;
                    rc = 1 as libc::c_int;
                }
            }
            sqlite3_step(pStmt_4);
            sqlite3_finalize(pStmt_4);
            current_block_1090 = 10465632374337877116;
        } else if nArg == 3 as libc::c_int
            && cli_strcmp(
                azArg[1 as libc::c_int as usize],
                b"unset\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
        {
            let mut zSql_3: *mut libc::c_char = sqlite3_mprintf(
                b"DELETE FROM temp.sqlite_parameters WHERE key=%Q\0" as *const u8
                    as *const libc::c_char,
                azArg[2 as libc::c_int as usize],
            );
            shell_check_oom(zSql_3 as *mut libc::c_void);
            sqlite3_exec(
                (*p).db,
                zSql_3,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
            sqlite3_free(zSql_3 as *mut libc::c_void);
            current_block_1090 = 10465632374337877116;
        } else {
            current_block_1090 = 16458017167451600258;
        }
        match current_block_1090 {
            16458017167451600258 => {
                showHelp((*p).out, b"parameter\0" as *const u8 as *const libc::c_char);
            }
            _ => {}
        }
    } else if c == 'p' as i32 && n >= 3 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"print\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut i_10: libc::c_int = 0;
        i_10 = 1 as libc::c_int;
        while i_10 < nArg {
            if i_10 > 1 as libc::c_int {
                fprintf((*p).out, b" \0" as *const u8 as *const libc::c_char);
            }
            fprintf(
                (*p).out,
                b"%s\0" as *const u8 as *const libc::c_char,
                azArg[i_10 as usize],
            );
            i_10 += 1;
        }
        fprintf((*p).out, b"\n\0" as *const u8 as *const libc::c_char);
    } else if c == 'p' as i32 && n >= 3 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"progress\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut i_11: libc::c_int = 0;
        let mut nn: libc::c_int = 0 as libc::c_int;
        (*p).flgProgress = 0 as libc::c_int as libc::c_uint;
        (*p).mxProgress = 0 as libc::c_int as libc::c_uint;
        (*p).nProgress = 0 as libc::c_int as libc::c_uint;
        i_11 = 1 as libc::c_int;
        loop {
            if !(i_11 < nArg) {
                current_block = 14988504346774710807;
                break;
            }
            let mut z_8: *const libc::c_char = azArg[i_11 as usize];
            if *z_8.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                z_8 = z_8.offset(1);
                if *z_8.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                    z_8 = z_8.offset(1);
                }
                if cli_strcmp(z_8, b"quiet\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                    || cli_strcmp(z_8, b"q\0" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                {
                    (*p).flgProgress |= 0x1 as libc::c_int as libc::c_uint;
                } else if cli_strcmp(z_8, b"reset\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    (*p).flgProgress |= 0x2 as libc::c_int as libc::c_uint;
                } else if cli_strcmp(z_8, b"once\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    (*p).flgProgress |= 0x4 as libc::c_int as libc::c_uint;
                } else if cli_strcmp(z_8, b"limit\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    if i_11 + 1 as libc::c_int >= nArg {
                        fprintf(
                            stderr,
                            b"Error: missing argument on --limit\n\0" as *const u8
                                as *const libc::c_char,
                        );
                        rc = 1 as libc::c_int;
                        current_block = 3081897820958806732;
                        break;
                    } else {
                        i_11 += 1;
                        (*p)
                            .mxProgress = integerValue(azArg[i_11 as usize])
                            as libc::c_int as libc::c_uint;
                    }
                } else {
                    fprintf(
                        stderr,
                        b"Error: unknown option: \"%s\"\n\0" as *const u8
                            as *const libc::c_char,
                        azArg[i_11 as usize],
                    );
                    rc = 1 as libc::c_int;
                    current_block = 3081897820958806732;
                    break;
                }
            } else {
                nn = integerValue(z_8) as libc::c_int;
            }
            i_11 += 1;
        }
        match current_block {
            3081897820958806732 => {}
            _ => {
                open_db(p, 0 as libc::c_int);
                sqlite3_progress_handler(
                    (*p).db,
                    nn,
                    Some(
                        progress_handler
                            as unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int,
                    ),
                    p as *mut libc::c_void,
                );
            }
        }
    } else if c == 'p' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"prompt\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        if nArg >= 2 as libc::c_int {
            strncpy(
                mainPrompt.as_mut_ptr(),
                azArg[1 as libc::c_int as usize],
                ((::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                    .wrapping_div(::std::mem::size_of::<libc::c_char>() as libc::c_ulong)
                    as libc::c_int - 1 as libc::c_int) as libc::c_ulong,
            );
        }
        if nArg >= 3 as libc::c_int {
            strncpy(
                continuePrompt.as_mut_ptr(),
                azArg[2 as libc::c_int as usize],
                ((::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                    .wrapping_div(::std::mem::size_of::<libc::c_char>() as libc::c_ulong)
                    as libc::c_int - 1 as libc::c_int) as libc::c_ulong,
            );
        }
    } else if c == 'q' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"quit\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        rc = 2 as libc::c_int;
    } else if c == 'r' as i32 && n >= 3 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"read\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut inSaved: *mut FILE = (*p).in_0;
        let mut savedLineno: libc::c_int = (*p).lineno;
        failIfSafeMode(
            p,
            b"cannot run .read in safe mode\0" as *const u8 as *const libc::c_char,
        );
        if nArg != 2 as libc::c_int {
            fprintf(
                stderr,
                b"Usage: .read FILE\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        } else {
            if *(azArg[1 as libc::c_int as usize]).offset(0 as libc::c_int as isize)
                as libc::c_int == '|' as i32
            {
                let ref mut fresh449 = (*p).in_0;
                *fresh449 = popen(
                    (azArg[1 as libc::c_int as usize]).offset(1 as libc::c_int as isize),
                    b"r\0" as *const u8 as *const libc::c_char,
                );
                if ((*p).in_0).is_null() {
                    fprintf(
                        stderr,
                        b"Error: cannot open \"%s\"\n\0" as *const u8
                            as *const libc::c_char,
                        azArg[1 as libc::c_int as usize],
                    );
                    rc = 1 as libc::c_int;
                } else {
                    rc = process_input(p);
                    pclose((*p).in_0);
                }
            } else {
                let ref mut fresh450 = (*p).in_0;
                *fresh450 = openChrSource(azArg[1 as libc::c_int as usize]);
                if (*fresh450).is_null() {
                    fprintf(
                        stderr,
                        b"Error: cannot open \"%s\"\n\0" as *const u8
                            as *const libc::c_char,
                        azArg[1 as libc::c_int as usize],
                    );
                    rc = 1 as libc::c_int;
                } else {
                    rc = process_input(p);
                    fclose((*p).in_0);
                }
            }
            let ref mut fresh451 = (*p).in_0;
            *fresh451 = inSaved;
            (*p).lineno = savedLineno;
        }
    } else if c == 'r' as i32 && n >= 3 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"restore\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut zSrcFile: *const libc::c_char = 0 as *const libc::c_char;
        let mut zDb_0: *const libc::c_char = 0 as *const libc::c_char;
        let mut pSrc: *mut sqlite3 = 0 as *mut sqlite3;
        let mut pBackup_0: *mut sqlite3_backup = 0 as *mut sqlite3_backup;
        let mut nTimeout: libc::c_int = 0 as libc::c_int;
        failIfSafeMode(
            p,
            b"cannot run .restore in safe mode\0" as *const u8 as *const libc::c_char,
        );
        if nArg == 2 as libc::c_int {
            zSrcFile = azArg[1 as libc::c_int as usize];
            zDb_0 = b"main\0" as *const u8 as *const libc::c_char;
            current_block = 2183283448959986581;
        } else if nArg == 3 as libc::c_int {
            zSrcFile = azArg[2 as libc::c_int as usize];
            zDb_0 = azArg[1 as libc::c_int as usize];
            current_block = 2183283448959986581;
        } else {
            fprintf(
                stderr,
                b"Usage: .restore ?DB? FILE\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
            current_block = 3081897820958806732;
        }
        match current_block {
            3081897820958806732 => {}
            _ => {
                rc = sqlite3_open(zSrcFile, &mut pSrc);
                if rc != 0 as libc::c_int {
                    fprintf(
                        stderr,
                        b"Error: cannot open \"%s\"\n\0" as *const u8
                            as *const libc::c_char,
                        zSrcFile,
                    );
                    close_db(pSrc);
                    return 1 as libc::c_int;
                }
                open_db(p, 0 as libc::c_int);
                pBackup_0 = sqlite3_backup_init(
                    (*p).db,
                    zDb_0,
                    pSrc,
                    b"main\0" as *const u8 as *const libc::c_char,
                );
                if pBackup_0.is_null() {
                    fprintf(
                        stderr,
                        b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                        sqlite3_errmsg((*p).db),
                    );
                    close_db(pSrc);
                    return 1 as libc::c_int;
                }
                loop {
                    rc = sqlite3_backup_step(pBackup_0, 100 as libc::c_int);
                    if !(rc == 0 as libc::c_int || rc == 5 as libc::c_int) {
                        break;
                    }
                    if !(rc == 5 as libc::c_int) {
                        continue;
                    }
                    let fresh452 = nTimeout;
                    nTimeout = nTimeout + 1;
                    if fresh452 >= 3 as libc::c_int {
                        break;
                    }
                    sqlite3_sleep(100 as libc::c_int);
                }
                sqlite3_backup_finish(pBackup_0);
                if rc == 101 as libc::c_int {
                    rc = 0 as libc::c_int;
                } else if rc == 5 as libc::c_int || rc == 6 as libc::c_int {
                    fprintf(
                        stderr,
                        b"Error: source database is busy\n\0" as *const u8
                            as *const libc::c_char,
                    );
                    rc = 1 as libc::c_int;
                } else {
                    fprintf(
                        stderr,
                        b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                        sqlite3_errmsg((*p).db),
                    );
                    rc = 1 as libc::c_int;
                }
                close_db(pSrc);
            }
        }
    } else if c == 's' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"scanstats\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        if nArg == 2 as libc::c_int {
            (*p).scanstatsOn = booleanValue(azArg[1 as libc::c_int as usize]) as u8_0;
            fprintf(
                stderr,
                b"Warning: .scanstats not available in this build.\n\0" as *const u8
                    as *const libc::c_char,
            );
        } else {
            fprintf(
                stderr,
                b"Usage: .scanstats on|off\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 's' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"schema\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut sSelect: ShellText = ShellText {
            z: 0 as *mut libc::c_char,
            n: 0,
            nAlloc: 0,
        };
        let mut data_0: ShellState = ShellState {
            db: 0 as *mut sqlite3,
            autoExplain: 0,
            autoEQP: 0,
            autoEQPtest: 0,
            autoEQPtrace: 0,
            scanstatsOn: 0,
            openMode: 0,
            doXdgOpen: 0,
            nEqpLevel: 0,
            eTraceType: 0,
            bSafeMode: 0,
            bSafeModePersist: 0,
            cmOpts: ColModeOpts {
                iWrap: 0,
                bQuote: 0,
                bWordWrap: 0,
            },
            statsOn: 0,
            mEqpLines: 0,
            inputNesting: 0,
            outCount: 0,
            cnt: 0,
            lineno: 0,
            openFlags: 0,
            in_0: 0 as *mut FILE,
            out: 0 as *mut FILE,
            traceOut: 0 as *mut FILE,
            nErr: 0,
            mode: 0,
            modePrior: 0,
            cMode: 0,
            normalMode: 0,
            writableSchema: 0,
            showHeader: 0,
            nCheck: 0,
            nProgress: 0,
            mxProgress: 0,
            flgProgress: 0,
            shellFlgs: 0,
            priorShFlgs: 0,
            szMax: 0,
            zDestTable: 0 as *mut libc::c_char,
            zTempFile: 0 as *mut libc::c_char,
            zTestcase: [0; 30],
            colSeparator: [0; 20],
            rowSeparator: [0; 20],
            colSepPrior: [0; 20],
            rowSepPrior: [0; 20],
            colWidth: 0 as *mut libc::c_int,
            actualWidth: 0 as *mut libc::c_int,
            nWidth: 0,
            nullValue: [0; 20],
            outfile: [0; 4096],
            pStmt: 0 as *mut sqlite3_stmt,
            pLog: 0 as *mut FILE,
            aAuxDb: [AuxDb {
                db: 0 as *mut sqlite3,
                zDbFilename: 0 as *const libc::c_char,
                zFreeOnClose: 0 as *mut libc::c_char,
            }; 5],
            pAuxDb: 0 as *mut AuxDb,
            aiIndent: 0 as *mut libc::c_int,
            nIndent: 0,
            iIndent: 0,
            zNonce: 0 as *mut libc::c_char,
            sGraph: EQPGraph {
                pRow: 0 as *mut EQPGraphRow,
                pLast: 0 as *mut EQPGraphRow,
                zPrefix: [0; 100],
            },
            expert: ExpertInfo {
                pExpert: 0 as *mut sqlite3expert,
                bVerbose: 0,
            },
        };
        let mut zErrMsg_0: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut zDiv: *const libc::c_char = b"(\0" as *const u8 as *const libc::c_char;
        let mut zName: *const libc::c_char = 0 as *const libc::c_char;
        let mut iSchema: libc::c_int = 0 as libc::c_int;
        let mut bDebug: libc::c_int = 0 as libc::c_int;
        let mut bNoSystemTabs: libc::c_int = 0 as libc::c_int;
        let mut ii_0: libc::c_int = 0;
        open_db(p, 0 as libc::c_int);
        memcpy(
            &mut data_0 as *mut ShellState as *mut libc::c_void,
            p as *const libc::c_void,
            ::std::mem::size_of::<ShellState>() as libc::c_ulong,
        );
        data_0.showHeader = 0 as libc::c_int;
        data_0.mode = 3 as libc::c_int;
        data_0.cMode = data_0.mode;
        initText(&mut sSelect);
        ii_0 = 1 as libc::c_int;
        loop {
            if !(ii_0 < nArg) {
                current_block = 9936813317866158820;
                break;
            }
            if optionMatch(
                azArg[ii_0 as usize],
                b"indent\0" as *const u8 as *const libc::c_char,
            ) != 0
            {
                data_0.mode = 11 as libc::c_int;
                data_0.cMode = data_0.mode;
            } else if optionMatch(
                azArg[ii_0 as usize],
                b"debug\0" as *const u8 as *const libc::c_char,
            ) != 0
            {
                bDebug = 1 as libc::c_int;
            } else if optionMatch(
                azArg[ii_0 as usize],
                b"nosys\0" as *const u8 as *const libc::c_char,
            ) != 0
            {
                bNoSystemTabs = 1 as libc::c_int;
            } else if *(azArg[ii_0 as usize]).offset(0 as libc::c_int as isize)
                as libc::c_int == '-' as i32
            {
                fprintf(
                    stderr,
                    b"Unknown option: \"%s\"\n\0" as *const u8 as *const libc::c_char,
                    azArg[ii_0 as usize],
                );
                rc = 1 as libc::c_int;
                current_block = 3081897820958806732;
                break;
            } else if zName.is_null() {
                zName = azArg[ii_0 as usize];
            } else {
                fprintf(
                    stderr,
                    b"Usage: .schema ?--indent? ?--nosys? ?LIKE-PATTERN?\n\0"
                        as *const u8 as *const libc::c_char,
                );
                rc = 1 as libc::c_int;
                current_block = 3081897820958806732;
                break;
            }
            ii_0 += 1;
        }
        match current_block {
            3081897820958806732 => {}
            _ => {
                if !zName.is_null() {
                    let mut isSchema: libc::c_int = (sqlite3_strlike(
                        zName,
                        b"sqlite_master\0" as *const u8 as *const libc::c_char,
                        '\\' as i32 as libc::c_uint,
                    ) == 0 as libc::c_int
                        || sqlite3_strlike(
                            zName,
                            b"sqlite_schema\0" as *const u8 as *const libc::c_char,
                            '\\' as i32 as libc::c_uint,
                        ) == 0 as libc::c_int
                        || sqlite3_strlike(
                            zName,
                            b"sqlite_temp_master\0" as *const u8 as *const libc::c_char,
                            '\\' as i32 as libc::c_uint,
                        ) == 0 as libc::c_int
                        || sqlite3_strlike(
                            zName,
                            b"sqlite_temp_schema\0" as *const u8 as *const libc::c_char,
                            '\\' as i32 as libc::c_uint,
                        ) == 0 as libc::c_int) as libc::c_int;
                    if isSchema != 0 {
                        let mut new_argv: [*mut libc::c_char; 2] = [0
                            as *mut libc::c_char; 2];
                        let mut new_colv: [*mut libc::c_char; 2] = [0
                            as *mut libc::c_char; 2];
                        new_argv[0 as libc::c_int
                            as usize] = sqlite3_mprintf(
                            b"CREATE TABLE %s (\n  type text,\n  name text,\n  tbl_name text,\n  rootpage integer,\n  sql text\n)\0"
                                as *const u8 as *const libc::c_char,
                            zName,
                        );
                        shell_check_oom(
                            new_argv[0 as libc::c_int as usize] as *mut libc::c_void,
                        );
                        new_argv[1 as libc::c_int as usize] = 0 as *mut libc::c_char;
                        new_colv[0 as libc::c_int
                            as usize] = b"sql\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char;
                        new_colv[1 as libc::c_int as usize] = 0 as *mut libc::c_char;
                        callback(
                            &mut data_0 as *mut ShellState as *mut libc::c_void,
                            1 as libc::c_int,
                            new_argv.as_mut_ptr(),
                            new_colv.as_mut_ptr(),
                        );
                        sqlite3_free(
                            new_argv[0 as libc::c_int as usize] as *mut libc::c_void,
                        );
                    }
                }
                if !zDiv.is_null() {
                    let mut pStmt_5: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
                    rc = sqlite3_prepare_v2(
                        (*p).db,
                        b"SELECT name FROM pragma_database_list\0" as *const u8
                            as *const libc::c_char,
                        -(1 as libc::c_int),
                        &mut pStmt_5,
                        0 as *mut *const libc::c_char,
                    );
                    if rc != 0 {
                        fprintf(
                            stderr,
                            b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                            sqlite3_errmsg((*p).db),
                        );
                        sqlite3_finalize(pStmt_5);
                        rc = 1 as libc::c_int;
                        current_block = 3081897820958806732;
                    } else {
                        appendText(
                            &mut sSelect,
                            b"SELECT sql FROM\0" as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                        iSchema = 0 as libc::c_int;
                        while sqlite3_step(pStmt_5) == 100 as libc::c_int {
                            let mut zDb_1: *const libc::c_char = sqlite3_column_text(
                                pStmt_5,
                                0 as libc::c_int,
                            ) as *const libc::c_char;
                            let mut zScNum: [libc::c_char; 30] = [0; 30];
                            iSchema += 1;
                            sqlite3_snprintf(
                                ::std::mem::size_of::<[libc::c_char; 30]>() as libc::c_ulong
                                    as libc::c_int,
                                zScNum.as_mut_ptr(),
                                b"%d\0" as *const u8 as *const libc::c_char,
                                iSchema,
                            );
                            appendText(
                                &mut sSelect,
                                zDiv,
                                0 as libc::c_int as libc::c_char,
                            );
                            zDiv = b" UNION ALL \0" as *const u8 as *const libc::c_char;
                            appendText(
                                &mut sSelect,
                                b"SELECT shell_add_schema(sql,\0" as *const u8
                                    as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                            if sqlite3_stricmp(
                                zDb_1,
                                b"main\0" as *const u8 as *const libc::c_char,
                            ) != 0 as libc::c_int
                            {
                                appendText(
                                    &mut sSelect,
                                    zDb_1,
                                    '\'' as i32 as libc::c_char,
                                );
                            } else {
                                appendText(
                                    &mut sSelect,
                                    b"NULL\0" as *const u8 as *const libc::c_char,
                                    0 as libc::c_int as libc::c_char,
                                );
                            }
                            appendText(
                                &mut sSelect,
                                b",name) AS sql, type, tbl_name, name, rowid,\0"
                                    as *const u8 as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                            appendText(
                                &mut sSelect,
                                zScNum.as_mut_ptr(),
                                0 as libc::c_int as libc::c_char,
                            );
                            appendText(
                                &mut sSelect,
                                b" AS snum, \0" as *const u8 as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                            appendText(&mut sSelect, zDb_1, '\'' as i32 as libc::c_char);
                            appendText(
                                &mut sSelect,
                                b" AS sname FROM \0" as *const u8 as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                            appendText(&mut sSelect, zDb_1, quoteChar(zDb_1));
                            appendText(
                                &mut sSelect,
                                b".sqlite_schema\0" as *const u8 as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                        }
                        sqlite3_finalize(pStmt_5);
                        if !zName.is_null() {
                            appendText(
                                &mut sSelect,
                                b" UNION ALL SELECT shell_module_schema(name), 'table', name, name, name, 9e+99, 'main' FROM pragma_module_list\0"
                                    as *const u8 as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                        }
                        appendText(
                            &mut sSelect,
                            b") WHERE \0" as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                        if !zName.is_null() {
                            let mut zQarg: *mut libc::c_char = sqlite3_mprintf(
                                b"%Q\0" as *const u8 as *const libc::c_char,
                                zName,
                            );
                            let mut bGlob: libc::c_int = 0;
                            shell_check_oom(zQarg as *mut libc::c_void);
                            bGlob = (!(strchr(zName, '*' as i32)).is_null()
                                || !(strchr(zName, '?' as i32)).is_null()
                                || !(strchr(zName, '[' as i32)).is_null()) as libc::c_int;
                            if !(strchr(zName, '.' as i32)).is_null() {
                                appendText(
                                    &mut sSelect,
                                    b"lower(printf('%s.%s',sname,tbl_name))\0" as *const u8
                                        as *const libc::c_char,
                                    0 as libc::c_int as libc::c_char,
                                );
                            } else {
                                appendText(
                                    &mut sSelect,
                                    b"lower(tbl_name)\0" as *const u8 as *const libc::c_char,
                                    0 as libc::c_int as libc::c_char,
                                );
                            }
                            appendText(
                                &mut sSelect,
                                if bGlob != 0 {
                                    b" GLOB \0" as *const u8 as *const libc::c_char
                                } else {
                                    b" LIKE \0" as *const u8 as *const libc::c_char
                                },
                                0 as libc::c_int as libc::c_char,
                            );
                            appendText(
                                &mut sSelect,
                                zQarg,
                                0 as libc::c_int as libc::c_char,
                            );
                            if bGlob == 0 {
                                appendText(
                                    &mut sSelect,
                                    b" ESCAPE '\\' \0" as *const u8 as *const libc::c_char,
                                    0 as libc::c_int as libc::c_char,
                                );
                            }
                            appendText(
                                &mut sSelect,
                                b" AND \0" as *const u8 as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                            sqlite3_free(zQarg as *mut libc::c_void);
                        }
                        if bNoSystemTabs != 0 {
                            appendText(
                                &mut sSelect,
                                b"name NOT LIKE 'sqlite_%%' AND \0" as *const u8
                                    as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                        }
                        appendText(
                            &mut sSelect,
                            b"sql IS NOT NULL ORDER BY snum, rowid\0" as *const u8
                                as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                        if bDebug != 0 {
                            fprintf(
                                (*p).out,
                                b"SQL: %s;\n\0" as *const u8 as *const libc::c_char,
                                sSelect.z,
                            );
                        } else {
                            rc = sqlite3_exec(
                                (*p).db,
                                sSelect.z,
                                Some(
                                    callback
                                        as unsafe extern "C" fn(
                                            *mut libc::c_void,
                                            libc::c_int,
                                            *mut *mut libc::c_char,
                                            *mut *mut libc::c_char,
                                        ) -> libc::c_int,
                                ),
                                &mut data_0 as *mut ShellState as *mut libc::c_void,
                                &mut zErrMsg_0,
                            );
                        }
                        freeText(&mut sSelect);
                        current_block = 2946575373538231819;
                    }
                } else {
                    current_block = 2946575373538231819;
                }
                match current_block {
                    3081897820958806732 => {}
                    _ => {
                        if !zErrMsg_0.is_null() {
                            fprintf(
                                stderr,
                                b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                                zErrMsg_0,
                            );
                            sqlite3_free(zErrMsg_0 as *mut libc::c_void);
                            rc = 1 as libc::c_int;
                        } else if rc != 0 as libc::c_int {
                            fprintf(
                                stderr,
                                b"Error: querying schema information\n\0" as *const u8
                                    as *const libc::c_char,
                            );
                            rc = 1 as libc::c_int;
                        } else {
                            rc = 0 as libc::c_int;
                        }
                    }
                }
            }
        }
    } else if c == 's' as i32 && n == 11 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"selecttrace\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
        || c == 't' as i32 && n == 9 as libc::c_int
            && cli_strncmp(
                azArg[0 as libc::c_int as usize],
                b"treetrace\0" as *const u8 as *const libc::c_char,
                n as size_t,
            ) == 0 as libc::c_int
    {
        let mut x_3: libc::c_uint = if nArg >= 2 as libc::c_int {
            integerValue(azArg[1 as libc::c_int as usize]) as libc::c_uint
        } else {
            0xffffffff as libc::c_uint
        };
        sqlite3_test_control(
            31 as libc::c_int,
            1 as libc::c_int,
            &mut x_3 as *mut libc::c_uint,
        );
    } else if c == 's' as i32 && n >= 4 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"selftest\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut bIsInit: libc::c_int = 0 as libc::c_int;
        let mut bVerbose: libc::c_int = 0 as libc::c_int;
        let mut bSelftestExists: libc::c_int = 0;
        let mut i_12: libc::c_int = 0;
        let mut k: libc::c_int = 0;
        let mut nTest: libc::c_int = 0 as libc::c_int;
        let mut nErr: libc::c_int = 0 as libc::c_int;
        let mut str: ShellText = ShellText {
            z: 0 as *mut libc::c_char,
            n: 0,
            nAlloc: 0,
        };
        let mut pStmt_6: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        open_db(p, 0 as libc::c_int);
        i_12 = 1 as libc::c_int;
        loop {
            if !(i_12 < nArg) {
                current_block = 16306641819203460824;
                break;
            }
            let mut z_9: *const libc::c_char = azArg[i_12 as usize];
            if *z_9.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
                && *z_9.offset(1 as libc::c_int as isize) as libc::c_int == '-' as i32
            {
                z_9 = z_9.offset(1);
            }
            if cli_strcmp(z_9, b"-init\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                bIsInit = 1 as libc::c_int;
            } else if cli_strcmp(z_9, b"-v\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                bVerbose += 1;
            } else {
                fprintf(
                    stderr,
                    b"Unknown option \"%s\" on \"%s\"\n\0" as *const u8
                        as *const libc::c_char,
                    azArg[i_12 as usize],
                    azArg[0 as libc::c_int as usize],
                );
                fprintf(
                    stderr,
                    b"Should be one of: --init -v\n\0" as *const u8
                        as *const libc::c_char,
                );
                rc = 1 as libc::c_int;
                current_block = 3081897820958806732;
                break;
            }
            i_12 += 1;
        }
        match current_block {
            3081897820958806732 => {}
            _ => {
                if sqlite3_table_column_metadata(
                    (*p).db,
                    b"main\0" as *const u8 as *const libc::c_char,
                    b"selftest\0" as *const u8 as *const libc::c_char,
                    0 as *const libc::c_char,
                    0 as *mut *const libc::c_char,
                    0 as *mut *const libc::c_char,
                    0 as *mut libc::c_int,
                    0 as *mut libc::c_int,
                    0 as *mut libc::c_int,
                ) != 0 as libc::c_int
                {
                    bSelftestExists = 0 as libc::c_int;
                } else {
                    bSelftestExists = 1 as libc::c_int;
                }
                if bIsInit != 0 {
                    createSelftestTable(p);
                    bSelftestExists = 1 as libc::c_int;
                }
                initText(&mut str);
                appendText(
                    &mut str,
                    b"x\0" as *const u8 as *const libc::c_char,
                    0 as libc::c_int as libc::c_char,
                );
                k = bSelftestExists;
                loop {
                    if !(k >= 0 as libc::c_int) {
                        current_block = 5806390029137455784;
                        break;
                    }
                    if k == 1 as libc::c_int {
                        rc = sqlite3_prepare_v2(
                            (*p).db,
                            b"SELECT tno,op,cmd,ans FROM selftest ORDER BY tno\0"
                                as *const u8 as *const libc::c_char,
                            -(1 as libc::c_int),
                            &mut pStmt_6,
                            0 as *mut *const libc::c_char,
                        );
                    } else {
                        rc = sqlite3_prepare_v2(
                            (*p).db,
                            b"VALUES(0,'memo','Missing SELFTEST table - default checks only',''),      (1,'run','PRAGMA integrity_check','ok')\0"
                                as *const u8 as *const libc::c_char,
                            -(1 as libc::c_int),
                            &mut pStmt_6,
                            0 as *mut *const libc::c_char,
                        );
                    }
                    if rc != 0 {
                        fprintf(
                            stderr,
                            b"Error querying the selftest table\n\0" as *const u8
                                as *const libc::c_char,
                        );
                        rc = 1 as libc::c_int;
                        sqlite3_finalize(pStmt_6);
                        current_block = 3081897820958806732;
                        break;
                    } else {
                        i_12 = 1 as libc::c_int;
                        while sqlite3_step(pStmt_6) == 100 as libc::c_int {
                            let mut tno: libc::c_int = sqlite3_column_int(
                                pStmt_6,
                                0 as libc::c_int,
                            );
                            let mut zOp: *const libc::c_char = sqlite3_column_text(
                                pStmt_6,
                                1 as libc::c_int,
                            ) as *const libc::c_char;
                            let mut zSql_4: *const libc::c_char = sqlite3_column_text(
                                pStmt_6,
                                2 as libc::c_int,
                            ) as *const libc::c_char;
                            let mut zAns: *const libc::c_char = sqlite3_column_text(
                                pStmt_6,
                                3 as libc::c_int,
                            ) as *const libc::c_char;
                            if !zOp.is_null() {
                                if !zSql_4.is_null() {
                                    if !zAns.is_null() {
                                        k = 0 as libc::c_int;
                                        if bVerbose > 0 as libc::c_int {
                                            printf(
                                                b"%d: %s %s\n\0" as *const u8 as *const libc::c_char,
                                                tno,
                                                zOp,
                                                zSql_4,
                                            );
                                        }
                                        if cli_strcmp(
                                            zOp,
                                            b"memo\0" as *const u8 as *const libc::c_char,
                                        ) == 0 as libc::c_int
                                        {
                                            fprintf(
                                                (*p).out,
                                                b"%s\n\0" as *const u8 as *const libc::c_char,
                                                zSql_4,
                                            );
                                        } else if cli_strcmp(
                                            zOp,
                                            b"run\0" as *const u8 as *const libc::c_char,
                                        ) == 0 as libc::c_int
                                        {
                                            let mut zErrMsg_1: *mut libc::c_char = 0
                                                as *mut libc::c_char;
                                            str.n = 0 as libc::c_int;
                                            *(str.z)
                                                .offset(
                                                    0 as libc::c_int as isize,
                                                ) = 0 as libc::c_int as libc::c_char;
                                            rc = sqlite3_exec(
                                                (*p).db,
                                                zSql_4,
                                                Some(
                                                    captureOutputCallback
                                                        as unsafe extern "C" fn(
                                                            *mut libc::c_void,
                                                            libc::c_int,
                                                            *mut *mut libc::c_char,
                                                            *mut *mut libc::c_char,
                                                        ) -> libc::c_int,
                                                ),
                                                &mut str as *mut ShellText as *mut libc::c_void,
                                                &mut zErrMsg_1,
                                            );
                                            nTest += 1;
                                            if bVerbose != 0 {
                                                fprintf(
                                                    (*p).out,
                                                    b"Result: %s\n\0" as *const u8 as *const libc::c_char,
                                                    str.z,
                                                );
                                            }
                                            if rc != 0 || !zErrMsg_1.is_null() {
                                                nErr += 1;
                                                rc = 1 as libc::c_int;
                                                fprintf(
                                                    (*p).out,
                                                    b"%d: error-code-%d: %s\n\0" as *const u8
                                                        as *const libc::c_char,
                                                    tno,
                                                    rc,
                                                    zErrMsg_1,
                                                );
                                                sqlite3_free(zErrMsg_1 as *mut libc::c_void);
                                            } else if cli_strcmp(zAns, str.z) != 0 as libc::c_int {
                                                nErr += 1;
                                                rc = 1 as libc::c_int;
                                                fprintf(
                                                    (*p).out,
                                                    b"%d: Expected: [%s]\n\0" as *const u8
                                                        as *const libc::c_char,
                                                    tno,
                                                    zAns,
                                                );
                                                fprintf(
                                                    (*p).out,
                                                    b"%d:      Got: [%s]\n\0" as *const u8
                                                        as *const libc::c_char,
                                                    tno,
                                                    str.z,
                                                );
                                            }
                                        } else {
                                            fprintf(
                                                stderr,
                                                b"Unknown operation \"%s\" on selftest line %d\n\0"
                                                    as *const u8 as *const libc::c_char,
                                                zOp,
                                                tno,
                                            );
                                            rc = 1 as libc::c_int;
                                            break;
                                        }
                                    }
                                }
                            }
                            i_12 += 1;
                        }
                        sqlite3_finalize(pStmt_6);
                        k -= 1;
                    }
                }
                match current_block {
                    3081897820958806732 => {}
                    _ => {
                        freeText(&mut str);
                        fprintf(
                            (*p).out,
                            b"%d errors out of %d tests\n\0" as *const u8
                                as *const libc::c_char,
                            nErr,
                            nTest,
                        );
                    }
                }
            }
        }
    } else if c == 's' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"separator\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        if nArg < 2 as libc::c_int || nArg > 3 as libc::c_int {
            fprintf(
                stderr,
                b"Usage: .separator COL ?ROW?\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
        if nArg >= 2 as libc::c_int {
            sqlite3_snprintf(
                ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                    as libc::c_int,
                ((*p).colSeparator).as_mut_ptr(),
                b"%.*s\0" as *const u8 as *const libc::c_char,
                (::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                    .wrapping_div(::std::mem::size_of::<libc::c_char>() as libc::c_ulong)
                    as libc::c_int - 1 as libc::c_int,
                azArg[1 as libc::c_int as usize],
            );
        }
        if nArg >= 3 as libc::c_int {
            sqlite3_snprintf(
                ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                    as libc::c_int,
                ((*p).rowSeparator).as_mut_ptr(),
                b"%.*s\0" as *const u8 as *const libc::c_char,
                (::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                    .wrapping_div(::std::mem::size_of::<libc::c_char>() as libc::c_ulong)
                    as libc::c_int - 1 as libc::c_int,
                azArg[2 as libc::c_int as usize],
            );
        }
    } else if c == 's' as i32 && n >= 4 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"sha3sum\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut zLike_0: *const libc::c_char = 0 as *const libc::c_char;
        let mut i_13: libc::c_int = 0;
        let mut bSchema: libc::c_int = 0 as libc::c_int;
        let mut bSeparate: libc::c_int = 0 as libc::c_int;
        let mut iSize: libc::c_int = 224 as libc::c_int;
        let mut bDebug_0: libc::c_int = 0 as libc::c_int;
        let mut pStmt_7: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        let mut zSql_5: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut zSep_0: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut sSql: ShellText = ShellText {
            z: 0 as *mut libc::c_char,
            n: 0,
            nAlloc: 0,
        };
        let mut sQuery: ShellText = ShellText {
            z: 0 as *mut libc::c_char,
            n: 0,
            nAlloc: 0,
        };
        open_db(p, 0 as libc::c_int);
        i_13 = 1 as libc::c_int;
        loop {
            if !(i_13 < nArg) {
                current_block = 9440740984579190949;
                break;
            }
            let mut z_10: *const libc::c_char = azArg[i_13 as usize];
            if *z_10.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                z_10 = z_10.offset(1);
                if *z_10.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                    z_10 = z_10.offset(1);
                }
                if cli_strcmp(z_10, b"schema\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    bSchema = 1 as libc::c_int;
                } else if cli_strcmp(
                    z_10,
                    b"sha3-224\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
                    || cli_strcmp(
                        z_10,
                        b"sha3-256\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                    || cli_strcmp(
                        z_10,
                        b"sha3-384\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                    || cli_strcmp(
                        z_10,
                        b"sha3-512\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                {
                    iSize = atoi(&*z_10.offset(5 as libc::c_int as isize));
                } else if cli_strcmp(
                    z_10,
                    b"debug\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
                {
                    bDebug_0 = 1 as libc::c_int;
                } else {
                    fprintf(
                        stderr,
                        b"Unknown option \"%s\" on \"%s\"\n\0" as *const u8
                            as *const libc::c_char,
                        azArg[i_13 as usize],
                        azArg[0 as libc::c_int as usize],
                    );
                    showHelp((*p).out, azArg[0 as libc::c_int as usize]);
                    rc = 1 as libc::c_int;
                    current_block = 3081897820958806732;
                    break;
                }
            } else if !zLike_0.is_null() {
                fprintf(
                    stderr,
                    b"Usage: .sha3sum ?OPTIONS? ?LIKE-PATTERN?\n\0" as *const u8
                        as *const libc::c_char,
                );
                rc = 1 as libc::c_int;
                current_block = 3081897820958806732;
                break;
            } else {
                zLike_0 = z_10;
                bSeparate = 1 as libc::c_int;
                if sqlite3_strlike(
                    b"sqlite\\_%\0" as *const u8 as *const libc::c_char,
                    zLike_0,
                    '\\' as i32 as libc::c_uint,
                ) == 0 as libc::c_int
                {
                    bSchema = 1 as libc::c_int;
                }
            }
            i_13 += 1;
        }
        match current_block {
            3081897820958806732 => {}
            _ => {
                if bSchema != 0 {
                    zSql_5 = b"SELECT lower(name) FROM sqlite_schema WHERE type='table' AND coalesce(rootpage,0)>1 UNION ALL SELECT 'sqlite_schema' ORDER BY 1 collate nocase\0"
                        as *const u8 as *const libc::c_char as *mut libc::c_char;
                } else {
                    zSql_5 = b"SELECT lower(name) FROM sqlite_schema WHERE type='table' AND coalesce(rootpage,0)>1 AND name NOT LIKE 'sqlite_%' ORDER BY 1 collate nocase\0"
                        as *const u8 as *const libc::c_char as *mut libc::c_char;
                }
                sqlite3_prepare_v2(
                    (*p).db,
                    zSql_5,
                    -(1 as libc::c_int),
                    &mut pStmt_7,
                    0 as *mut *const libc::c_char,
                );
                initText(&mut sQuery);
                initText(&mut sSql);
                appendText(
                    &mut sSql,
                    b"WITH [sha3sum$query](a,b) AS(\0" as *const u8
                        as *const libc::c_char,
                    0 as libc::c_int as libc::c_char,
                );
                zSep_0 = b"VALUES(\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char;
                while 100 as libc::c_int == sqlite3_step(pStmt_7) {
                    let mut zTab: *const libc::c_char = sqlite3_column_text(
                        pStmt_7,
                        0 as libc::c_int,
                    ) as *const libc::c_char;
                    if zTab.is_null() {
                        continue;
                    }
                    if !zLike_0.is_null()
                        && sqlite3_strlike(
                            zLike_0,
                            zTab,
                            0 as libc::c_int as libc::c_uint,
                        ) != 0 as libc::c_int
                    {
                        continue;
                    }
                    if cli_strncmp(
                        zTab,
                        b"sqlite_\0" as *const u8 as *const libc::c_char,
                        7 as libc::c_int as size_t,
                    ) != 0 as libc::c_int
                    {
                        appendText(
                            &mut sQuery,
                            b"SELECT * FROM \0" as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                        appendText(&mut sQuery, zTab, '"' as i32 as libc::c_char);
                        appendText(
                            &mut sQuery,
                            b" NOT INDEXED;\0" as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                    } else if cli_strcmp(
                        zTab,
                        b"sqlite_schema\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                    {
                        appendText(
                            &mut sQuery,
                            b"SELECT type,name,tbl_name,sql FROM sqlite_schema ORDER BY name;\0"
                                as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                    } else if cli_strcmp(
                        zTab,
                        b"sqlite_sequence\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                    {
                        appendText(
                            &mut sQuery,
                            b"SELECT name,seq FROM sqlite_sequence ORDER BY name;\0"
                                as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                    } else if cli_strcmp(
                        zTab,
                        b"sqlite_stat1\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                    {
                        appendText(
                            &mut sQuery,
                            b"SELECT tbl,idx,stat FROM sqlite_stat1 ORDER BY tbl,idx;\0"
                                as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                    } else if cli_strcmp(
                        zTab,
                        b"sqlite_stat4\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                    {
                        appendText(
                            &mut sQuery,
                            b"SELECT * FROM \0" as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                        appendText(&mut sQuery, zTab, 0 as libc::c_int as libc::c_char);
                        appendText(
                            &mut sQuery,
                            b" ORDER BY tbl, idx, rowid;\n\0" as *const u8
                                as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                    }
                    appendText(&mut sSql, zSep_0, 0 as libc::c_int as libc::c_char);
                    appendText(&mut sSql, sQuery.z, '\'' as i32 as libc::c_char);
                    sQuery.n = 0 as libc::c_int;
                    appendText(
                        &mut sSql,
                        b",\0" as *const u8 as *const libc::c_char,
                        0 as libc::c_int as libc::c_char,
                    );
                    appendText(&mut sSql, zTab, '\'' as i32 as libc::c_char);
                    zSep_0 = b"),(\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char;
                }
                sqlite3_finalize(pStmt_7);
                if bSeparate != 0 {
                    zSql_5 = sqlite3_mprintf(
                        b"%s)) SELECT lower(hex(sha3_query(a,%d))) AS hash, b AS label   FROM [sha3sum$query]\0"
                            as *const u8 as *const libc::c_char,
                        sSql.z,
                        iSize,
                    );
                } else {
                    zSql_5 = sqlite3_mprintf(
                        b"%s)) SELECT lower(hex(sha3_query(group_concat(a,''),%d))) AS hash   FROM [sha3sum$query]\0"
                            as *const u8 as *const libc::c_char,
                        sSql.z,
                        iSize,
                    );
                }
                shell_check_oom(zSql_5 as *mut libc::c_void);
                freeText(&mut sQuery);
                freeText(&mut sSql);
                if bDebug_0 != 0 {
                    fprintf(
                        (*p).out,
                        b"%s\n\0" as *const u8 as *const libc::c_char,
                        zSql_5,
                    );
                } else {
                    shell_exec(p, zSql_5, 0 as *mut *mut libc::c_char);
                }
                sqlite3_free(zSql_5 as *mut libc::c_void);
            }
        }
    } else if c == 's' as i32
        && (cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"shell\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
            || cli_strncmp(
                azArg[0 as libc::c_int as usize],
                b"system\0" as *const u8 as *const libc::c_char,
                n as size_t,
            ) == 0 as libc::c_int)
    {
        let mut zCmd_0: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut i_14: libc::c_int = 0;
        let mut x_4: libc::c_int = 0;
        failIfSafeMode(
            p,
            b"cannot run .%s in safe mode\0" as *const u8 as *const libc::c_char,
            azArg[0 as libc::c_int as usize],
        );
        if nArg < 2 as libc::c_int {
            fprintf(
                stderr,
                b"Usage: .system COMMAND\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        } else {
            zCmd_0 = sqlite3_mprintf(
                if (strchr(azArg[1 as libc::c_int as usize], ' ' as i32)).is_null() {
                    b"%s\0" as *const u8 as *const libc::c_char
                } else {
                    b"\"%s\"\0" as *const u8 as *const libc::c_char
                },
                azArg[1 as libc::c_int as usize],
            );
            i_14 = 2 as libc::c_int;
            while i_14 < nArg && !zCmd_0.is_null() {
                zCmd_0 = sqlite3_mprintf(
                    if (strchr(azArg[i_14 as usize], ' ' as i32)).is_null() {
                        b"%z %s\0" as *const u8 as *const libc::c_char
                    } else {
                        b"%z \"%s\"\0" as *const u8 as *const libc::c_char
                    },
                    zCmd_0,
                    azArg[i_14 as usize],
                );
                i_14 += 1;
            }
            x_4 = if !zCmd_0.is_null() { system(zCmd_0) } else { 1 as libc::c_int };
            sqlite3_free(zCmd_0 as *mut libc::c_void);
            if x_4 != 0 {
                fprintf(
                    stderr,
                    b"System command returns %d\n\0" as *const u8 as *const libc::c_char,
                    x_4,
                );
            }
        }
    } else if c == 's' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"show\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        static mut azBool: [*const libc::c_char; 4] = [
            b"off\0" as *const u8 as *const libc::c_char,
            b"on\0" as *const u8 as *const libc::c_char,
            b"trigger\0" as *const u8 as *const libc::c_char,
            b"full\0" as *const u8 as *const libc::c_char,
        ];
        let mut zOut: *const libc::c_char = 0 as *const libc::c_char;
        let mut i_15: libc::c_int = 0;
        if nArg != 1 as libc::c_int {
            fprintf(stderr, b"Usage: .show\n\0" as *const u8 as *const libc::c_char);
            rc = 1 as libc::c_int;
        } else {
            fprintf(
                (*p).out,
                b"%12.12s: %s\n\0" as *const u8 as *const libc::c_char,
                b"echo\0" as *const u8 as *const libc::c_char,
                azBool[((*p).shellFlgs & 0x40 as libc::c_int as libc::c_uint
                    != 0 as libc::c_int as libc::c_uint) as libc::c_int as usize],
            );
            fprintf(
                (*p).out,
                b"%12.12s: %s\n\0" as *const u8 as *const libc::c_char,
                b"eqp\0" as *const u8 as *const libc::c_char,
                azBool[((*p).autoEQP as libc::c_int & 3 as libc::c_int) as usize],
            );
            fprintf(
                (*p).out,
                b"%12.12s: %s\n\0" as *const u8 as *const libc::c_char,
                b"explain\0" as *const u8 as *const libc::c_char,
                if (*p).mode == 9 as libc::c_int {
                    b"on\0" as *const u8 as *const libc::c_char
                } else if (*p).autoExplain as libc::c_int != 0 {
                    b"auto\0" as *const u8 as *const libc::c_char
                } else {
                    b"off\0" as *const u8 as *const libc::c_char
                },
            );
            fprintf(
                (*p).out,
                b"%12.12s: %s\n\0" as *const u8 as *const libc::c_char,
                b"headers\0" as *const u8 as *const libc::c_char,
                azBool[((*p).showHeader != 0 as libc::c_int) as libc::c_int as usize],
            );
            if (*p).mode == 1 as libc::c_int
                || (*p).mode >= 14 as libc::c_int && (*p).mode <= 16 as libc::c_int
            {
                fprintf(
                    (*p).out,
                    b"%12.12s: %s --wrap %d --wordwrap %s --%squote\n\0" as *const u8
                        as *const libc::c_char,
                    b"mode\0" as *const u8 as *const libc::c_char,
                    modeDescr[(*p).mode as usize],
                    (*p).cmOpts.iWrap,
                    if (*p).cmOpts.bWordWrap as libc::c_int != 0 {
                        b"on\0" as *const u8 as *const libc::c_char
                    } else {
                        b"off\0" as *const u8 as *const libc::c_char
                    },
                    if (*p).cmOpts.bQuote as libc::c_int != 0 {
                        b"\0" as *const u8 as *const libc::c_char
                    } else {
                        b"no\0" as *const u8 as *const libc::c_char
                    },
                );
            } else {
                fprintf(
                    (*p).out,
                    b"%12.12s: %s\n\0" as *const u8 as *const libc::c_char,
                    b"mode\0" as *const u8 as *const libc::c_char,
                    modeDescr[(*p).mode as usize],
                );
            }
            fprintf(
                (*p).out,
                b"%12.12s: \0" as *const u8 as *const libc::c_char,
                b"nullvalue\0" as *const u8 as *const libc::c_char,
            );
            output_c_string((*p).out, ((*p).nullValue).as_mut_ptr());
            fprintf((*p).out, b"\n\0" as *const u8 as *const libc::c_char);
            fprintf(
                (*p).out,
                b"%12.12s: %s\n\0" as *const u8 as *const libc::c_char,
                b"output\0" as *const u8 as *const libc::c_char,
                if strlen30(((*p).outfile).as_mut_ptr()) != 0 {
                    ((*p).outfile).as_mut_ptr() as *const libc::c_char
                } else {
                    b"stdout\0" as *const u8 as *const libc::c_char
                },
            );
            fprintf(
                (*p).out,
                b"%12.12s: \0" as *const u8 as *const libc::c_char,
                b"colseparator\0" as *const u8 as *const libc::c_char,
            );
            output_c_string((*p).out, ((*p).colSeparator).as_mut_ptr());
            fprintf((*p).out, b"\n\0" as *const u8 as *const libc::c_char);
            fprintf(
                (*p).out,
                b"%12.12s: \0" as *const u8 as *const libc::c_char,
                b"rowseparator\0" as *const u8 as *const libc::c_char,
            );
            output_c_string((*p).out, ((*p).rowSeparator).as_mut_ptr());
            fprintf((*p).out, b"\n\0" as *const u8 as *const libc::c_char);
            match (*p).statsOn {
                0 => {
                    zOut = b"off\0" as *const u8 as *const libc::c_char;
                }
                2 => {
                    zOut = b"stmt\0" as *const u8 as *const libc::c_char;
                }
                3 => {
                    zOut = b"vmstep\0" as *const u8 as *const libc::c_char;
                }
                _ => {
                    zOut = b"on\0" as *const u8 as *const libc::c_char;
                }
            }
            fprintf(
                (*p).out,
                b"%12.12s: %s\n\0" as *const u8 as *const libc::c_char,
                b"stats\0" as *const u8 as *const libc::c_char,
                zOut,
            );
            fprintf(
                (*p).out,
                b"%12.12s: \0" as *const u8 as *const libc::c_char,
                b"width\0" as *const u8 as *const libc::c_char,
            );
            i_15 = 0 as libc::c_int;
            while i_15 < (*p).nWidth {
                fprintf(
                    (*p).out,
                    b"%d \0" as *const u8 as *const libc::c_char,
                    *((*p).colWidth).offset(i_15 as isize),
                );
                i_15 += 1;
            }
            fprintf((*p).out, b"\n\0" as *const u8 as *const libc::c_char);
            fprintf(
                (*p).out,
                b"%12.12s: %s\n\0" as *const u8 as *const libc::c_char,
                b"filename\0" as *const u8 as *const libc::c_char,
                if !((*(*p).pAuxDb).zDbFilename).is_null() {
                    (*(*p).pAuxDb).zDbFilename
                } else {
                    b"\0" as *const u8 as *const libc::c_char
                },
            );
        }
    } else if c == 's' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"stats\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        if nArg == 2 as libc::c_int {
            if cli_strcmp(
                azArg[1 as libc::c_int as usize],
                b"stmt\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
            {
                (*p).statsOn = 2 as libc::c_int as libc::c_uint;
            } else if cli_strcmp(
                azArg[1 as libc::c_int as usize],
                b"vmstep\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
            {
                (*p).statsOn = 3 as libc::c_int as libc::c_uint;
            } else {
                (*p)
                    .statsOn = booleanValue(azArg[1 as libc::c_int as usize]) as u8_0
                    as libc::c_uint;
            }
        } else if nArg == 1 as libc::c_int {
            display_stats((*p).db, p, 0 as libc::c_int);
        } else {
            fprintf(
                stderr,
                b"Usage: .stats ?on|off|stmt|vmstep?\n\0" as *const u8
                    as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 't' as i32 && n > 1 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"tables\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
        || c == 'i' as i32
            && (cli_strncmp(
                azArg[0 as libc::c_int as usize],
                b"indices\0" as *const u8 as *const libc::c_char,
                n as size_t,
            ) == 0 as libc::c_int
                || cli_strncmp(
                    azArg[0 as libc::c_int as usize],
                    b"indexes\0" as *const u8 as *const libc::c_char,
                    n as size_t,
                ) == 0 as libc::c_int)
    {
        let mut pStmt_8: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        let mut azResult: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
        let mut nRow: libc::c_int = 0;
        let mut nAlloc: libc::c_int = 0;
        let mut ii_1: libc::c_int = 0;
        let mut s: ShellText = ShellText {
            z: 0 as *mut libc::c_char,
            n: 0,
            nAlloc: 0,
        };
        initText(&mut s);
        open_db(p, 0 as libc::c_int);
        rc = sqlite3_prepare_v2(
            (*p).db,
            b"PRAGMA database_list\0" as *const u8 as *const libc::c_char,
            -(1 as libc::c_int),
            &mut pStmt_8,
            0 as *mut *const libc::c_char,
        );
        if rc != 0 {
            sqlite3_finalize(pStmt_8);
            return shellDatabaseError((*p).db);
        }
        if nArg > 2 as libc::c_int && c == 'i' as i32 {
            fprintf(
                stderr,
                b"Usage: .indexes ?LIKE-PATTERN?\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
            sqlite3_finalize(pStmt_8);
        } else {
            ii_1 = 0 as libc::c_int;
            while sqlite3_step(pStmt_8) == 100 as libc::c_int {
                let mut zDbName: *const libc::c_char = sqlite3_column_text(
                    pStmt_8,
                    1 as libc::c_int,
                ) as *const libc::c_char;
                if !zDbName.is_null() {
                    if !(s.z).is_null()
                        && *(s.z).offset(0 as libc::c_int as isize) as libc::c_int != 0
                    {
                        appendText(
                            &mut s,
                            b" UNION ALL \0" as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                    }
                    if sqlite3_stricmp(
                        zDbName,
                        b"main\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                    {
                        appendText(
                            &mut s,
                            b"SELECT name FROM \0" as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                    } else {
                        appendText(
                            &mut s,
                            b"SELECT \0" as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                        appendText(&mut s, zDbName, '\'' as i32 as libc::c_char);
                        appendText(
                            &mut s,
                            b"||'.'||name FROM \0" as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                    }
                    appendText(&mut s, zDbName, '"' as i32 as libc::c_char);
                    appendText(
                        &mut s,
                        b".sqlite_schema \0" as *const u8 as *const libc::c_char,
                        0 as libc::c_int as libc::c_char,
                    );
                    if c == 't' as i32 {
                        appendText(
                            &mut s,
                            b" WHERE type IN ('table','view')   AND name NOT LIKE 'sqlite_%'   AND name LIKE ?1\0"
                                as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                    } else {
                        appendText(
                            &mut s,
                            b" WHERE type='index'   AND tbl_name LIKE ?1\0" as *const u8
                                as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                    }
                }
                ii_1 += 1;
            }
            rc = sqlite3_finalize(pStmt_8);
            if rc == 0 as libc::c_int {
                appendText(
                    &mut s,
                    b" ORDER BY 1\0" as *const u8 as *const libc::c_char,
                    0 as libc::c_int as libc::c_char,
                );
                rc = sqlite3_prepare_v2(
                    (*p).db,
                    s.z,
                    -(1 as libc::c_int),
                    &mut pStmt_8,
                    0 as *mut *const libc::c_char,
                );
            }
            freeText(&mut s);
            if rc != 0 {
                return shellDatabaseError((*p).db);
            }
            nAlloc = 0 as libc::c_int;
            nRow = nAlloc;
            azResult = 0 as *mut *mut libc::c_char;
            if nArg > 1 as libc::c_int {
                sqlite3_bind_text(
                    pStmt_8,
                    1 as libc::c_int,
                    azArg[1 as libc::c_int as usize],
                    -(1 as libc::c_int),
                    ::std::mem::transmute::<
                        libc::intptr_t,
                        sqlite3_destructor_type,
                    >(-(1 as libc::c_int) as libc::intptr_t),
                );
            } else {
                sqlite3_bind_text(
                    pStmt_8,
                    1 as libc::c_int,
                    b"%\0" as *const u8 as *const libc::c_char,
                    -(1 as libc::c_int),
                    None,
                );
            }
            while sqlite3_step(pStmt_8) == 100 as libc::c_int {
                if nRow >= nAlloc {
                    let mut azNew: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
                    let mut n2_2: libc::c_int = nAlloc * 2 as libc::c_int
                        + 10 as libc::c_int;
                    azNew = sqlite3_realloc64(
                        azResult as *mut libc::c_void,
                        (::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong)
                            .wrapping_mul(n2_2 as libc::c_ulong) as sqlite3_uint64,
                    ) as *mut *mut libc::c_char;
                    shell_check_oom(azNew as *mut libc::c_void);
                    nAlloc = n2_2;
                    azResult = azNew;
                }
                let ref mut fresh453 = *azResult.offset(nRow as isize);
                *fresh453 = sqlite3_mprintf(
                    b"%s\0" as *const u8 as *const libc::c_char,
                    sqlite3_column_text(pStmt_8, 0 as libc::c_int),
                );
                shell_check_oom(*azResult.offset(nRow as isize) as *mut libc::c_void);
                nRow += 1;
            }
            if sqlite3_finalize(pStmt_8) != 0 as libc::c_int {
                rc = shellDatabaseError((*p).db);
            }
            if rc == 0 as libc::c_int && nRow > 0 as libc::c_int {
                let mut len_0: libc::c_int = 0;
                let mut maxlen: libc::c_int = 0 as libc::c_int;
                let mut i_16: libc::c_int = 0;
                let mut j_1: libc::c_int = 0;
                let mut nPrintCol: libc::c_int = 0;
                let mut nPrintRow: libc::c_int = 0;
                i_16 = 0 as libc::c_int;
                while i_16 < nRow {
                    len_0 = strlen30(*azResult.offset(i_16 as isize));
                    if len_0 > maxlen {
                        maxlen = len_0;
                    }
                    i_16 += 1;
                }
                nPrintCol = 80 as libc::c_int / (maxlen + 2 as libc::c_int);
                if nPrintCol < 1 as libc::c_int {
                    nPrintCol = 1 as libc::c_int;
                }
                nPrintRow = (nRow + nPrintCol - 1 as libc::c_int) / nPrintCol;
                i_16 = 0 as libc::c_int;
                while i_16 < nPrintRow {
                    j_1 = i_16;
                    while j_1 < nRow {
                        let mut zSp: *mut libc::c_char = (if j_1 < nPrintRow {
                            b"\0" as *const u8 as *const libc::c_char
                        } else {
                            b"  \0" as *const u8 as *const libc::c_char
                        }) as *mut libc::c_char;
                        fprintf(
                            (*p).out,
                            b"%s%-*s\0" as *const u8 as *const libc::c_char,
                            zSp,
                            maxlen,
                            if !(*azResult.offset(j_1 as isize)).is_null() {
                                *azResult.offset(j_1 as isize) as *const libc::c_char
                            } else {
                                b"\0" as *const u8 as *const libc::c_char
                            },
                        );
                        j_1 += nPrintRow;
                    }
                    fprintf((*p).out, b"\n\0" as *const u8 as *const libc::c_char);
                    i_16 += 1;
                }
            }
            ii_1 = 0 as libc::c_int;
            while ii_1 < nRow {
                sqlite3_free(*azResult.offset(ii_1 as isize) as *mut libc::c_void);
                ii_1 += 1;
            }
            sqlite3_free(azResult as *mut libc::c_void);
        }
    } else if c == 't' as i32
        && cli_strcmp(
            azArg[0 as libc::c_int as usize],
            b"testcase\0" as *const u8 as *const libc::c_char,
        ) == 0 as libc::c_int
    {
        output_reset(p);
        let ref mut fresh454 = (*p).out;
        *fresh454 = output_file_open(
            b"testcase-out.txt\0" as *const u8 as *const libc::c_char,
            0 as libc::c_int,
        );
        if ((*p).out).is_null() {
            fprintf(
                stderr,
                b"Error: cannot open 'testcase-out.txt'\n\0" as *const u8
                    as *const libc::c_char,
            );
        }
        if nArg >= 2 as libc::c_int {
            sqlite3_snprintf(
                ::std::mem::size_of::<[libc::c_char; 30]>() as libc::c_ulong
                    as libc::c_int,
                ((*p).zTestcase).as_mut_ptr(),
                b"%s\0" as *const u8 as *const libc::c_char,
                azArg[1 as libc::c_int as usize],
            );
        } else {
            sqlite3_snprintf(
                ::std::mem::size_of::<[libc::c_char; 30]>() as libc::c_ulong
                    as libc::c_int,
                ((*p).zTestcase).as_mut_ptr(),
                b"?\0" as *const u8 as *const libc::c_char,
            );
        }
    } else if c == 't' as i32 && n >= 8 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"testctrl\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        static mut aCtrl_0: [C2RustUnnamed_19; 16] = [
            {
                let mut init = C2RustUnnamed_19 {
                    zCtrlName: b"always\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 13 as libc::c_int,
                    unSafe: 1 as libc::c_int,
                    zUsage: b"BOOLEAN\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_19 {
                    zCtrlName: b"assert\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 12 as libc::c_int,
                    unSafe: 1 as libc::c_int,
                    zUsage: b"BOOLEAN\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_19 {
                    zCtrlName: b"byteorder\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 22 as libc::c_int,
                    unSafe: 0 as libc::c_int,
                    zUsage: b"\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_19 {
                    zCtrlName: b"extra_schema_checks\0" as *const u8
                        as *const libc::c_char,
                    ctrlCode: 29 as libc::c_int,
                    unSafe: 0 as libc::c_int,
                    zUsage: b"BOOLEAN\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_19 {
                    zCtrlName: b"imposter\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 25 as libc::c_int,
                    unSafe: 1 as libc::c_int,
                    zUsage: b"SCHEMA ON/OFF ROOTPAGE\0" as *const u8
                        as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_19 {
                    zCtrlName: b"internal_functions\0" as *const u8
                        as *const libc::c_char,
                    ctrlCode: 17 as libc::c_int,
                    unSafe: 0 as libc::c_int,
                    zUsage: b"\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_19 {
                    zCtrlName: b"localtime_fault\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 18 as libc::c_int,
                    unSafe: 0 as libc::c_int,
                    zUsage: b"BOOLEAN\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_19 {
                    zCtrlName: b"never_corrupt\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 20 as libc::c_int,
                    unSafe: 1 as libc::c_int,
                    zUsage: b"BOOLEAN\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_19 {
                    zCtrlName: b"optimizations\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 15 as libc::c_int,
                    unSafe: 0 as libc::c_int,
                    zUsage: b"DISABLE-MASK\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_19 {
                    zCtrlName: b"pending_byte\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 11 as libc::c_int,
                    unSafe: 0 as libc::c_int,
                    zUsage: b"OFFSET  \0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_19 {
                    zCtrlName: b"prng_restore\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 6 as libc::c_int,
                    unSafe: 0 as libc::c_int,
                    zUsage: b"\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_19 {
                    zCtrlName: b"prng_save\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 5 as libc::c_int,
                    unSafe: 0 as libc::c_int,
                    zUsage: b"\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_19 {
                    zCtrlName: b"prng_seed\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 28 as libc::c_int,
                    unSafe: 0 as libc::c_int,
                    zUsage: b"SEED ?db?\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_19 {
                    zCtrlName: b"seek_count\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 30 as libc::c_int,
                    unSafe: 0 as libc::c_int,
                    zUsage: b"\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_19 {
                    zCtrlName: b"sorter_mmap\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 24 as libc::c_int,
                    unSafe: 0 as libc::c_int,
                    zUsage: b"NMAX\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let mut init = C2RustUnnamed_19 {
                    zCtrlName: b"tune\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 32 as libc::c_int,
                    unSafe: 1 as libc::c_int,
                    zUsage: b"ID VALUE\0" as *const u8 as *const libc::c_char,
                };
                init
            },
        ];
        let mut testctrl: libc::c_int = -(1 as libc::c_int);
        let mut iCtrl_0: libc::c_int = -(1 as libc::c_int);
        let mut rc2: libc::c_int = 0 as libc::c_int;
        let mut isOk_0: libc::c_int = 0 as libc::c_int;
        let mut i_17: libc::c_int = 0;
        let mut n2_3: libc::c_int = 0;
        let mut zCmd_1: *const libc::c_char = 0 as *const libc::c_char;
        open_db(p, 0 as libc::c_int);
        zCmd_1 = if nArg >= 2 as libc::c_int {
            azArg[1 as libc::c_int as usize] as *const libc::c_char
        } else {
            b"help\0" as *const u8 as *const libc::c_char
        };
        if *zCmd_1.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
            && *zCmd_1.offset(1 as libc::c_int as isize) as libc::c_int != 0
        {
            zCmd_1 = zCmd_1.offset(1);
            if *zCmd_1.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
                && *zCmd_1.offset(1 as libc::c_int as isize) as libc::c_int != 0
            {
                zCmd_1 = zCmd_1.offset(1);
            }
        }
        if cli_strcmp(zCmd_1, b"help\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            fprintf(
                (*p).out,
                b"Available test-controls:\n\0" as *const u8 as *const libc::c_char,
            );
            i_17 = 0 as libc::c_int;
            while i_17
                < (::std::mem::size_of::<[C2RustUnnamed_19; 16]>() as libc::c_ulong)
                    .wrapping_div(
                        ::std::mem::size_of::<C2RustUnnamed_19>() as libc::c_ulong,
                    ) as libc::c_int
            {
                fprintf(
                    (*p).out,
                    b"  .testctrl %s %s\n\0" as *const u8 as *const libc::c_char,
                    aCtrl_0[i_17 as usize].zCtrlName,
                    aCtrl_0[i_17 as usize].zUsage,
                );
                i_17 += 1;
            }
            rc = 1 as libc::c_int;
        } else {
            n2_3 = strlen30(zCmd_1);
            i_17 = 0 as libc::c_int;
            loop {
                if !(i_17
                    < (::std::mem::size_of::<[C2RustUnnamed_19; 16]>() as libc::c_ulong)
                        .wrapping_div(
                            ::std::mem::size_of::<C2RustUnnamed_19>() as libc::c_ulong,
                        ) as libc::c_int)
                {
                    current_block = 12138394770546653819;
                    break;
                }
                if cli_strncmp(zCmd_1, aCtrl_0[i_17 as usize].zCtrlName, n2_3 as size_t)
                    == 0 as libc::c_int
                {
                    if testctrl < 0 as libc::c_int {
                        testctrl = aCtrl_0[i_17 as usize].ctrlCode;
                        iCtrl_0 = i_17;
                    } else {
                        fprintf(
                            stderr,
                            b"Error: ambiguous test-control: \"%s\"\nUse \".testctrl --help\" for help\n\0"
                                as *const u8 as *const libc::c_char,
                            zCmd_1,
                        );
                        rc = 1 as libc::c_int;
                        current_block = 3081897820958806732;
                        break;
                    }
                }
                i_17 += 1;
            }
            match current_block {
                3081897820958806732 => {}
                _ => {
                    if testctrl < 0 as libc::c_int {
                        fprintf(
                            stderr,
                            b"Error: unknown test-control: %s\nUse \".testctrl --help\" for help\n\0"
                                as *const u8 as *const libc::c_char,
                            zCmd_1,
                        );
                    } else if aCtrl_0[iCtrl_0 as usize].unSafe != 0
                        && (*p).bSafeMode as libc::c_int != 0
                    {
                        fprintf(
                            stderr,
                            b"line %d: \".testctrl %s\" may not be used in safe mode\n\0"
                                as *const u8 as *const libc::c_char,
                            (*p).lineno,
                            aCtrl_0[iCtrl_0 as usize].zCtrlName,
                        );
                        exit(1 as libc::c_int);
                    } else {
                        match testctrl {
                            15 => {
                                if nArg == 3 as libc::c_int {
                                    let mut opt: libc::c_uint = strtol(
                                        azArg[2 as libc::c_int as usize],
                                        0 as *mut *mut libc::c_char,
                                        0 as libc::c_int,
                                    ) as libc::c_uint;
                                    rc2 = sqlite3_test_control(testctrl, (*p).db, opt);
                                    isOk_0 = 3 as libc::c_int;
                                }
                            }
                            5 | 6 | 22 => {
                                if nArg == 2 as libc::c_int {
                                    rc2 = sqlite3_test_control(testctrl);
                                    isOk_0 = if testctrl == 22 as libc::c_int {
                                        1 as libc::c_int
                                    } else {
                                        3 as libc::c_int
                                    };
                                }
                            }
                            11 => {
                                if nArg == 3 as libc::c_int {
                                    let mut opt_0: libc::c_uint = integerValue(
                                        azArg[2 as libc::c_int as usize],
                                    ) as libc::c_uint;
                                    rc2 = sqlite3_test_control(testctrl, opt_0);
                                    isOk_0 = 3 as libc::c_int;
                                }
                            }
                            28 => {
                                if nArg == 3 as libc::c_int || nArg == 4 as libc::c_int {
                                    let mut ii_2: libc::c_int = integerValue(
                                        azArg[2 as libc::c_int as usize],
                                    ) as libc::c_int;
                                    let mut db: *mut sqlite3 = 0 as *mut sqlite3;
                                    if ii_2 == 0 as libc::c_int
                                        && cli_strcmp(
                                            azArg[2 as libc::c_int as usize],
                                            b"random\0" as *const u8 as *const libc::c_char,
                                        ) == 0 as libc::c_int
                                    {
                                        sqlite3_randomness(
                                            ::std::mem::size_of::<libc::c_int>() as libc::c_ulong
                                                as libc::c_int,
                                            &mut ii_2 as *mut libc::c_int as *mut libc::c_void,
                                        );
                                        printf(
                                            b"-- random seed: %d\n\0" as *const u8
                                                as *const libc::c_char,
                                            ii_2,
                                        );
                                    }
                                    if nArg == 3 as libc::c_int {
                                        db = 0 as *mut sqlite3;
                                    } else {
                                        db = (*p).db;
                                        sqlite3_table_column_metadata(
                                            db,
                                            0 as *const libc::c_char,
                                            b"x\0" as *const u8 as *const libc::c_char,
                                            0 as *const libc::c_char,
                                            0 as *mut *const libc::c_char,
                                            0 as *mut *const libc::c_char,
                                            0 as *mut libc::c_int,
                                            0 as *mut libc::c_int,
                                            0 as *mut libc::c_int,
                                        );
                                    }
                                    rc2 = sqlite3_test_control(testctrl, ii_2, db);
                                    isOk_0 = 3 as libc::c_int;
                                }
                            }
                            12 | 13 => {
                                if nArg == 3 as libc::c_int {
                                    let mut opt_1: libc::c_int = booleanValue(
                                        azArg[2 as libc::c_int as usize],
                                    );
                                    rc2 = sqlite3_test_control(testctrl, opt_1);
                                    isOk_0 = 1 as libc::c_int;
                                }
                            }
                            18 | 20 => {
                                if nArg == 3 as libc::c_int {
                                    let mut opt_2: libc::c_int = booleanValue(
                                        azArg[2 as libc::c_int as usize],
                                    );
                                    rc2 = sqlite3_test_control(testctrl, opt_2);
                                    isOk_0 = 3 as libc::c_int;
                                }
                            }
                            17 => {
                                rc2 = sqlite3_test_control(testctrl, (*p).db);
                                isOk_0 = 3 as libc::c_int;
                            }
                            25 => {
                                if nArg == 5 as libc::c_int {
                                    rc2 = sqlite3_test_control(
                                        testctrl,
                                        (*p).db,
                                        azArg[2 as libc::c_int as usize],
                                        integerValue(azArg[3 as libc::c_int as usize]),
                                        integerValue(azArg[4 as libc::c_int as usize]),
                                    );
                                    isOk_0 = 3 as libc::c_int;
                                }
                            }
                            30 => {
                                let mut x_5: u64_0 = 0 as libc::c_int as u64_0;
                                rc2 = sqlite3_test_control(
                                    testctrl,
                                    (*p).db,
                                    &mut x_5 as *mut u64_0,
                                );
                                fprintf(
                                    (*p).out,
                                    b"%llu\n\0" as *const u8 as *const libc::c_char,
                                    x_5,
                                );
                                isOk_0 = 3 as libc::c_int;
                            }
                            24 => {
                                if nArg == 3 as libc::c_int {
                                    let mut opt_3: libc::c_int = integerValue(
                                        azArg[2 as libc::c_int as usize],
                                    ) as libc::c_uint as libc::c_int;
                                    rc2 = sqlite3_test_control(testctrl, (*p).db, opt_3);
                                    isOk_0 = 3 as libc::c_int;
                                }
                            }
                            _ => {}
                        }
                    }
                    if isOk_0 == 0 as libc::c_int && iCtrl_0 >= 0 as libc::c_int {
                        fprintf(
                            (*p).out,
                            b"Usage: .testctrl %s %s\n\0" as *const u8
                                as *const libc::c_char,
                            zCmd_1,
                            aCtrl_0[iCtrl_0 as usize].zUsage,
                        );
                        rc = 1 as libc::c_int;
                    } else if isOk_0 == 1 as libc::c_int {
                        fprintf(
                            (*p).out,
                            b"%d\n\0" as *const u8 as *const libc::c_char,
                            rc2,
                        );
                    } else if isOk_0 == 2 as libc::c_int {
                        fprintf(
                            (*p).out,
                            b"0x%08x\n\0" as *const u8 as *const libc::c_char,
                            rc2,
                        );
                    }
                }
            }
        }
    } else if c == 't' as i32 && n > 4 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"timeout\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        open_db(p, 0 as libc::c_int);
        sqlite3_busy_timeout(
            (*p).db,
            if nArg >= 2 as libc::c_int {
                integerValue(azArg[1 as libc::c_int as usize]) as libc::c_int
            } else {
                0 as libc::c_int
            },
        );
    } else if c == 't' as i32 && n >= 5 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"timer\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        if nArg == 2 as libc::c_int {
            enableTimer = booleanValue(azArg[1 as libc::c_int as usize]);
            if enableTimer != 0 && 1 as libc::c_int == 0 {
                fprintf(
                    stderr,
                    b"Error: timer not available on this system.\n\0" as *const u8
                        as *const libc::c_char,
                );
                enableTimer = 0 as libc::c_int;
            }
        } else {
            fprintf(
                stderr,
                b"Usage: .timer on|off\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 't' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"trace\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut mType: libc::c_int = 0 as libc::c_int;
        let mut jj: libc::c_int = 0;
        open_db(p, 0 as libc::c_int);
        jj = 1 as libc::c_int;
        loop {
            if !(jj < nArg) {
                current_block = 7772455862054932419;
                break;
            }
            let mut z_11: *const libc::c_char = azArg[jj as usize];
            if *z_11.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                if optionMatch(z_11, b"expanded\0" as *const u8 as *const libc::c_char)
                    != 0
                {
                    (*p).eTraceType = 1 as libc::c_int as u8_0;
                } else if optionMatch(
                    z_11,
                    b"plain\0" as *const u8 as *const libc::c_char,
                ) != 0
                {
                    (*p).eTraceType = 0 as libc::c_int as u8_0;
                } else if optionMatch(
                    z_11,
                    b"profile\0" as *const u8 as *const libc::c_char,
                ) != 0
                {
                    mType |= 0x2 as libc::c_int;
                } else if optionMatch(z_11, b"row\0" as *const u8 as *const libc::c_char)
                    != 0
                {
                    mType |= 0x4 as libc::c_int;
                } else if optionMatch(
                    z_11,
                    b"stmt\0" as *const u8 as *const libc::c_char,
                ) != 0
                {
                    mType |= 0x1 as libc::c_int;
                } else if optionMatch(
                    z_11,
                    b"close\0" as *const u8 as *const libc::c_char,
                ) != 0
                {
                    mType |= 0x8 as libc::c_int;
                } else {
                    fprintf(
                        stderr,
                        b"Unknown option \"%s\" on \".trace\"\n\0" as *const u8
                            as *const libc::c_char,
                        z_11,
                    );
                    rc = 1 as libc::c_int;
                    current_block = 3081897820958806732;
                    break;
                }
            } else {
                output_file_close((*p).traceOut);
                let ref mut fresh455 = (*p).traceOut;
                *fresh455 = output_file_open(z_11, 0 as libc::c_int);
            }
            jj += 1;
        }
        match current_block {
            3081897820958806732 => {}
            _ => {
                if ((*p).traceOut).is_null() {
                    sqlite3_trace_v2(
                        (*p).db,
                        0 as libc::c_int as libc::c_uint,
                        None,
                        0 as *mut libc::c_void,
                    );
                } else {
                    if mType == 0 as libc::c_int {
                        mType = 0x1 as libc::c_int;
                    }
                    sqlite3_trace_v2(
                        (*p).db,
                        mType as libc::c_uint,
                        Some(
                            sql_trace_callback
                                as unsafe extern "C" fn(
                                    libc::c_uint,
                                    *mut libc::c_void,
                                    *mut libc::c_void,
                                    *mut libc::c_void,
                                ) -> libc::c_int,
                        ),
                        p as *mut libc::c_void,
                    );
                }
            }
        }
    } else if c == 'v' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"version\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        fprintf(
            (*p).out,
            b"libSQL %s (based on SQLite %s) %s\n\0" as *const u8 as *const libc::c_char,
            libsql_libversion(),
            sqlite3_libversion(),
            sqlite3_sourceid(),
        );
        fprintf(
            (*p).out,
            b"zlib version %s\n\0" as *const u8 as *const libc::c_char,
            zlibVersion(),
        );
        fprintf((*p).out, b"clang-14.0.6\n\0" as *const u8 as *const libc::c_char);
    } else if c == 'v' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"vfsinfo\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut zDbName_0: *const libc::c_char = if nArg == 2 as libc::c_int {
            azArg[1 as libc::c_int as usize] as *const libc::c_char
        } else {
            b"main\0" as *const u8 as *const libc::c_char
        };
        let mut pVfs: *mut sqlite3_vfs = 0 as *mut sqlite3_vfs;
        if !((*p).db).is_null() {
            sqlite3_file_control(
                (*p).db,
                zDbName_0,
                27 as libc::c_int,
                &mut pVfs as *mut *mut sqlite3_vfs as *mut libc::c_void,
            );
            if !pVfs.is_null() {
                fprintf(
                    (*p).out,
                    b"vfs.zName      = \"%s\"\n\0" as *const u8 as *const libc::c_char,
                    (*pVfs).zName,
                );
                fprintf(
                    (*p).out,
                    b"vfs.iVersion   = %d\n\0" as *const u8 as *const libc::c_char,
                    (*pVfs).iVersion,
                );
                fprintf(
                    (*p).out,
                    b"vfs.szOsFile   = %d\n\0" as *const u8 as *const libc::c_char,
                    (*pVfs).szOsFile,
                );
                fprintf(
                    (*p).out,
                    b"vfs.mxPathname = %d\n\0" as *const u8 as *const libc::c_char,
                    (*pVfs).mxPathname,
                );
            }
        }
    } else if c == 'v' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"vfslist\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut pVfs_0: *mut sqlite3_vfs = 0 as *mut sqlite3_vfs;
        let mut pCurrent: *mut sqlite3_vfs = 0 as *mut sqlite3_vfs;
        if !((*p).db).is_null() {
            sqlite3_file_control(
                (*p).db,
                b"main\0" as *const u8 as *const libc::c_char,
                27 as libc::c_int,
                &mut pCurrent as *mut *mut sqlite3_vfs as *mut libc::c_void,
            );
        }
        pVfs_0 = sqlite3_vfs_find(0 as *const libc::c_char);
        while !pVfs_0.is_null() {
            fprintf(
                (*p).out,
                b"vfs.zName      = \"%s\"%s\n\0" as *const u8 as *const libc::c_char,
                (*pVfs_0).zName,
                if pVfs_0 == pCurrent {
                    b"  <--- CURRENT\0" as *const u8 as *const libc::c_char
                } else {
                    b"\0" as *const u8 as *const libc::c_char
                },
            );
            fprintf(
                (*p).out,
                b"vfs.iVersion   = %d\n\0" as *const u8 as *const libc::c_char,
                (*pVfs_0).iVersion,
            );
            fprintf(
                (*p).out,
                b"vfs.szOsFile   = %d\n\0" as *const u8 as *const libc::c_char,
                (*pVfs_0).szOsFile,
            );
            fprintf(
                (*p).out,
                b"vfs.mxPathname = %d\n\0" as *const u8 as *const libc::c_char,
                (*pVfs_0).mxPathname,
            );
            if !((*pVfs_0).pNext).is_null() {
                fprintf(
                    (*p).out,
                    b"-----------------------------------\n\0" as *const u8
                        as *const libc::c_char,
                );
            }
            pVfs_0 = (*pVfs_0).pNext;
        }
    } else if c == 'v' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"vfsname\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut zDbName_1: *const libc::c_char = if nArg == 2 as libc::c_int {
            azArg[1 as libc::c_int as usize] as *const libc::c_char
        } else {
            b"main\0" as *const u8 as *const libc::c_char
        };
        let mut zVfsName: *mut libc::c_char = 0 as *mut libc::c_char;
        if !((*p).db).is_null() {
            sqlite3_file_control(
                (*p).db,
                zDbName_1,
                12 as libc::c_int,
                &mut zVfsName as *mut *mut libc::c_char as *mut libc::c_void,
            );
            if !zVfsName.is_null() {
                fprintf(
                    (*p).out,
                    b"%s\n\0" as *const u8 as *const libc::c_char,
                    zVfsName,
                );
                sqlite3_free(zVfsName as *mut libc::c_void);
            }
        }
    } else if c == 'w' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"wheretrace\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut x_6: libc::c_uint = if nArg >= 2 as libc::c_int {
            integerValue(azArg[1 as libc::c_int as usize]) as libc::c_uint
        } else {
            0xffffffff as libc::c_uint
        };
        sqlite3_test_control(
            31 as libc::c_int,
            3 as libc::c_int,
            &mut x_6 as *mut libc::c_uint,
        );
    } else if c == 'w' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"width\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut j_2: libc::c_int = 0;
        (*p).nWidth = nArg - 1 as libc::c_int;
        let ref mut fresh456 = (*p).colWidth;
        *fresh456 = realloc(
            (*p).colWidth as *mut libc::c_void,
            (((*p).nWidth + 1 as libc::c_int) as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<libc::c_int>() as libc::c_ulong)
                .wrapping_mul(2 as libc::c_int as libc::c_ulong),
        ) as *mut libc::c_int;
        if ((*p).colWidth).is_null() && (*p).nWidth > 0 as libc::c_int {
            shell_out_of_memory();
        }
        if (*p).nWidth != 0 {
            let ref mut fresh457 = (*p).actualWidth;
            *fresh457 = &mut *((*p).colWidth).offset((*p).nWidth as isize)
                as *mut libc::c_int;
        }
        j_2 = 1 as libc::c_int;
        while j_2 < nArg {
            *((*p).colWidth)
                .offset(
                    (j_2 - 1 as libc::c_int) as isize,
                ) = integerValue(azArg[j_2 as usize]) as libc::c_int;
            j_2 += 1;
        }
    } else {
        fprintf(
            stderr,
            b"Error: unknown command or invalid arguments:  \"%s\". Enter \".help\" for help\n\0"
                as *const u8 as *const libc::c_char,
            azArg[0 as libc::c_int as usize],
        );
        rc = 1 as libc::c_int;
    }
    if (*p).outCount != 0 {
        let ref mut fresh458 = (*p).outCount;
        *fresh458 -= 1;
        if (*p).outCount == 0 as libc::c_int {
            output_reset(p);
        }
    }
    (*p).bSafeMode = (*p).bSafeModePersist;
    return rc;
}
unsafe extern "C" fn quickscan(
    mut zLine: *mut libc::c_char,
    mut qss: QuickScanState,
) -> QuickScanState {
    let mut current_block: u64;
    let mut cin: libc::c_char = 0;
    let mut cWait: libc::c_char = qss as libc::c_char;
    if cWait as libc::c_int == 0 as libc::c_int {
        current_block = 10680521327981672866;
    } else {
        current_block = 16203760046146113240;
    }
    's_19: loop {
        match current_block {
            10680521327981672866 => {
                let fresh459 = zLine;
                zLine = zLine.offset(1);
                cin = *fresh459;
                if !(cin as libc::c_int != 0 as libc::c_int) {
                    break;
                }
                if *(*__ctype_b_loc())
                    .offset(cin as libc::c_uchar as libc::c_int as isize) as libc::c_int
                    & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0
                {
                    current_block = 10680521327981672866;
                    continue;
                }
                match cin as libc::c_int {
                    45 => {
                        if *zLine as libc::c_int != '-' as i32 {
                            current_block = 1109700713171191020;
                        } else {
                            loop {
                                zLine = zLine.offset(1);
                                cin = *zLine;
                                if !(cin as libc::c_int != 0 as libc::c_int) {
                                    break;
                                }
                                if cin as libc::c_int == '\n' as i32 {
                                    current_block = 10680521327981672866;
                                    continue 's_19;
                                }
                            }
                            return qss;
                        }
                    }
                    59 => {
                        qss = ::std::mem::transmute::<
                            libc::c_uint,
                            QuickScanState,
                        >(
                            qss as libc::c_uint
                                | QSS_EndingSemi as libc::c_int as libc::c_uint,
                        );
                        current_block = 10680521327981672866;
                        continue;
                    }
                    47 => {
                        if *zLine as libc::c_int == '*' as i32 {
                            zLine = zLine.offset(1);
                            cWait = '*' as i32 as libc::c_char;
                            qss = (cWait as libc::c_uint
                                | qss as libc::c_uint
                                    & QSS_ScanMask as libc::c_int as libc::c_uint)
                                as QuickScanState;
                            current_block = 16203760046146113240;
                            continue;
                        } else {
                            current_block = 1109700713171191020;
                        }
                    }
                    91 => {
                        cin = ']' as i32 as libc::c_char;
                        current_block = 4517647163436632206;
                    }
                    96 | 39 | 34 => {
                        current_block = 4517647163436632206;
                    }
                    _ => {
                        current_block = 1109700713171191020;
                    }
                }
                match current_block {
                    1109700713171191020 => {
                        qss = (qss as libc::c_uint
                            & !(QSS_EndingSemi as libc::c_int) as libc::c_uint
                            | QSS_HasDark as libc::c_int as libc::c_uint)
                            as QuickScanState;
                        current_block = 10680521327981672866;
                    }
                    _ => {
                        cWait = cin;
                        qss = (QSS_HasDark as libc::c_int | cWait as libc::c_int)
                            as QuickScanState;
                        current_block = 16203760046146113240;
                    }
                }
            }
            _ => {
                let fresh460 = zLine;
                zLine = zLine.offset(1);
                cin = *fresh460;
                if !(cin as libc::c_int != 0 as libc::c_int) {
                    break;
                }
                if !(cin as libc::c_int == cWait as libc::c_int) {
                    current_block = 16203760046146113240;
                    continue;
                }
                match cWait as libc::c_int {
                    42 => {
                        if *zLine as libc::c_int != '/' as i32 {
                            current_block = 16203760046146113240;
                            continue;
                        }
                        zLine = zLine.offset(1);
                        cWait = 0 as libc::c_int as libc::c_char;
                        qss = (0 as libc::c_int as libc::c_uint
                            | qss as libc::c_uint
                                & QSS_ScanMask as libc::c_int as libc::c_uint)
                            as QuickScanState;
                        current_block = 10680521327981672866;
                        continue;
                    }
                    96 | 39 | 34 => {
                        if *zLine as libc::c_int == cWait as libc::c_int {
                            zLine = zLine.offset(1);
                            current_block = 16203760046146113240;
                            continue;
                        }
                    }
                    93 => {}
                    _ => {
                        current_block = 16203760046146113240;
                        continue;
                    }
                }
                cWait = 0 as libc::c_int as libc::c_char;
                qss = (0 as libc::c_int as libc::c_uint
                    | qss as libc::c_uint & QSS_ScanMask as libc::c_int as libc::c_uint)
                    as QuickScanState;
                current_block = 10680521327981672866;
            }
        }
    }
    return qss;
}
unsafe extern "C" fn line_is_command_terminator(
    mut zLine: *mut libc::c_char,
) -> libc::c_int {
    while *(*__ctype_b_loc())
        .offset(
            *zLine.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                as isize,
        ) as libc::c_int & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0
    {
        zLine = zLine.offset(1);
    }
    if *zLine.offset(0 as libc::c_int as isize) as libc::c_int == '/' as i32 {
        zLine = zLine.offset(1 as libc::c_int as isize);
    } else if ({
        let mut __res: libc::c_int = 0;
        if ::std::mem::size_of::<libc::c_uchar>() as libc::c_ulong
            > 1 as libc::c_int as libc::c_ulong
        {
            if 0 != 0 {
                let mut __c: libc::c_int = *zLine.offset(0 as libc::c_int as isize)
                    as libc::c_uchar as libc::c_int;
                __res = (if __c < -(128 as libc::c_int) || __c > 255 as libc::c_int {
                    __c
                } else {
                    *(*__ctype_tolower_loc()).offset(__c as isize)
                });
            } else {
                __res = tolower(
                    *zLine.offset(0 as libc::c_int as isize) as libc::c_uchar
                        as libc::c_int,
                );
            }
        } else {
            __res = *(*__ctype_tolower_loc())
                .offset(
                    *zLine.offset(0 as libc::c_int as isize) as libc::c_uchar
                        as libc::c_int as isize,
                );
        }
        __res
    }) as libc::c_char as libc::c_int == 'g' as i32
        && ({
            let mut __res: libc::c_int = 0;
            if ::std::mem::size_of::<libc::c_uchar>() as libc::c_ulong
                > 1 as libc::c_int as libc::c_ulong
            {
                if 0 != 0 {
                    let mut __c: libc::c_int = *zLine.offset(1 as libc::c_int as isize)
                        as libc::c_uchar as libc::c_int;
                    __res = (if __c < -(128 as libc::c_int) || __c > 255 as libc::c_int {
                        __c
                    } else {
                        *(*__ctype_tolower_loc()).offset(__c as isize)
                    });
                } else {
                    __res = tolower(
                        *zLine.offset(1 as libc::c_int as isize) as libc::c_uchar
                            as libc::c_int,
                    );
                }
            } else {
                __res = *(*__ctype_tolower_loc())
                    .offset(
                        *zLine.offset(1 as libc::c_int as isize) as libc::c_uchar
                            as libc::c_int as isize,
                    );
            }
            __res
        }) as libc::c_char as libc::c_int == 'o' as i32
    {
        zLine = zLine.offset(2 as libc::c_int as isize);
    } else {
        return 0 as libc::c_int
    }
    return (quickscan(zLine, QSS_Start) as libc::c_uint
        == QSS_Start as libc::c_int as libc::c_uint) as libc::c_int;
}
unsafe extern "C" fn line_is_complete(
    mut zSql: *mut libc::c_char,
    mut nSql: libc::c_int,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    if zSql.is_null() {
        return 1 as libc::c_int;
    }
    *zSql.offset(nSql as isize) = ';' as i32 as libc::c_char;
    *zSql.offset((nSql + 1 as libc::c_int) as isize) = 0 as libc::c_int as libc::c_char;
    rc = sqlite3_complete(zSql);
    *zSql.offset(nSql as isize) = 0 as libc::c_int as libc::c_char;
    return rc;
}
unsafe extern "C" fn runOneSqlLine(
    mut p: *mut ShellState,
    mut zSql: *mut libc::c_char,
    mut in_0: *mut FILE,
    mut startline: libc::c_int,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    let mut zErrMsg: *mut libc::c_char = 0 as *mut libc::c_char;
    open_db(p, 0 as libc::c_int);
    if (*p).shellFlgs & 0x4 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint
    {
        resolve_backslashes(zSql);
    }
    if (*p).flgProgress & 0x2 as libc::c_int as libc::c_uint != 0 {
        (*p).nProgress = 0 as libc::c_int as libc::c_uint;
    }
    beginTimer();
    rc = shell_exec(p, zSql, &mut zErrMsg);
    endTimer();
    if rc != 0 || !zErrMsg.is_null() {
        let mut zPrefix: [libc::c_char; 100] = [0; 100];
        let mut zErrorTail: *const libc::c_char = 0 as *const libc::c_char;
        let mut zErrorType: *const libc::c_char = 0 as *const libc::c_char;
        if zErrMsg.is_null() {
            zErrorType = b"Error\0" as *const u8 as *const libc::c_char;
            zErrorTail = sqlite3_errmsg((*p).db);
        } else if cli_strncmp(
            zErrMsg,
            b"in prepare, \0" as *const u8 as *const libc::c_char,
            12 as libc::c_int as size_t,
        ) == 0 as libc::c_int
        {
            zErrorType = b"Parse error\0" as *const u8 as *const libc::c_char;
            zErrorTail = &mut *zErrMsg.offset(12 as libc::c_int as isize)
                as *mut libc::c_char;
        } else if cli_strncmp(
            zErrMsg,
            b"stepping, \0" as *const u8 as *const libc::c_char,
            10 as libc::c_int as size_t,
        ) == 0 as libc::c_int
        {
            zErrorType = b"Runtime error\0" as *const u8 as *const libc::c_char;
            zErrorTail = &mut *zErrMsg.offset(10 as libc::c_int as isize)
                as *mut libc::c_char;
        } else {
            zErrorType = b"Error\0" as *const u8 as *const libc::c_char;
            zErrorTail = zErrMsg;
        }
        if !in_0.is_null() || stdin_is_interactive == 0 {
            sqlite3_snprintf(
                ::std::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong
                    as libc::c_int,
                zPrefix.as_mut_ptr(),
                b"%s near line %d:\0" as *const u8 as *const libc::c_char,
                zErrorType,
                startline,
            );
        } else {
            sqlite3_snprintf(
                ::std::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong
                    as libc::c_int,
                zPrefix.as_mut_ptr(),
                b"%s:\0" as *const u8 as *const libc::c_char,
                zErrorType,
            );
        }
        fprintf(
            stderr,
            b"%s %s\n\0" as *const u8 as *const libc::c_char,
            zPrefix.as_mut_ptr(),
            zErrorTail,
        );
        sqlite3_free(zErrMsg as *mut libc::c_void);
        zErrMsg = 0 as *mut libc::c_char;
        return 1 as libc::c_int;
    } else {
        if (*p).shellFlgs & 0x20 as libc::c_int as libc::c_uint
            != 0 as libc::c_int as libc::c_uint
        {
            let mut zLineBuf: [libc::c_char; 2000] = [0; 2000];
            sqlite3_snprintf(
                ::std::mem::size_of::<[libc::c_char; 2000]>() as libc::c_ulong
                    as libc::c_int,
                zLineBuf.as_mut_ptr(),
                b"changes: %lld   total_changes: %lld\0" as *const u8
                    as *const libc::c_char,
                sqlite3_changes64((*p).db),
                sqlite3_total_changes64((*p).db),
            );
            fprintf(
                (*p).out,
                b"%s\n\0" as *const u8 as *const libc::c_char,
                zLineBuf.as_mut_ptr(),
            );
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn echo_group_input(
    mut p: *mut ShellState,
    mut zDo: *const libc::c_char,
) {
    if (*p).shellFlgs & 0x40 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint
    {
        fprintf((*p).out, b"%s\n\0" as *const u8 as *const libc::c_char, zDo);
    }
}
unsafe extern "C" fn process_input(mut p: *mut ShellState) -> libc::c_int {
    let mut zLine: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut nLine: i64_0 = 0;
    let mut nSql: i64_0 = 0 as libc::c_int as i64_0;
    let mut nAlloc: i64_0 = 0 as libc::c_int as i64_0;
    let mut rc: libc::c_int = 0;
    let mut errCnt: libc::c_int = 0 as libc::c_int;
    let mut startline: i64_0 = 0 as libc::c_int as i64_0;
    let mut qss: QuickScanState = QSS_Start;
    if (*p).inputNesting == 25 as libc::c_int {
        fprintf(
            stderr,
            b"Input nesting limit (%d) reached at line %d. Check recursion.\n\0"
                as *const u8 as *const libc::c_char,
            25 as libc::c_int,
            (*p).lineno,
        );
        return 1 as libc::c_int;
    }
    let ref mut fresh461 = (*p).inputNesting;
    *fresh461 += 1;
    (*p).lineno = 0 as libc::c_int;
    while errCnt == 0 as libc::c_int || bail_on_error == 0
        || ((*p).in_0).is_null() && stdin_is_interactive != 0
    {
        fflush((*p).out);
        zLine = one_input_line(
            (*p).in_0,
            zLine,
            (nSql > 0 as libc::c_int as libc::c_longlong) as libc::c_int,
        );
        if zLine.is_null() {
            if ((*p).in_0).is_null() && stdin_is_interactive != 0 {
                printf(b"\n\0" as *const u8 as *const libc::c_char);
            }
            break;
        } else {
            if seenInterrupt != 0 {
                if !((*p).in_0).is_null() {
                    break;
                }
                ::std::ptr::write_volatile(
                    &mut seenInterrupt as *mut libc::c_int,
                    0 as libc::c_int,
                );
            }
            let ref mut fresh462 = (*p).lineno;
            *fresh462 += 1;
            if qss as libc::c_uint & QSS_CharMask as libc::c_int as libc::c_uint
                == QSS_Start as libc::c_int as libc::c_uint
                && line_is_command_terminator(zLine) != 0
                && line_is_complete(zSql, nSql as libc::c_int) != 0
            {
                memcpy(
                    zLine as *mut libc::c_void,
                    b";\0" as *const u8 as *const libc::c_char as *const libc::c_void,
                    2 as libc::c_int as libc::c_ulong,
                );
            }
            qss = quickscan(zLine, qss);
            if qss as libc::c_uint & !(QSS_EndingSemi as libc::c_int) as libc::c_uint
                == QSS_Start as libc::c_int as libc::c_uint
                && nSql == 0 as libc::c_int as libc::c_longlong
            {
                echo_group_input(p, zLine);
                qss = QSS_Start;
            } else if !zLine.is_null()
                && (*zLine.offset(0 as libc::c_int as isize) as libc::c_int == '.' as i32
                    || *zLine.offset(0 as libc::c_int as isize) as libc::c_int
                        == '#' as i32) && nSql == 0 as libc::c_int as libc::c_longlong
            {
                echo_group_input(p, zLine);
                if *zLine.offset(0 as libc::c_int as isize) as libc::c_int == '.' as i32
                {
                    rc = do_meta_command(zLine, p);
                    if rc == 2 as libc::c_int {
                        break;
                    }
                    if rc != 0 {
                        errCnt += 1;
                    }
                }
                qss = QSS_Start;
            } else {
                nLine = strlen(zLine) as i64_0;
                if nSql + nLine + 2 as libc::c_int as libc::c_longlong >= nAlloc {
                    nAlloc = nSql + (nSql >> 1 as libc::c_int) + nLine
                        + 100 as libc::c_int as libc::c_longlong;
                    zSql = realloc(zSql as *mut libc::c_void, nAlloc as libc::c_ulong)
                        as *mut libc::c_char;
                    shell_check_oom(zSql as *mut libc::c_void);
                }
                if nSql == 0 as libc::c_int as libc::c_longlong {
                    let mut i: i64_0 = 0;
                    i = 0 as libc::c_int as i64_0;
                    while *zLine.offset(i as isize) as libc::c_int != 0
                        && *(*__ctype_b_loc())
                            .offset(
                                *zLine.offset(i as isize) as libc::c_uchar as libc::c_int
                                    as isize,
                            ) as libc::c_int
                            & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                            != 0
                    {
                        i += 1;
                    }
                    memcpy(
                        zSql as *mut libc::c_void,
                        zLine.offset(i as isize) as *const libc::c_void,
                        (nLine + 1 as libc::c_int as libc::c_longlong - i)
                            as libc::c_ulong,
                    );
                    startline = (*p).lineno as i64_0;
                    nSql = nLine - i;
                } else {
                    let fresh463 = nSql;
                    nSql = nSql + 1;
                    *zSql.offset(fresh463 as isize) = '\n' as i32 as libc::c_char;
                    memcpy(
                        zSql.offset(nSql as isize) as *mut libc::c_void,
                        zLine as *const libc::c_void,
                        (nLine + 1 as libc::c_int as libc::c_longlong) as libc::c_ulong,
                    );
                    nSql += nLine;
                }
                if nSql != 0
                    && qss as libc::c_uint
                        & !(QSS_HasDark as libc::c_int) as libc::c_uint
                        == QSS_EndingSemi as libc::c_int as libc::c_uint
                    && sqlite3_complete(zSql) != 0
                {
                    echo_group_input(p, zSql);
                    errCnt
                        += runOneSqlLine(p, zSql, (*p).in_0, startline as libc::c_int);
                    nSql = 0 as libc::c_int as i64_0;
                    if (*p).outCount != 0 {
                        output_reset(p);
                        (*p).outCount = 0 as libc::c_int;
                    } else {
                        clearTempFile(p);
                    }
                    (*p).bSafeMode = (*p).bSafeModePersist;
                    qss = QSS_Start;
                } else if nSql != 0
                    && qss as libc::c_uint
                        & !(QSS_EndingSemi as libc::c_int) as libc::c_uint
                        == QSS_Start as libc::c_int as libc::c_uint
                {
                    echo_group_input(p, zSql);
                    nSql = 0 as libc::c_int as i64_0;
                    qss = QSS_Start;
                }
            }
        }
    }
    if nSql != 0 {
        echo_group_input(p, zSql);
        errCnt += runOneSqlLine(p, zSql, (*p).in_0, startline as libc::c_int);
    }
    free(zSql as *mut libc::c_void);
    free(zLine as *mut libc::c_void);
    let ref mut fresh464 = (*p).inputNesting;
    *fresh464 -= 1;
    return (errCnt > 0 as libc::c_int) as libc::c_int;
}
unsafe extern "C" fn find_home_dir(mut clearFlag: libc::c_int) -> *mut libc::c_char {
    static mut home_dir: *mut libc::c_char = 0 as *const libc::c_char
        as *mut libc::c_char;
    if clearFlag != 0 {
        free(home_dir as *mut libc::c_void);
        home_dir = 0 as *mut libc::c_char;
        return 0 as *mut libc::c_char;
    }
    if !home_dir.is_null() {
        return home_dir;
    }
    let mut pwent: *mut passwd = 0 as *mut passwd;
    let mut uid: uid_t = getuid();
    pwent = getpwuid(uid);
    if !pwent.is_null() {
        home_dir = (*pwent).pw_dir;
    }
    if home_dir.is_null() {
        home_dir = getenv(b"HOME\0" as *const u8 as *const libc::c_char);
    }
    if !home_dir.is_null() {
        let mut n: i64_0 = (strlen(home_dir))
            .wrapping_add(1 as libc::c_int as libc::c_ulong) as i64_0;
        let mut z: *mut libc::c_char = malloc(n as libc::c_ulong) as *mut libc::c_char;
        if !z.is_null() {
            memcpy(
                z as *mut libc::c_void,
                home_dir as *const libc::c_void,
                n as libc::c_ulong,
            );
        }
        home_dir = z;
    }
    return home_dir;
}
unsafe extern "C" fn find_xdg_config() -> *const libc::c_char {
    static mut alreadyTried: libc::c_int = 0 as libc::c_int;
    static mut zConfig: *mut libc::c_char = 0 as *const libc::c_char
        as *mut libc::c_char;
    let mut zXdgHome: *const libc::c_char = 0 as *const libc::c_char;
    if alreadyTried != 0 as libc::c_int {
        return zConfig;
    }
    alreadyTried = 1 as libc::c_int;
    zXdgHome = getenv(b"XDG_CONFIG_HOME\0" as *const u8 as *const libc::c_char);
    if zXdgHome.is_null() {
        return 0 as *const libc::c_char;
    }
    zConfig = sqlite3_mprintf(
        b"%s/sqlite3/sqliterc\0" as *const u8 as *const libc::c_char,
        zXdgHome,
    );
    shell_check_oom(zConfig as *mut libc::c_void);
    if access(zConfig, 0 as libc::c_int) != 0 as libc::c_int {
        sqlite3_free(zConfig as *mut libc::c_void);
        zConfig = 0 as *mut libc::c_char;
    }
    return zConfig;
}
unsafe extern "C" fn process_sqliterc(
    mut p: *mut ShellState,
    mut sqliterc_override: *const libc::c_char,
) {
    let mut home_dir: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut sqliterc: *const libc::c_char = sqliterc_override;
    let mut zBuf: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut inSaved: *mut FILE = (*p).in_0;
    let mut savedLineno: libc::c_int = (*p).lineno;
    if sqliterc.is_null() {
        sqliterc = find_xdg_config();
    }
    if sqliterc.is_null() {
        home_dir = find_home_dir(0 as libc::c_int);
        if home_dir.is_null() {
            fprintf(
                stderr,
                b"-- warning: cannot find home directory; cannot read ~/.sqliterc\n\0"
                    as *const u8 as *const libc::c_char,
            );
            return;
        }
        zBuf = sqlite3_mprintf(
            b"%s/.sqliterc\0" as *const u8 as *const libc::c_char,
            home_dir,
        );
        shell_check_oom(zBuf as *mut libc::c_void);
        sqliterc = zBuf;
    }
    let ref mut fresh465 = (*p).in_0;
    *fresh465 = fopen(sqliterc, b"rb\0" as *const u8 as *const libc::c_char);
    if !((*p).in_0).is_null() {
        if stdin_is_interactive != 0 {
            fprintf(
                stderr,
                b"-- Loading resources from %s\n\0" as *const u8 as *const libc::c_char,
                sqliterc,
            );
        }
        if process_input(p) != 0 && bail_on_error != 0 {
            exit(1 as libc::c_int);
        }
        fclose((*p).in_0);
    } else if !sqliterc_override.is_null() {
        fprintf(
            stderr,
            b"cannot open: \"%s\"\n\0" as *const u8 as *const libc::c_char,
            sqliterc,
        );
        if bail_on_error != 0 {
            exit(1 as libc::c_int);
        }
    }
    let ref mut fresh466 = (*p).in_0;
    *fresh466 = inSaved;
    (*p).lineno = savedLineno;
    sqlite3_free(zBuf as *mut libc::c_void);
}
static mut zOptions: [libc::c_char; 2151] = unsafe {
    *::std::mem::transmute::<
        &[u8; 2151],
        &[libc::c_char; 2151],
    >(
        b"   -A ARGS...           run \".archive ARGS\" and exit\n   -append              append the database to the end of the file\n   -ascii               set output mode to 'ascii'\n   -bail                stop after hitting an error\n   -batch               force batch I/O\n   -box                 set output mode to 'box'\n   -column              set output mode to 'column'\n   -cmd COMMAND         run \"COMMAND\" before reading stdin\n   -csv                 set output mode to 'csv'\n   -deserialize         open the database using sqlite3_deserialize()\n   -echo                print inputs before execution\n   -init FILENAME       read/process named file\n   -[no]header          turn headers on or off\n   -help                show this message\n   -html                set output mode to HTML\n   -interactive         force interactive I/O\n   -json                set output mode to 'json'\n   -line                set output mode to 'line'\n   -list                set output mode to 'list'\n   -lookaside SIZE N    use N entries of SZ bytes for lookaside memory\n   -markdown            set output mode to 'markdown'\n   -maxsize N           maximum size for a --deserialize database\n   -memtrace            trace all memory allocations and deallocations\n   -mmap N              default mmap size set to N\n   -newline SEP         set output row separator. Default: '\\n'\n   -nofollow            refuse to open symbolic links to database files\n   -nonce STRING        set the safe-mode escape nonce\n   -nullvalue TEXT      set text string for NULL values. Default ''\n   -pagecache SIZE N    use N slots of SZ bytes each for page cache memory\n   -quote               set output mode to 'quote'\n   -readonly            open the database read-only\n   -safe                enable safe-mode\n   -separator SEP       set output column separator. Default: '|'\n   -stats               print memory stats before each finalize\n   -table               set output mode to 'table'\n   -tabs                set output mode to 'tabs'\n   -version             show SQLite version\n   -vfs NAME            use NAME as the default VFS\n   -zip                 open the file as a ZIP Archive\n\0",
    )
};
unsafe extern "C" fn usage(mut showDetail: libc::c_int) {
    fprintf(
        stderr,
        b"Usage: %s [OPTIONS] FILENAME [SQL]\nFILENAME is the name of an SQLite database. A new database is created\nif the file does not previously exist.\n\0"
            as *const u8 as *const libc::c_char,
        Argv0,
    );
    if showDetail != 0 {
        fprintf(
            stderr,
            b"OPTIONS include:\n%s\0" as *const u8 as *const libc::c_char,
            zOptions.as_ptr(),
        );
    } else {
        fprintf(
            stderr,
            b"Use the -help option for additional information\n\0" as *const u8
                as *const libc::c_char,
        );
    }
    exit(1 as libc::c_int);
}
unsafe extern "C" fn verify_uninitialized() {
    if sqlite3_config(-(1 as libc::c_int)) == 21 as libc::c_int {
        fprintf(
            stdout,
            b"WARNING: attempt to configure SQLite after initialization.\n\0"
                as *const u8 as *const libc::c_char,
        );
    }
}
unsafe extern "C" fn main_init(mut data: *mut ShellState) {
    memset(
        data as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<ShellState>() as libc::c_ulong,
    );
    let ref mut fresh467 = (*data).mode;
    *fresh467 = 2 as libc::c_int;
    let ref mut fresh468 = (*data).cMode;
    *fresh468 = *fresh467;
    (*data).normalMode = *fresh468;
    (*data).autoExplain = 1 as libc::c_int as u8_0;
    let ref mut fresh469 = (*data).pAuxDb;
    *fresh469 = &mut *((*data).aAuxDb).as_mut_ptr().offset(0 as libc::c_int as isize)
        as *mut AuxDb;
    memcpy(
        ((*data).colSeparator).as_mut_ptr() as *mut libc::c_void,
        b"|\0" as *const u8 as *const libc::c_char as *const libc::c_void,
        2 as libc::c_int as libc::c_ulong,
    );
    memcpy(
        ((*data).rowSeparator).as_mut_ptr() as *mut libc::c_void,
        b"\n\0" as *const u8 as *const libc::c_char as *const libc::c_void,
        2 as libc::c_int as libc::c_ulong,
    );
    (*data).showHeader = 0 as libc::c_int;
    (*data).shellFlgs = 0x2 as libc::c_int as libc::c_uint;
    verify_uninitialized();
    sqlite3_config(17 as libc::c_int, 1 as libc::c_int);
    sqlite3_config(
        16 as libc::c_int,
        Some(
            shellLog
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    libc::c_int,
                    *const libc::c_char,
                ) -> (),
        ),
        data,
    );
    sqlite3_config(2 as libc::c_int);
    sqlite3_snprintf(
        ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as libc::c_int,
        mainPrompt.as_mut_ptr(),
        b"libsql> \0" as *const u8 as *const libc::c_char,
    );
    sqlite3_snprintf(
        ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as libc::c_int,
        continuePrompt.as_mut_ptr(),
        b"   ...> \0" as *const u8 as *const libc::c_char,
    );
}
unsafe extern "C" fn printBold(mut zText: *const libc::c_char) {
    printf(b"\x1B[1m%s\x1B[0m\0" as *const u8 as *const libc::c_char, zText);
}
unsafe extern "C" fn cmdline_option_value(
    mut argc: libc::c_int,
    mut argv: *mut *mut libc::c_char,
    mut i: libc::c_int,
) -> *mut libc::c_char {
    if i == argc {
        fprintf(
            stderr,
            b"%s: Error: missing argument to %s\n\0" as *const u8 as *const libc::c_char,
            *argv.offset(0 as libc::c_int as isize),
            *argv.offset((argc - 1 as libc::c_int) as isize),
        );
        exit(1 as libc::c_int);
    }
    return *argv.offset(i as isize);
}
unsafe fn main_0(
    mut argc: libc::c_int,
    mut argv: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut zErrMsg: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut data: ShellState = ShellState {
        db: 0 as *mut sqlite3,
        autoExplain: 0,
        autoEQP: 0,
        autoEQPtest: 0,
        autoEQPtrace: 0,
        scanstatsOn: 0,
        openMode: 0,
        doXdgOpen: 0,
        nEqpLevel: 0,
        eTraceType: 0,
        bSafeMode: 0,
        bSafeModePersist: 0,
        cmOpts: ColModeOpts {
            iWrap: 0,
            bQuote: 0,
            bWordWrap: 0,
        },
        statsOn: 0,
        mEqpLines: 0,
        inputNesting: 0,
        outCount: 0,
        cnt: 0,
        lineno: 0,
        openFlags: 0,
        in_0: 0 as *mut FILE,
        out: 0 as *mut FILE,
        traceOut: 0 as *mut FILE,
        nErr: 0,
        mode: 0,
        modePrior: 0,
        cMode: 0,
        normalMode: 0,
        writableSchema: 0,
        showHeader: 0,
        nCheck: 0,
        nProgress: 0,
        mxProgress: 0,
        flgProgress: 0,
        shellFlgs: 0,
        priorShFlgs: 0,
        szMax: 0,
        zDestTable: 0 as *mut libc::c_char,
        zTempFile: 0 as *mut libc::c_char,
        zTestcase: [0; 30],
        colSeparator: [0; 20],
        rowSeparator: [0; 20],
        colSepPrior: [0; 20],
        rowSepPrior: [0; 20],
        colWidth: 0 as *mut libc::c_int,
        actualWidth: 0 as *mut libc::c_int,
        nWidth: 0,
        nullValue: [0; 20],
        outfile: [0; 4096],
        pStmt: 0 as *mut sqlite3_stmt,
        pLog: 0 as *mut FILE,
        aAuxDb: [AuxDb {
            db: 0 as *mut sqlite3,
            zDbFilename: 0 as *const libc::c_char,
            zFreeOnClose: 0 as *mut libc::c_char,
        }; 5],
        pAuxDb: 0 as *mut AuxDb,
        aiIndent: 0 as *mut libc::c_int,
        nIndent: 0,
        iIndent: 0,
        zNonce: 0 as *mut libc::c_char,
        sGraph: EQPGraph {
            pRow: 0 as *mut EQPGraphRow,
            pLast: 0 as *mut EQPGraphRow,
            zPrefix: [0; 100],
        },
        expert: ExpertInfo {
            pExpert: 0 as *mut sqlite3expert,
            bVerbose: 0,
        },
    };
    let mut zInitFile: *const libc::c_char = 0 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut warnInmemoryDb: libc::c_int = 0 as libc::c_int;
    let mut readStdin: libc::c_int = 1 as libc::c_int;
    let mut nCmd: libc::c_int = 0 as libc::c_int;
    let mut azCmd: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
    let mut zVfs: *const libc::c_char = 0 as *const libc::c_char;
    setvbuf(
        stderr,
        0 as *mut libc::c_char,
        2 as libc::c_int,
        0 as libc::c_int as size_t,
    );
    stdin_is_interactive = isatty(0 as libc::c_int);
    stdout_is_console = isatty(1 as libc::c_int);
    if !(getenv(b"SQLITE_DEBUG_BREAK\0" as *const u8 as *const libc::c_char)).is_null() {
        if isatty(0 as libc::c_int) != 0 && isatty(2 as libc::c_int) != 0 {
            fprintf(
                stderr,
                b"attach debugger to process %d and press any key to continue.\n\0"
                    as *const u8 as *const libc::c_char,
                getpid(),
            );
            fgetc(stdin);
        } else {
            raise(5 as libc::c_int);
        }
    }
    if cli_strncmp(
        sqlite3_sourceid(),
        b"2022-12-02 18:56:37 57dd593ef0efa17dfb3a9f4eac36d5b8b879e271de817d8cd94a8c8b56d3alt1\0"
            as *const u8 as *const libc::c_char,
        60 as libc::c_int as size_t,
    ) != 0 as libc::c_int
    {
        fprintf(
            stderr,
            b"SQLite header and source version mismatch\n%s\n%s\n\0" as *const u8
                as *const libc::c_char,
            sqlite3_sourceid(),
            b"2022-12-02 18:56:37 57dd593ef0efa17dfb3a9f4eac36d5b8b879e271de817d8cd94a8c8b56d3alt1\0"
                as *const u8 as *const libc::c_char,
        );
        exit(1 as libc::c_int);
    }
    main_init(&mut data);
    Argv0 = *argv.offset(0 as libc::c_int as isize);
    signal(
        2 as libc::c_int,
        Some(interrupt_handler as unsafe extern "C" fn(libc::c_int) -> ()),
    );
    verify_uninitialized();
    i = 1 as libc::c_int;
    while i < argc {
        let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
        z = *argv.offset(i as isize);
        if *z.offset(0 as libc::c_int as isize) as libc::c_int != '-' as i32 {
            if ((*(data.aAuxDb).as_mut_ptr()).zDbFilename).is_null() {
                let ref mut fresh470 = (*(data.aAuxDb).as_mut_ptr()).zDbFilename;
                *fresh470 = z;
            } else {
                readStdin = 0 as libc::c_int;
                nCmd += 1;
                azCmd = realloc(
                    azCmd as *mut libc::c_void,
                    (::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong)
                        .wrapping_mul(nCmd as libc::c_ulong),
                ) as *mut *mut libc::c_char;
                shell_check_oom(azCmd as *mut libc::c_void);
                let ref mut fresh471 = *azCmd.offset((nCmd - 1 as libc::c_int) as isize);
                *fresh471 = z;
            }
        }
        if *z.offset(1 as libc::c_int as isize) as libc::c_int == '-' as i32 {
            z = z.offset(1);
        }
        if cli_strcmp(z, b"-separator\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
            || cli_strcmp(z, b"-nullvalue\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            || cli_strcmp(z, b"-newline\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            || cli_strcmp(z, b"-cmd\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
        {
            i += 1;
            cmdline_option_value(argc, argv, i);
        } else if cli_strcmp(z, b"-init\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            i += 1;
            zInitFile = cmdline_option_value(argc, argv, i);
        } else if cli_strcmp(z, b"-batch\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            stdin_is_interactive = 0 as libc::c_int;
        } else if cli_strcmp(z, b"-heap\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            i += 1;
            cmdline_option_value(argc, argv, i);
        } else if cli_strcmp(z, b"-pagecache\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            let mut n: sqlite3_int64 = 0;
            let mut sz: sqlite3_int64 = 0;
            i += 1;
            sz = integerValue(cmdline_option_value(argc, argv, i));
            if sz > 70000 as libc::c_int as libc::c_longlong {
                sz = 70000 as libc::c_int as sqlite3_int64;
            }
            if sz < 0 as libc::c_int as libc::c_longlong {
                sz = 0 as libc::c_int as sqlite3_int64;
            }
            i += 1;
            n = integerValue(cmdline_option_value(argc, argv, i));
            if sz > 0 as libc::c_int as libc::c_longlong
                && n > 0 as libc::c_int as libc::c_longlong
                && 0xffffffffffff as libc::c_longlong / sz < n
            {
                n = 0xffffffffffff as libc::c_longlong / sz;
            }
            sqlite3_config(
                7 as libc::c_int,
                if n > 0 as libc::c_int as libc::c_longlong
                    && sz > 0 as libc::c_int as libc::c_longlong
                {
                    malloc((n * sz) as libc::c_ulong)
                } else {
                    0 as *mut libc::c_void
                },
                sz,
                n,
            );
            data.shellFlgs |= 0x1 as libc::c_int as libc::c_uint;
        } else if cli_strcmp(z, b"-lookaside\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            let mut n_0: libc::c_int = 0;
            let mut sz_0: libc::c_int = 0;
            i += 1;
            sz_0 = integerValue(cmdline_option_value(argc, argv, i)) as libc::c_int;
            if sz_0 < 0 as libc::c_int {
                sz_0 = 0 as libc::c_int;
            }
            i += 1;
            n_0 = integerValue(cmdline_option_value(argc, argv, i)) as libc::c_int;
            if n_0 < 0 as libc::c_int {
                n_0 = 0 as libc::c_int;
            }
            sqlite3_config(13 as libc::c_int, sz_0, n_0);
            if sz_0 * n_0 == 0 as libc::c_int {
                data.shellFlgs &= !(0x2 as libc::c_int) as libc::c_uint;
            }
        } else if cli_strcmp(z, b"-threadsafe\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            let mut n_1: libc::c_int = 0;
            i += 1;
            n_1 = integerValue(cmdline_option_value(argc, argv, i)) as libc::c_int;
            match n_1 {
                0 => {
                    sqlite3_config(1 as libc::c_int);
                }
                2 => {
                    sqlite3_config(2 as libc::c_int);
                }
                _ => {
                    sqlite3_config(3 as libc::c_int);
                }
            }
        } else if cli_strcmp(z, b"-mmap\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            i += 1;
            let mut sz_1: sqlite3_int64 = integerValue(
                cmdline_option_value(argc, argv, i),
            );
            sqlite3_config(22 as libc::c_int, sz_1, sz_1);
        } else if cli_strcmp(z, b"-vfs\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            i += 1;
            zVfs = cmdline_option_value(argc, argv, i);
        } else if cli_strcmp(z, b"-zip\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            data.openMode = 3 as libc::c_int as u8_0;
        } else if cli_strcmp(z, b"-append\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            data.openMode = 2 as libc::c_int as u8_0;
        } else if cli_strcmp(z, b"-deserialize\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            data.openMode = 5 as libc::c_int as u8_0;
        } else if cli_strcmp(z, b"-maxsize\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int && (i + 1 as libc::c_int) < argc
        {
            i += 1;
            data.szMax = integerValue(*argv.offset(i as isize));
        } else if cli_strcmp(z, b"-readonly\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            data.openMode = 4 as libc::c_int as u8_0;
        } else if cli_strcmp(z, b"-nofollow\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            data.openFlags = 0x1000000 as libc::c_int;
        } else {
            if cli_strncmp(
                z,
                b"-A\0" as *const u8 as *const libc::c_char,
                2 as libc::c_int as size_t,
            ) == 0 as libc::c_int
            {
                break;
            }
            if cli_strcmp(z, b"-memtrace\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                sqlite3MemTraceActivate(stderr);
            } else if cli_strcmp(z, b"-bail\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                bail_on_error = 1 as libc::c_int;
            } else if cli_strcmp(z, b"-nonce\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                free(data.zNonce as *mut libc::c_void);
                i += 1;
                data.zNonce = strdup(*argv.offset(i as isize));
            } else {
                cli_strcmp(z, b"-safe\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int;
            }
        }
        i += 1;
    }
    verify_uninitialized();
    sqlite3_initialize();
    if !zVfs.is_null() {
        let mut pVfs: *mut sqlite3_vfs = sqlite3_vfs_find(zVfs);
        if !pVfs.is_null() {
            sqlite3_vfs_register(pVfs, 1 as libc::c_int);
        } else {
            fprintf(
                stderr,
                b"no such VFS: \"%s\"\n\0" as *const u8 as *const libc::c_char,
                zVfs,
            );
            exit(1 as libc::c_int);
        }
    }
    if ((*data.pAuxDb).zDbFilename).is_null() {
        let ref mut fresh472 = (*data.pAuxDb).zDbFilename;
        *fresh472 = b":memory:\0" as *const u8 as *const libc::c_char;
        warnInmemoryDb = (argc == 1 as libc::c_int) as libc::c_int;
    }
    data.out = stdout;
    sqlite3_appendvfs_init(
        0 as *mut sqlite3,
        0 as *mut *mut libc::c_char,
        0 as *const sqlite3_api_routines,
    );
    if access((*data.pAuxDb).zDbFilename, 0 as libc::c_int) == 0 as libc::c_int {
        open_db(&mut data, 0 as libc::c_int);
    }
    process_sqliterc(&mut data, zInitFile);
    i = 1 as libc::c_int;
    while i < argc {
        let mut z_0: *mut libc::c_char = *argv.offset(i as isize);
        if !(*z_0.offset(0 as libc::c_int as isize) as libc::c_int != '-' as i32) {
            if *z_0.offset(1 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                z_0 = z_0.offset(1);
            }
            if cli_strcmp(z_0, b"-init\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                i += 1;
            } else if cli_strcmp(z_0, b"-html\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.mode = 4 as libc::c_int;
            } else if cli_strcmp(z_0, b"-list\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.mode = 2 as libc::c_int;
            } else if cli_strcmp(z_0, b"-quote\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.mode = 6 as libc::c_int;
                sqlite3_snprintf(
                    ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                        as libc::c_int,
                    (data.colSeparator).as_mut_ptr(),
                    b",\0" as *const u8 as *const libc::c_char,
                );
                sqlite3_snprintf(
                    ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                        as libc::c_int,
                    (data.rowSeparator).as_mut_ptr(),
                    b"\n\0" as *const u8 as *const libc::c_char,
                );
            } else if cli_strcmp(z_0, b"-line\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.mode = 0 as libc::c_int;
            } else if cli_strcmp(z_0, b"-column\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.mode = 1 as libc::c_int;
            } else if cli_strcmp(z_0, b"-json\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.mode = 13 as libc::c_int;
            } else if cli_strcmp(z_0, b"-markdown\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.mode = 14 as libc::c_int;
            } else if cli_strcmp(z_0, b"-table\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.mode = 15 as libc::c_int;
            } else if cli_strcmp(z_0, b"-box\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.mode = 16 as libc::c_int;
            } else if cli_strcmp(z_0, b"-csv\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.mode = 8 as libc::c_int;
                memcpy(
                    (data.colSeparator).as_mut_ptr() as *mut libc::c_void,
                    b",\0" as *const u8 as *const libc::c_char as *const libc::c_void,
                    2 as libc::c_int as libc::c_ulong,
                );
            } else if cli_strcmp(z_0, b"-zip\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.openMode = 3 as libc::c_int as u8_0;
            } else if cli_strcmp(z_0, b"-append\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.openMode = 2 as libc::c_int as u8_0;
            } else if cli_strcmp(
                z_0,
                b"-deserialize\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
            {
                data.openMode = 5 as libc::c_int as u8_0;
            } else if cli_strcmp(z_0, b"-maxsize\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int && (i + 1 as libc::c_int) < argc
            {
                i += 1;
                data.szMax = integerValue(*argv.offset(i as isize));
            } else if cli_strcmp(z_0, b"-readonly\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.openMode = 4 as libc::c_int as u8_0;
            } else if cli_strcmp(z_0, b"-nofollow\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.openFlags |= 0x1000000 as libc::c_int;
            } else if cli_strcmp(z_0, b"-ascii\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.mode = 10 as libc::c_int;
                sqlite3_snprintf(
                    ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                        as libc::c_int,
                    (data.colSeparator).as_mut_ptr(),
                    b"\x1F\0" as *const u8 as *const libc::c_char,
                );
                sqlite3_snprintf(
                    ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                        as libc::c_int,
                    (data.rowSeparator).as_mut_ptr(),
                    b"\x1E\0" as *const u8 as *const libc::c_char,
                );
            } else if cli_strcmp(z_0, b"-tabs\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.mode = 2 as libc::c_int;
                sqlite3_snprintf(
                    ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                        as libc::c_int,
                    (data.colSeparator).as_mut_ptr(),
                    b"\t\0" as *const u8 as *const libc::c_char,
                );
                sqlite3_snprintf(
                    ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                        as libc::c_int,
                    (data.rowSeparator).as_mut_ptr(),
                    b"\n\0" as *const u8 as *const libc::c_char,
                );
            } else if cli_strcmp(
                z_0,
                b"-separator\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
            {
                i += 1;
                sqlite3_snprintf(
                    ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                        as libc::c_int,
                    (data.colSeparator).as_mut_ptr(),
                    b"%s\0" as *const u8 as *const libc::c_char,
                    cmdline_option_value(argc, argv, i),
                );
            } else if cli_strcmp(z_0, b"-newline\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                i += 1;
                sqlite3_snprintf(
                    ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                        as libc::c_int,
                    (data.rowSeparator).as_mut_ptr(),
                    b"%s\0" as *const u8 as *const libc::c_char,
                    cmdline_option_value(argc, argv, i),
                );
            } else if cli_strcmp(
                z_0,
                b"-nullvalue\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
            {
                i += 1;
                sqlite3_snprintf(
                    ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                        as libc::c_int,
                    (data.nullValue).as_mut_ptr(),
                    b"%s\0" as *const u8 as *const libc::c_char,
                    cmdline_option_value(argc, argv, i),
                );
            } else if cli_strcmp(z_0, b"-header\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.showHeader = 1 as libc::c_int;
                data.shellFlgs |= 0x80 as libc::c_int as libc::c_uint;
            } else if cli_strcmp(z_0, b"-noheader\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.showHeader = 0 as libc::c_int;
                data.shellFlgs |= 0x80 as libc::c_int as libc::c_uint;
            } else if cli_strcmp(z_0, b"-echo\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.shellFlgs |= 0x40 as libc::c_int as libc::c_uint;
            } else if cli_strcmp(z_0, b"-eqp\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.autoEQP = 1 as libc::c_int as u8_0;
            } else if cli_strcmp(z_0, b"-eqpfull\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.autoEQP = 3 as libc::c_int as u8_0;
            } else if cli_strcmp(z_0, b"-stats\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.statsOn = 1 as libc::c_int as libc::c_uint;
            } else if cli_strcmp(
                z_0,
                b"-scanstats\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
            {
                data.scanstatsOn = 1 as libc::c_int as u8_0;
            } else if cli_strcmp(
                z_0,
                b"-backslash\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
            {
                data.shellFlgs |= 0x4 as libc::c_int as libc::c_uint;
            } else if !(cli_strcmp(z_0, b"-bail\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int)
            {
                if cli_strcmp(z_0, b"-version\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    printf(
                        b"%s %s (libSQL %s)\n\0" as *const u8 as *const libc::c_char,
                        sqlite3_libversion(),
                        sqlite3_sourceid(),
                        libsql_libversion(),
                    );
                    return 0 as libc::c_int;
                } else if cli_strcmp(
                    z_0,
                    b"-interactive\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
                {
                    stdin_is_interactive = 1 as libc::c_int;
                } else if cli_strcmp(
                    z_0,
                    b"-batch\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
                {
                    stdin_is_interactive = 0 as libc::c_int;
                } else if cli_strcmp(z_0, b"-heap\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    i += 1;
                } else if cli_strcmp(
                    z_0,
                    b"-pagecache\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
                {
                    i += 2 as libc::c_int;
                } else if cli_strcmp(
                    z_0,
                    b"-lookaside\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
                {
                    i += 2 as libc::c_int;
                } else if cli_strcmp(
                    z_0,
                    b"-threadsafe\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
                {
                    i += 2 as libc::c_int;
                } else if cli_strcmp(
                    z_0,
                    b"-nonce\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
                {
                    i += 2 as libc::c_int;
                } else if cli_strcmp(z_0, b"-mmap\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    i += 1;
                } else if cli_strcmp(
                    z_0,
                    b"-memtrace\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
                {
                    i += 1;
                } else if cli_strcmp(z_0, b"-vfs\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    i += 1;
                } else if cli_strcmp(z_0, b"-help\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    usage(1 as libc::c_int);
                } else if cli_strcmp(z_0, b"-cmd\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    if i == argc - 1 as libc::c_int {
                        break;
                    }
                    i += 1;
                    z_0 = cmdline_option_value(argc, argv, i);
                    if *z_0.offset(0 as libc::c_int as isize) as libc::c_int
                        == '.' as i32
                    {
                        rc = do_meta_command(z_0, &mut data);
                        if rc != 0 && bail_on_error != 0 {
                            return if rc == 2 as libc::c_int {
                                0 as libc::c_int
                            } else {
                                rc
                            };
                        }
                    } else {
                        open_db(&mut data, 0 as libc::c_int);
                        rc = shell_exec(&mut data, z_0, &mut zErrMsg);
                        if !zErrMsg.is_null() {
                            fprintf(
                                stderr,
                                b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                                zErrMsg,
                            );
                            if bail_on_error != 0 {
                                return if rc != 0 as libc::c_int {
                                    rc
                                } else {
                                    1 as libc::c_int
                                };
                            }
                        } else if rc != 0 as libc::c_int {
                            fprintf(
                                stderr,
                                b"Error: unable to process SQL \"%s\"\n\0" as *const u8
                                    as *const libc::c_char,
                                z_0,
                            );
                            if bail_on_error != 0 {
                                return rc;
                            }
                        }
                    }
                } else if cli_strncmp(
                    z_0,
                    b"-A\0" as *const u8 as *const libc::c_char,
                    2 as libc::c_int as size_t,
                ) == 0 as libc::c_int
                {
                    if nCmd > 0 as libc::c_int {
                        fprintf(
                            stderr,
                            b"Error: cannot mix regular SQL or dot-commands with \"%s\"\n\0"
                                as *const u8 as *const libc::c_char,
                            z_0,
                        );
                        return 1 as libc::c_int;
                    }
                    open_db(&mut data, 0x2 as libc::c_int);
                    if *z_0.offset(2 as libc::c_int as isize) != 0 {
                        let ref mut fresh473 = *argv.offset(i as isize);
                        *fresh473 = &mut *z_0.offset(2 as libc::c_int as isize)
                            as *mut libc::c_char;
                        arDotCommand(
                            &mut data,
                            1 as libc::c_int,
                            argv.offset((i - 1 as libc::c_int) as isize),
                            argc - (i - 1 as libc::c_int),
                        );
                    } else {
                        arDotCommand(
                            &mut data,
                            1 as libc::c_int,
                            argv.offset(i as isize),
                            argc - i,
                        );
                    }
                    readStdin = 0 as libc::c_int;
                    break;
                } else if cli_strcmp(z_0, b"-safe\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    data.bSafeModePersist = 1 as libc::c_int as u8_0;
                    data.bSafeMode = data.bSafeModePersist;
                } else {
                    fprintf(
                        stderr,
                        b"%s: Error: unknown option: %s\n\0" as *const u8
                            as *const libc::c_char,
                        Argv0,
                        z_0,
                    );
                    fprintf(
                        stderr,
                        b"Use -help for a list of options.\n\0" as *const u8
                            as *const libc::c_char,
                    );
                    return 1 as libc::c_int;
                }
            }
            data.cMode = data.mode;
        }
        i += 1;
    }
    if readStdin == 0 {
        i = 0 as libc::c_int;
        while i < nCmd {
            if *(*azCmd.offset(i as isize)).offset(0 as libc::c_int as isize)
                as libc::c_int == '.' as i32
            {
                rc = do_meta_command(*azCmd.offset(i as isize), &mut data);
                if rc != 0 {
                    free(azCmd as *mut libc::c_void);
                    return if rc == 2 as libc::c_int { 0 as libc::c_int } else { rc };
                }
            } else {
                open_db(&mut data, 0 as libc::c_int);
                rc = shell_exec(&mut data, *azCmd.offset(i as isize), &mut zErrMsg);
                if !zErrMsg.is_null() || rc != 0 {
                    if !zErrMsg.is_null() {
                        fprintf(
                            stderr,
                            b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                            zErrMsg,
                        );
                    } else {
                        fprintf(
                            stderr,
                            b"Error: unable to process SQL: %s\n\0" as *const u8
                                as *const libc::c_char,
                            *azCmd.offset(i as isize),
                        );
                    }
                    sqlite3_free(zErrMsg as *mut libc::c_void);
                    free(azCmd as *mut libc::c_void);
                    return if rc != 0 as libc::c_int { rc } else { 1 as libc::c_int };
                }
            }
            i += 1;
        }
    } else if stdin_is_interactive != 0 {
        let mut zHome: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut zHistory: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut nHistory: libc::c_int = 0;
        printf(
            b"libSQL version %s (based on SQLite version %s) %.19s\nEnter \".help\" for usage hints.\n\0"
                as *const u8 as *const libc::c_char,
            libsql_libversion(),
            sqlite3_libversion(),
            sqlite3_sourceid(),
        );
        if warnInmemoryDb != 0 {
            printf(b"Connected to a \0" as *const u8 as *const libc::c_char);
            printBold(
                b"transient in-memory database\0" as *const u8 as *const libc::c_char,
            );
            printf(
                b".\nUse \".open FILENAME\" to reopen on a persistent database.\n\0"
                    as *const u8 as *const libc::c_char,
            );
        }
        zHistory = getenv(b"SQLITE_HISTORY\0" as *const u8 as *const libc::c_char);
        if !zHistory.is_null() {
            zHistory = strdup(zHistory);
        } else {
            zHome = find_home_dir(0 as libc::c_int);
            if !zHome.is_null() {
                nHistory = strlen30(zHome) + 20 as libc::c_int;
                zHistory = malloc(nHistory as libc::c_ulong) as *mut libc::c_char;
                if !zHistory.is_null() {
                    sqlite3_snprintf(
                        nHistory,
                        zHistory,
                        b"%s/.sqlite_history\0" as *const u8 as *const libc::c_char,
                        zHome,
                    );
                }
            }
        }
        if !zHistory.is_null() {
            read_history(zHistory);
        }
        rl_attempted_completion_function = Some(
            readline_completion
                as unsafe extern "C" fn(
                    *const libc::c_char,
                    libc::c_int,
                    libc::c_int,
                ) -> *mut *mut libc::c_char,
        );
        data.in_0 = 0 as *mut FILE;
        rc = process_input(&mut data);
        if !zHistory.is_null() {
            stifle_history(2000 as libc::c_int);
            write_history(zHistory);
            free(zHistory as *mut libc::c_void);
        }
    } else {
        data.in_0 = stdin;
        rc = process_input(&mut data);
    }
    free(azCmd as *mut libc::c_void);
    set_table_name(&mut data, 0 as *const libc::c_char);
    if !(data.db).is_null() {
        close_db(data.db);
    }
    i = 0 as libc::c_int;
    while i
        < (::std::mem::size_of::<[AuxDb; 5]>() as libc::c_ulong)
            .wrapping_div(::std::mem::size_of::<AuxDb>() as libc::c_ulong) as libc::c_int
    {
        sqlite3_free(data.aAuxDb[i as usize].zFreeOnClose as *mut libc::c_void);
        if !(data.aAuxDb[i as usize].db).is_null() {
            close_db(data.aAuxDb[i as usize].db);
        }
        i += 1;
    }
    find_home_dir(1 as libc::c_int);
    output_reset(&mut data);
    data.doXdgOpen = 0 as libc::c_int as u8_0;
    clearTempFile(&mut data);
    free(data.colWidth as *mut libc::c_void);
    free(data.zNonce as *mut libc::c_void);
    memset(
        &mut data as *mut ShellState as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<ShellState>() as libc::c_ulong,
    );
    return rc;
}
pub fn main() {
    let mut args: Vec::<*mut libc::c_char> = Vec::new();
    for arg in ::std::env::args() {
        args.push(
            (::std::ffi::CString::new(arg))
                .expect("Failed to convert argument into CString.")
                .into_raw(),
        );
    }
    args.push(::std::ptr::null_mut());
    unsafe {
        ::std::process::exit(
            main_0(
                (args.len() - 1) as libc::c_int,
                args.as_mut_ptr() as *mut *mut libc::c_char,
            ) as i32,
        )
    }
}
